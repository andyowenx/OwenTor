# 1 "routerlist.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "routerlist.c"
# 15 "routerlist.c"
# 1 "or.h" 1
# 15 "or.h"
# 1 "../win32/orconfig.h" 1
# 16 "or.h" 2
# 36 "or.h"
# 1 "/usr/include/signal.h" 1 3 4
# 28 "/usr/include/signal.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 29 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 102 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 33 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;








typedef __sigset_t sigset_t;






# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 57 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 58 "/usr/include/signal.h" 2 3 4



typedef __pid_t pid_t;





typedef __uid_t uid_t;







# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 76 "/usr/include/signal.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
     short int si_addr_lsb;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t ;
# 153 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 303 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
typedef union pthread_attr_t pthread_attr_t;



typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 81 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 100 "/usr/include/signal.h" 3 4


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4

# 127 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);




extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 167 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 189 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 209 "/usr/include/signal.h" 3 4
typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 246 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 303 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 327 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 121 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 333 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 343 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 350 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;





typedef greg_t gregset_t[23];
# 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 353 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));
# 387 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};







typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 388 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));
# 389 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 37 "or.h" 2







# 1 "../common/torint.h" 1
# 14 "../common/torint.h"
# 1 "../win32/orconfig.h" 1
# 15 "../common/torint.h" 2





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 86 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __off_t off_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 43 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4

# 21 "../common/torint.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 24 "../common/torint.h" 2
# 76 "../common/torint.h"
typedef signed char int8_t;



typedef unsigned char uint8_t;






typedef signed short int16_t;



typedef unsigned short uint16_t;
# 107 "../common/torint.h"
typedef signed int int32_t;



typedef unsigned int uint32_t;
# 179 "../common/torint.h"
typedef signed __int64 int64_t;



typedef unsigned __int64 uint64_t;
# 212 "../common/torint.h"
typedef int32_t ssize_t;
# 229 "../common/torint.h"
typedef int32_t intptr_t;



typedef uint32_t uintptr_t;
# 45 "or.h" 2




# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };
# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 341 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4

# 415 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4

# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 67 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 68 "/usr/include/fcntl.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };
# 69 "/usr/include/fcntl.h" 2 3 4
# 137 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 146 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 170 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 192 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 221 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, off_t __len);
# 238 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 282 "/usr/include/fcntl.h" 3 4

# 50 "or.h" 2
# 58 "or.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 103 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 106 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 209 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 238 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 263 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 284 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));
# 321 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 399 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 442 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 59 "or.h" 2
# 67 "or.h"
# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 58 "/usr/include/errno.h" 3 4

# 68 "or.h" 2


# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 71 "or.h" 2


# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 42 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

# 221 "/usr/include/time.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 236 "/usr/include/time.h" 3 4



extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));
# 430 "/usr/include/time.h" 3 4

# 74 "or.h" 2
# 89 "or.h"
# 1 "../common/crypto.h" 1
# 16 "../common/crypto.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 306 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 913 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "/usr/include/stdio.h" 3 4

# 17 "../common/crypto.h" 2
# 1 "../common/torint.h" 1
# 18 "../common/crypto.h" 2
# 1 "../common/testsupport.h" 1
# 19 "../common/crypto.h" 2
# 87 "../common/crypto.h"
typedef enum {
  DIGEST_SHA1 = 0,
  DIGEST_SHA256 = 1,
} digest_algorithm_t;
# 102 "../common/crypto.h"
typedef struct {
  char d[(DIGEST_SHA256+1)][32];
} digests_t;

typedef struct crypto_pk_t crypto_pk_t;
typedef struct crypto_cipher_t crypto_cipher_t;
typedef struct crypto_digest_t crypto_digest_t;
typedef struct crypto_dh_t crypto_dh_t;


const char * crypto_openssl_get_version_str(void);
const char * crypto_openssl_get_header_version_str(void);
int crypto_early_init(void);
int crypto_global_init(int hardwareAccel,
                       const char *accelName,
                       const char *accelPath);
void crypto_thread_cleanup(void);
int crypto_global_cleanup(void);


crypto_pk_t *crypto_pk_new(void);
void crypto_pk_free(crypto_pk_t *env);

void crypto_set_tls_dh_prime(const char *dynamic_dh_modulus_fname);

crypto_cipher_t *crypto_cipher_new(const char *key);
crypto_cipher_t *crypto_cipher_new_with_iv(const char *key, const char *iv);
void crypto_cipher_free(crypto_cipher_t *env);


int crypto_pk_generate_key_with_bits(crypto_pk_t *env, int bits);



int crypto_pk_read_private_key_from_filename(crypto_pk_t *env,
                                             const char *keyfile);
int crypto_pk_write_public_key_to_string(crypto_pk_t *env,
                                         char **dest, size_t *len);
int crypto_pk_write_private_key_to_string(crypto_pk_t *env,
                                          char **dest, size_t *len);
int crypto_pk_read_public_key_from_string(crypto_pk_t *env,
                                          const char *src, size_t len);
int crypto_pk_read_private_key_from_string(crypto_pk_t *env,
                                           const char *s, ssize_t len);
int crypto_pk_write_private_key_to_filename(crypto_pk_t *env,
                                            const char *fname);

int crypto_pk_check_key(crypto_pk_t *env);
int crypto_pk_cmp_keys(crypto_pk_t *a, crypto_pk_t *b);
int crypto_pk_eq_keys(crypto_pk_t *a, crypto_pk_t *b);
size_t crypto_pk_keysize(crypto_pk_t *env);
int crypto_pk_num_bits(crypto_pk_t *env);
crypto_pk_t *crypto_pk_dup_key(crypto_pk_t *orig);
crypto_pk_t *crypto_pk_copy_full(crypto_pk_t *orig);
int crypto_pk_key_is_private(const crypto_pk_t *key);
int crypto_pk_public_exponent_ok(crypto_pk_t *env);

int crypto_pk_public_encrypt(crypto_pk_t *env, char *to, size_t tolen,
                             const char *from, size_t fromlen, int padding);
int crypto_pk_private_decrypt(crypto_pk_t *env, char *to, size_t tolen,
                              const char *from, size_t fromlen,
                              int padding, int warnOnFailure);
int crypto_pk_public_checksig(crypto_pk_t *env, char *to, size_t tolen,
                              const char *from, size_t fromlen);
int crypto_pk_public_checksig_digest(crypto_pk_t *env, const char *data,
                               size_t datalen, const char *sig, size_t siglen);
int crypto_pk_private_sign(crypto_pk_t *env, char *to, size_t tolen,
                           const char *from, size_t fromlen);
int crypto_pk_private_sign_digest(crypto_pk_t *env, char *to, size_t tolen,
                                  const char *from, size_t fromlen);
int crypto_pk_public_hybrid_encrypt(crypto_pk_t *env, char *to,
                                    size_t tolen,
                                    const char *from, size_t fromlen,
                                    int padding, int force);
int crypto_pk_private_hybrid_decrypt(crypto_pk_t *env, char *to,
                                     size_t tolen,
                                     const char *from, size_t fromlen,
                                     int padding, int warnOnFailure);

int crypto_pk_asn1_encode(crypto_pk_t *pk, char *dest, size_t dest_len);
crypto_pk_t *crypto_pk_asn1_decode(const char *str, size_t len);
int crypto_pk_get_digest(const crypto_pk_t *pk, char *digest_out);
int crypto_pk_get_all_digests(crypto_pk_t *pk, digests_t *digests_out);
int crypto_pk_get_fingerprint(crypto_pk_t *pk, char *fp_out,int add_space);
int crypto_pk_get_hashed_fingerprint(crypto_pk_t *pk, char *fp_out);


const char *crypto_cipher_get_key(crypto_cipher_t *env);

int crypto_cipher_encrypt(crypto_cipher_t *env, char *to,
                          const char *from, size_t fromlen);
int crypto_cipher_decrypt(crypto_cipher_t *env, char *to,
                          const char *from, size_t fromlen);
int crypto_cipher_crypt_inplace(crypto_cipher_t *env, char *d, size_t len);

int crypto_cipher_encrypt_with_iv(const char *key,
                                  char *to, size_t tolen,
                                  const char *from, size_t fromlen);
int crypto_cipher_decrypt_with_iv(const char *key,
                                  char *to, size_t tolen,
                                  const char *from, size_t fromlen);


int crypto_digest(char *digest, const char *m, size_t len);
int crypto_digest256(char *digest, const char *m, size_t len,
                     digest_algorithm_t algorithm);
int crypto_digest_all(digests_t *ds_out, const char *m, size_t len);
struct smartlist_t;
void crypto_digest_smartlist(char *digest_out, size_t len_out,
                             const struct smartlist_t *lst, const char *append,
                             digest_algorithm_t alg);
const char *crypto_digest_algorithm_get_name(digest_algorithm_t alg);
int crypto_digest_algorithm_parse_name(const char *name);
crypto_digest_t *crypto_digest_new(void);
crypto_digest_t *crypto_digest256_new(digest_algorithm_t algorithm);
void crypto_digest_free(crypto_digest_t *digest);
void crypto_digest_add_bytes(crypto_digest_t *digest, const char *data,
                             size_t len);
void crypto_digest_get_digest(crypto_digest_t *digest,
                              char *out, size_t out_len);
crypto_digest_t *crypto_digest_dup(const crypto_digest_t *digest);
void crypto_digest_assign(crypto_digest_t *into,
                          const crypto_digest_t *from);
void crypto_hmac_sha256(char *hmac_out,
                        const char *key, size_t key_len,
                        const char *msg, size_t msg_len);





crypto_dh_t *crypto_dh_new(int dh_type);
crypto_dh_t *crypto_dh_dup(const crypto_dh_t *dh);
int crypto_dh_get_bytes(crypto_dh_t *dh);
int crypto_dh_generate_public(crypto_dh_t *dh);
int crypto_dh_get_public(crypto_dh_t *dh, char *pubkey_out,
                         size_t pubkey_out_len);
ssize_t crypto_dh_compute_secret(int severity, crypto_dh_t *dh,
                             const char *pubkey, size_t pubkey_len,
                             char *secret_out, size_t secret_out_len);
void crypto_dh_free(crypto_dh_t *dh);

int crypto_expand_key_material_TAP(const uint8_t *key_in,
                                   size_t key_in_len,
                                   uint8_t *key_out, size_t key_out_len);
int crypto_expand_key_material_rfc5869_sha256(
                                    const uint8_t *key_in, size_t key_in_len,
                                    const uint8_t *salt_in, size_t salt_in_len,
                                    const uint8_t *info_in, size_t info_in_len,
                                    uint8_t *key_out, size_t key_out_len);


int crypto_seed_rng(int startup);
int crypto_rand (char *to, size_t n);
int crypto_strongest_rand(uint8_t *out, size_t out_len);
int crypto_rand_int(unsigned int max);
uint64_t crypto_rand_uint64(uint64_t max);
double crypto_rand_double(void);
struct tor_weak_rng_t;
void crypto_seed_weak_rng(struct tor_weak_rng_t *rng);
int crypto_init_siphash_key(void);

char *crypto_random_hostname(int min_rand_len, int max_rand_len,
                             const char *prefix, const char *suffix);

struct smartlist_t;
void *smartlist_choose(const struct smartlist_t *sl);
void smartlist_shuffle(struct smartlist_t *sl);

int base64_encode(char *dest, size_t destlen, const char *src, size_t srclen);
int base64_decode(char *dest, size_t destlen, const char *src, size_t srclen);


void base32_encode(char *dest, size_t destlen, const char *src, size_t srclen);
int base32_decode(char *dest, size_t destlen, const char *src, size_t srclen);

int digest_to_base64(char *d64, const char *digest);
int digest_from_base64(char *digest, const char *d64);
int digest256_to_base64(char *d64, const char *digest);
int digest256_from_base64(char *digest, const char *d64);


void memwipe(void *mem, uint8_t byte, size_t sz);



struct rsa_st;
struct evp_pkey_st;
struct dh_st;
struct rsa_st *crypto_pk_get_rsa_(crypto_pk_t *env);
crypto_pk_t *crypto_new_pk_from_rsa_(struct rsa_st *rsa);
struct evp_pkey_st *crypto_pk_get_evp_pkey_(crypto_pk_t *env,
                                                int private);
struct dh_st *crypto_dh_get_dh_(crypto_dh_t *dh);

void crypto_add_spaces_to_fp(char *out, size_t outlen, const char *in);
# 90 "or.h" 2
# 1 "../common/tortls.h" 1
# 14 "../common/tortls.h"
# 1 "../common/crypto.h" 1
# 15 "../common/tortls.h" 2
# 1 "../common/compat.h" 1
# 9 "../common/compat.h"
# 1 "../win32/orconfig.h" 1
# 10 "../common/compat.h" 2
# 37 "../common/compat.h"
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 127 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 166 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4

# 236 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 282 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 427 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 445 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 534 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 644 "/usr/include/string.h" 3 4

# 38 "../common/compat.h" 2

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 40 "../common/compat.h" 2
# 54 "../common/compat.h"
# 1 "/usr/include/errno.h" 1 3 4
# 55 "../common/compat.h" 2
# 231 "../common/compat.h"
size_t strlcat(char *dst, const char *src, size_t siz) ;


size_t strlcpy(char *dst, const char *src, size_t siz) ;
# 283 "../common/compat.h"
typedef struct tor_mmap_t {
  const char *data;
  size_t size;
# 295 "../common/compat.h"
} tor_mmap_t;

tor_mmap_t *tor_mmap_file(const char *filename) ;
int tor_munmap_file(tor_mmap_t *handle) ;

int tor_snprintf(char *str, size_t size, const char *format, ...)
  __attribute__ ((format(printf, 3, 4))) ;
int tor_vsnprintf(char *str, size_t size, const char *format, va_list args)
  __attribute__ ((format(printf, 3, 0))) ;

int tor_asprintf(char **strp, const char *fmt, ...)
  __attribute__ ((format(printf, 2, 3)));
int tor_vasprintf(char **strp, const char *fmt, va_list args)
  __attribute__ ((format(printf, 2, 0)));

const void *tor_memmem(const void *haystack, size_t hlen, const void *needle,
                       size_t nlen) ;
static const void *tor_memstr(const void *haystack, size_t hlen,
                           const char *needle) ;
static inline const void *
tor_memstr(const void *haystack, size_t hlen, const char *needle)
{
  return tor_memmem(haystack, hlen, needle, strlen(needle));
}
# 329 "../common/compat.h"
static int TOR_ISALPHA(char c); extern const uint32_t TOR_ISALPHA_TABLE[]; static inline int TOR_ISALPHA(char c) { uint8_t u = c; return !!(TOR_ISALPHA_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISALNUM(char c); extern const uint32_t TOR_ISALNUM_TABLE[]; static inline int TOR_ISALNUM(char c) { uint8_t u = c; return !!(TOR_ISALNUM_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISSPACE(char c); extern const uint32_t TOR_ISSPACE_TABLE[]; static inline int TOR_ISSPACE(char c) { uint8_t u = c; return !!(TOR_ISSPACE_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISDIGIT(char c); extern const uint32_t TOR_ISDIGIT_TABLE[]; static inline int TOR_ISDIGIT(char c) { uint8_t u = c; return !!(TOR_ISDIGIT_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISXDIGIT(char c); extern const uint32_t TOR_ISXDIGIT_TABLE[]; static inline int TOR_ISXDIGIT(char c) { uint8_t u = c; return !!(TOR_ISXDIGIT_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISPRINT(char c); extern const uint32_t TOR_ISPRINT_TABLE[]; static inline int TOR_ISPRINT(char c) { uint8_t u = c; return !!(TOR_ISPRINT_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISLOWER(char c); extern const uint32_t TOR_ISLOWER_TABLE[]; static inline int TOR_ISLOWER(char c) { uint8_t u = c; return !!(TOR_ISLOWER_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
static int TOR_ISUPPER(char c); extern const uint32_t TOR_ISUPPER_TABLE[]; static inline int TOR_ISUPPER(char c) { uint8_t u = c; return !!(TOR_ISUPPER_TABLE[(u >> 5) & 7] & (1u << (u & 31))); }
extern const char TOR_TOUPPER_TABLE[];
extern const char TOR_TOLOWER_TABLE[];



char *tor_strtok_r_impl(char *str, const char *sep, char **lasts);
# 366 "../common/compat.h"
void tor_gettimeofday(struct timeval *timeval);

struct tm *tor_localtime_r(const time_t *timep, struct tm *result);
struct tm *tor_gmtime_r(const time_t *timep, struct tm *result);
# 414 "../common/compat.h"
int tor_open_cloexec(const char *path, int flags, unsigned mode);
FILE *tor_fopen_cloexec(const char *path, const char *mode);
int tor_rename(const char *path_old, const char *path_new);

int replace_file(const char *from, const char *to);
int touch_file(const char *fname);

typedef struct tor_lockfile_t tor_lockfile_t;
tor_lockfile_t *tor_lockfile_lock(const char *filename, int blocking,
                                  int *locked_out);
void tor_lockfile_unlock(tor_lockfile_t *lockfile);

off_t tor_fd_getpos(int fd);
int tor_fd_setpos(int fd, off_t pos);
int tor_fd_seekend(int fd);
int tor_ftruncate(int fd);
# 440 "../common/compat.h"
typedef int socklen_t;
# 461 "../common/compat.h"
int tor_close_socket_simple(int s);
int tor_close_socket(int s);
int tor_open_socket_with_extensions(
                                           int domain, int type, int protocol,
                                           int cloexec, int nonblock);
int tor_open_socket(int domain, int type, int protocol);
int tor_open_socket_nonblocking(int domain, int type, int protocol);
int tor_accept_socket(int sockfd, struct sockaddr *addr,
                                  socklen_t *len);
int tor_accept_socket_nonblocking(int sockfd,
                                           struct sockaddr *addr,
                                           socklen_t *len);
int tor_accept_socket_with_extensions(int sockfd,
                                               struct sockaddr *addr,
                                               socklen_t *len,
                                               int cloexec, int nonblock);
int get_n_open_sockets(void);
# 514 "../common/compat.h"
typedef uint16_t sa_family_t;
# 544 "../common/compat.h"
int tor_gethostname (char *name, size_t namelen);
int tor_inet_aton(const char *cp, struct in_addr *addr) ;
const char *tor_inet_ntop(int af, const void *src, char *dst, size_t len);
int tor_inet_pton(int af, const char *src, void *dst);
int tor_lookup_hostname (const char *name, uint32_t *addr);
int set_socket_nonblocking(int socket);
int tor_socketpair(int family, int type, int protocol, int fd[2]);
int network_init(void);
# 601 "../common/compat.h"
typedef enum {
  SOCKS5_SUCCEEDED = 0x00,
  SOCKS5_GENERAL_ERROR = 0x01,
  SOCKS5_NOT_ALLOWED = 0x02,
  SOCKS5_NET_UNREACHABLE = 0x03,
  SOCKS5_HOST_UNREACHABLE = 0x04,
  SOCKS5_CONNECTION_REFUSED = 0x05,
  SOCKS5_TTL_EXPIRED = 0x06,
  SOCKS5_COMMAND_NOT_SUPPORTED = 0x07,
  SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED = 0x08,
} socks5_reply_status_t;


const char *get_uname(void);

uint16_t get_uint16(const void *cp) ;
uint32_t get_uint32(const void *cp) ;
uint64_t get_uint64(const void *cp) ;
void set_uint16(void *cp, uint16_t v) ;
void set_uint32(void *cp, uint32_t v) ;
void set_uint64(void *cp, uint64_t v) ;



static void set_uint8(void *cp, uint8_t v);
static inline void
set_uint8(void *cp, uint8_t v)
{
  *(uint8_t*)cp = v;
}


typedef unsigned long rlim_t;

int set_max_file_descriptors(rlim_t limit, int *max);
int tor_disable_debugger_attach(void);
int switch_id(const char *user);





const struct passwd *tor_getpwnam(const char *username);
const struct passwd *tor_getpwuid(uid_t uid);


int get_parent_directory(char *fname);
char *make_path_absolute(char *fname);

char **get_environment(void);

int get_total_system_memory(size_t *mem_out);

int compute_num_cpus(void);

int tor_mlockall(void);
# 704 "../common/compat.h"
# 1 "../common/compat_threads.h" 1
# 9 "../common/compat_threads.h"
# 1 "../win32/orconfig.h" 1
# 10 "../common/compat_threads.h" 2
# 25 "../common/compat_threads.h"
int spawn_func(void (*func)(void *), void *data);
void spawn_exit(void) __attribute__((noreturn));






typedef struct tor_mutex_t {
# 43 "../common/compat_threads.h"
  int _unused;

} tor_mutex_t;

tor_mutex_t *tor_mutex_new(void);
tor_mutex_t *tor_mutex_new_nonrecursive(void);
void tor_mutex_init(tor_mutex_t *m);
void tor_mutex_init_nonrecursive(tor_mutex_t *m);
void tor_mutex_acquire(tor_mutex_t *m);
void tor_mutex_release(tor_mutex_t *m);
void tor_mutex_free(tor_mutex_t *m);
void tor_mutex_uninit(tor_mutex_t *m);
unsigned long tor_get_thread_id(void);
void tor_threads_init(void);




void set_main_thread(void);
int in_main_thread(void);

typedef struct tor_cond_t {
# 77 "../common/compat_threads.h"
} tor_cond_t;

tor_cond_t *tor_cond_new(void);
void tor_cond_free(tor_cond_t *cond);
int tor_cond_init(tor_cond_t *cond);
void tor_cond_uninit(tor_cond_t *cond);
int tor_cond_wait(tor_cond_t *cond, tor_mutex_t *mutex,
                  const struct timeval *tv);
void tor_cond_signal_one(tor_cond_t *cond);
void tor_cond_signal_all(tor_cond_t *cond);



typedef struct alert_sockets_s {




  int read_fd;

  int write_fd;

  int (*alert_fn)(int write_fd);

  int (*drain_fn)(int read_fd);
} alert_sockets_t;
# 111 "../common/compat_threads.h"
int alert_sockets_create(alert_sockets_t *socks_out, uint32_t flags);
void alert_sockets_close(alert_sockets_t *socks);
# 705 "../common/compat.h" 2
# 16 "../common/tortls.h" 2



typedef struct tor_tls_t tor_tls_t;


typedef struct tor_cert_t tor_cert_t;
# 54 "../common/tortls.h"
const char *tor_tls_err_to_string(int err);
void tor_tls_get_state_description(tor_tls_t *tls, char *buf, size_t sz);

void tor_tls_free_all(void);





int tor_tls_context_init(unsigned flags,
                         crypto_pk_t *client_identity,
                         crypto_pk_t *server_identity,
                         unsigned int key_lifetime);
tor_tls_t *tor_tls_new(int sock, int is_server);
void tor_tls_set_logged_address(tor_tls_t *tls, const char *address);
void tor_tls_set_renegotiate_callback(tor_tls_t *tls,
                                      void (*cb)(tor_tls_t *, void *arg),
                                      void *arg);
int tor_tls_is_server(tor_tls_t *tls);
void tor_tls_free(tor_tls_t *tls);
int tor_tls_peer_has_cert(tor_tls_t *tls);
tor_cert_t *tor_tls_get_peer_cert(tor_tls_t *tls);
int tor_tls_verify(int severity, tor_tls_t *tls, crypto_pk_t **identity);
int tor_tls_check_lifetime(int severity,
                           tor_tls_t *tls, int past_tolerance,
                           int future_tolerance);
int tor_tls_read(tor_tls_t *tls, char *cp, size_t len);
int tor_tls_write(tor_tls_t *tls, const char *cp, size_t n);
int tor_tls_handshake(tor_tls_t *tls);
int tor_tls_finish_handshake(tor_tls_t *tls);
int tor_tls_renegotiate(tor_tls_t *tls);
void tor_tls_unblock_renegotiation(tor_tls_t *tls);
void tor_tls_block_renegotiation(tor_tls_t *tls);
void tor_tls_assert_renegotiation_unblocked(tor_tls_t *tls);
int tor_tls_shutdown(tor_tls_t *tls);
int tor_tls_get_pending_bytes(tor_tls_t *tls);
size_t tor_tls_get_forced_write_size(tor_tls_t *tls);

void tor_tls_get_n_raw_bytes(tor_tls_t *tls,
                             size_t *n_read, size_t *n_written);

void tor_tls_get_buffer_sizes(tor_tls_t *tls,
                              size_t *rbuf_capacity, size_t *rbuf_bytes,
                              size_t *wbuf_capacity, size_t *wbuf_bytes);

double tls_get_write_overhead_ratio (void);

int tor_tls_used_v1_handshake(tor_tls_t *tls);
int tor_tls_received_v3_certificate(tor_tls_t *tls);
int tor_tls_get_num_server_handshakes(tor_tls_t *tls);
int tor_tls_server_got_renegotiate(tor_tls_t *tls);
int tor_tls_get_tlssecrets(tor_tls_t *tls, uint8_t *secrets_out);





void check_no_tls_errors_(const char *fname, int line);
void tor_tls_log_one_error(tor_tls_t *tls, unsigned long err,
                           int severity, int domain, const char *doing);
# 123 "../common/tortls.h"
void tor_cert_free(tor_cert_t *cert);
tor_cert_t *tor_cert_decode(const uint8_t *certificate,
                            size_t certificate_len);
void tor_cert_get_der(const tor_cert_t *cert,
                      const uint8_t **encoded_out, size_t *size_out);
const digests_t *tor_cert_get_id_digests(const tor_cert_t *cert);
const digests_t *tor_cert_get_cert_digests(const tor_cert_t *cert);
int tor_tls_get_my_certs(int server,
                         const tor_cert_t **link_cert_out,
                         const tor_cert_t **id_cert_out);
crypto_pk_t *tor_tls_get_my_client_auth_key(void);
crypto_pk_t *tor_tls_cert_get_key(tor_cert_t *cert);
int tor_tls_cert_matches_key(const tor_tls_t *tls, const tor_cert_t *cert);
int tor_tls_cert_is_valid(int severity,
                          const tor_cert_t *cert,
                          const tor_cert_t *signing_cert,
                          int check_rsa_1024);
const char *tor_tls_get_ciphersuite_name(tor_tls_t *tls);
# 91 "or.h" 2
# 1 "../common/torlog.h" 1
# 113 "../common/torlog.h"
typedef uint32_t log_domain_mask_t;



typedef struct log_severity_list_t {


  log_domain_mask_t masks[7 -3 +1];
} log_severity_list_t;


typedef void (*log_callback)(int severity, uint32_t domain, const char *msg);

void init_logging(int disable_startup_queue);
int parse_log_level(const char *level);
const char *log_level_to_string(int level);
int parse_log_severity_config(const char **cfg,
                              log_severity_list_t *severity_out);
void set_log_severity_config(int minSeverity, int maxSeverity,
                             log_severity_list_t *severity_out);
void add_stream_log(const log_severity_list_t *severity, const char *name,
                    int fd);
int add_file_log(const log_severity_list_t *severity, const char *filename,
                 const int truncate);



int add_callback_log(const log_severity_list_t *severity, log_callback cb);
void logs_set_domain_logging(int enabled);
int get_min_log_level(void);
void switch_logs_debug(void);
void logs_free_all(void);
void add_temp_log(int min_severity);
void close_temp_logs(void);
void rollback_log_changes(void);
void mark_logs_temp(void);
void change_callback_log_severity(int loglevelMin, int loglevelMax,
                                  log_callback cb);
void flush_pending_log_callbacks(void);
void flush_log_messages_from_startup(void);
void log_set_application_name(const char *name);
void set_log_time_granularity(int granularity_msec);
void truncate_logs(void);

void tor_log(int severity, log_domain_mask_t domain, const char *format, ...)
  __attribute__ ((format(printf, 3, 4)));

void tor_log_err_sigsafe(const char *m, ...);
int tor_log_get_sigsafe_err_fds(const int **out);
void tor_log_update_sigsafe_err_fds(void);

struct smartlist_t;
void tor_log_get_logfile_names(struct smartlist_t *out);

extern int log_global_min_severity_;


void log_fn_(int severity, log_domain_mask_t domain,
             const char *funcname, const char *format, ...)
  __attribute__ ((format(printf, 4, 5)));
struct ratelim_t;
void log_fn_ratelim_(struct ratelim_t *ratelim, int severity,
                     log_domain_mask_t domain, const char *funcname,
                     const char *format, ...)
  __attribute__ ((format(printf, 5, 6)));
# 92 "or.h" 2
# 1 "../common/container.h" 1
# 9 "../common/container.h"
# 1 "../common/util.h" 1
# 14 "../common/util.h"
# 1 "../win32/orconfig.h" 1
# 15 "../common/util.h" 2


# 1 "../common/di_ops.h" 1
# 14 "../common/di_ops.h"
# 1 "../win32/orconfig.h" 1
# 15 "../common/di_ops.h" 2


int tor_memcmp(const void *a, const void *b, size_t sz);
int tor_memeq(const void *a, const void *b, size_t sz);
# 30 "../common/di_ops.h"
int safe_mem_is_zero(const void *mem, size_t sz);






typedef struct di_digest256_map_t di_digest256_map_t;
typedef void (*dimap_free_fn)(void *);

void dimap_free(di_digest256_map_t *map, dimap_free_fn free_fn);
void dimap_add_entry(di_digest256_map_t **map,
                     const uint8_t *key, void *val);
void *dimap_search(const di_digest256_map_t *map, const uint8_t *key,
                   void *dflt_val);
# 18 "../common/util.h" 2


# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 321 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 513 "/usr/include/stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 530 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 752 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 951 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4

# 21 "../common/util.h" 2
# 56 "../common/util.h"
void tor_assertion_failed_(const char *fname, unsigned int line,
                           const char *func, const char *expr);
# 78 "../common/util.h"
void *tor_malloc_(size_t size ) __attribute__((malloc));
void *tor_malloc_zero_(size_t size ) __attribute__((malloc));
void *tor_calloc_(size_t nmemb, size_t size ) __attribute__((malloc));
void *tor_realloc_(void *ptr, size_t size );
void *tor_reallocarray_(void *ptr, size_t size1, size_t size2 );
char *tor_strdup_(const char *s ) __attribute__((malloc)) ;
char *tor_strndup_(const char *s, size_t n )
  __attribute__((malloc)) ;
void *tor_memdup_(const void *mem, size_t len )
  __attribute__((malloc)) ;
void *tor_memdup_nulterm_(const void *mem, size_t len )
  __attribute__((malloc)) ;
void tor_free_(void *mem);
# 127 "../common/util.h"
void tor_log_mallinfo(int severity);
# 167 "../common/util.h"
double tor_mathlog(double d) __attribute__((const));
long tor_lround(double d) __attribute__((const));
int64_t tor_llround(double d) __attribute__((const));
int tor_log2(uint64_t u64) __attribute__((const));
uint64_t round_to_power_of_2(uint64_t u64);
unsigned round_to_next_multiple_of(unsigned number, unsigned divisor);
uint32_t round_uint32_to_next_multiple_of(uint32_t number, uint32_t divisor);
uint64_t round_uint64_to_next_multiple_of(uint64_t number, uint64_t divisor);
int64_t round_int64_to_next_multiple_of(int64_t number, int64_t divisor);
int64_t sample_laplace_distribution(double mu, double b, double p);
int64_t add_laplace_noise(int64_t signal, double random, double delta_f,
                          double epsilon);
int n_bits_set_u8(uint8_t v);
# 201 "../common/util.h"
void tor_strlower(char *s) ;
void tor_strupper(char *s) ;
int tor_strisprint(const char *s) ;
int tor_strisnonupper(const char *s) ;
int strcmp_opt(const char *s1, const char *s2);
int strcmpstart(const char *s1, const char *s2) ;
int strcmp_len(const char *s1, const char *s2, size_t len) ;
int strcasecmpstart(const char *s1, const char *s2) ;
int strcmpend(const char *s1, const char *s2) ;
int strcasecmpend(const char *s1, const char *s2) ;
int fast_memcmpstart(const void *mem, size_t memlen, const char *prefix);
void tor_strclear(char *s);

void tor_strstrip(char *s, const char *strip) ;
long tor_parse_long(const char *s, int base, long min,
                    long max, int *ok, char **next);
unsigned long tor_parse_ulong(const char *s, int base, unsigned long min,
                              unsigned long max, int *ok, char **next);
double tor_parse_double(const char *s, double min, double max, int *ok,
                        char **next);
uint64_t tor_parse_uint64(const char *s, int base, uint64_t min,
                         uint64_t max, int *ok, char **next);
const char *hex_str(const char *from, size_t fromlen) ;
const char *eat_whitespace(const char *s);
const char *eat_whitespace_eos(const char *s, const char *eos);
const char *eat_whitespace_no_nl(const char *s);
const char *eat_whitespace_eos_no_nl(const char *s, const char *eos);
const char *find_whitespace(const char *s);
const char *find_whitespace_eos(const char *s, const char *eos);
const char *find_str_at_start_of_line(const char *haystack,
                                      const char *needle);
int string_is_C_identifier(const char *string);
int string_is_key_value(int severity, const char *string);
int string_is_valid_hostname(const char *string);
int string_is_valid_ipv4_address(const char *string);
int string_is_valid_ipv6_address(const char *string);

int tor_mem_is_zero(const char *mem, size_t len);
int tor_digest_is_zero(const char *digest);
int tor_digest256_is_zero(const char *digest);
char *esc_for_log(const char *string) __attribute__((malloc));
char *esc_for_log_len(const char *chars, size_t n) __attribute__((malloc));
const char *escaped(const char *string);

char *tor_escape_str_for_pt_args(const char *string,
                                 const char *chars_to_escape);

struct smartlist_t;
int tor_vsscanf(const char *buf, const char *pattern, va_list ap)
  __attribute__ ((format(scanf, 2, 0)));
int tor_sscanf(const char *buf, const char *pattern, ...)
  __attribute__ ((format(scanf, 2, 3)));

void smartlist_add_asprintf(struct smartlist_t *sl, const char *pattern, ...)
  __attribute__ ((format(printf, 2, 3)));
void smartlist_add_vasprintf(struct smartlist_t *sl, const char *pattern,
                             va_list args)
  __attribute__ ((format(printf, 2, 0)));

int hex_decode_digit(char c);
void base16_encode(char *dest, size_t destlen, const char *src, size_t srclen);
int base16_decode(char *dest, size_t destlen, const char *src, size_t srclen);


long tv_udiff(const struct timeval *start, const struct timeval *end);
long tv_mdiff(const struct timeval *start, const struct timeval *end);
int64_t tv_to_msec(const struct timeval *tv);
int tor_timegm(const struct tm *tm, time_t *time_out);

void format_rfc1123_time(char *buf, time_t t);
int parse_rfc1123_time(const char *buf, time_t *t);


void format_local_iso_time(char *buf, time_t t);
void format_iso_time(char *buf, time_t t);
void format_iso_time_nospace(char *buf, time_t t);
void format_iso_time_nospace_usec(char *buf, const struct timeval *tv);
int parse_iso_time_(const char *cp, time_t *t, int strict);
int parse_iso_time(const char *buf, time_t *t);
int parse_http_time(const char *buf, struct tm *tm);
int format_time_interval(char *out, size_t out_len, long interval);






time_t approx_time(void);
void update_approx_time(time_t now);
# 318 "../common/util.h"
typedef struct ratelim_t {
  int rate;
  time_t last_allowed;
  int n_calls_since_last_time;
} ratelim_t;



char *rate_limit_log(ratelim_t *lim, time_t now);


ssize_t write_all(int fd, const char *buf, size_t count,int isSocket);
ssize_t read_all(int fd, char *buf, size_t count, int isSocket);


enum stream_status {
  IO_STREAM_OKAY,
  IO_STREAM_EAGAIN,
  IO_STREAM_TERM,
  IO_STREAM_CLOSED
};

const char *stream_status_to_string(enum stream_status stream_status);

enum stream_status get_string_from_pipe(FILE *stream, char *buf, size_t count);



typedef enum { FN_ERROR, FN_NOENT, FN_FILE, FN_DIR, FN_EMPTY } file_status_t;
file_status_t file_status(const char *filename);



typedef unsigned int cpd_check_t;






int check_private_dir(const char *dirname, cpd_check_t check,
                      const char *effective_user);




typedef struct open_file_t open_file_t;
int start_writing_to_file(const char *fname, int open_flags, int mode,
                          open_file_t **data_out);
FILE *start_writing_to_stdio_file(const char *fname, int open_flags, int mode,
                                  open_file_t **data_out);
FILE *fdopen_file(open_file_t *file_data);
int finish_writing_to_file(open_file_t *file_data);
int abort_writing_to_file(open_file_t *file_data);
int write_str_to_file(const char *fname, const char *str, int bin);
int write_bytes_to_file (const char *fname, const char *str, size_t len, int bin)

                              ;


typedef struct sized_chunk_t {
  const char *bytes;
  size_t len;
} sized_chunk_t;
int write_chunks_to_file(const char *fname, const struct smartlist_t *chunks,
                         int bin, int no_tempfile);
int append_bytes_to_file(const char *fname, const char *str, size_t len,
                         int bin);
int write_bytes_to_new_file(const char *fname, const char *str, size_t len,
                            int bin);







struct stat;

char *read_file_to_str(const char *filename, int flags, struct stat *stat_out)
  __attribute__((malloc));
char *read_file_to_str_until_eof(int fd, size_t max_bytes_to_read,
                                 size_t *sz_out)
  __attribute__((malloc));
const char *parse_config_line_from_str_verbose(const char *line,
                                       char **key_out, char **value_out,
                                       const char **err_out);


char *expand_filename(const char *filename);
struct smartlist_t *tor_listdir(const char *dirname);
int path_is_relative(const char *filename);


void start_daemon(void);
void finish_daemon(const char *desired_cwd);
void write_pidfile(char *filename);


void tor_check_port_forwarding(const char *filename,
                               struct smartlist_t *ports_to_forward,
                               time_t now);

typedef struct process_handle_t process_handle_t;
typedef struct process_environment_t process_environment_t;
int tor_spawn_background(const char *const filename, const char **argv,
                         process_environment_t *env,
                         process_handle_t **process_handle_out);







int environment_variable_names_equal(const char *s1, const char *s2);


struct process_environment_t {


  char *windows_environment_block;


  char **unixoid_environment_block;
};

process_environment_t *process_environment_make(struct smartlist_t *env_vars);
void process_environment_free(process_environment_t *env);

struct smartlist_t *get_current_process_environment_variables(void);

void set_environment_variable_in_smartlist(struct smartlist_t *env_vars,
                                           const char *new_var,
                                           void (*free_old)(void*),
                                           int free_p);
# 493 "../common/util.h"
int tor_get_exit_code(process_handle_t *process_handle,
                      int block, int *exit_code);
int tor_split_lines(struct smartlist_t *sl, char *buf, int len);




ssize_t tor_read_all_handle(FILE *h, char *buf, size_t count,
                            const process_handle_t *process,
                            int *eof);

ssize_t tor_read_all_from_process_stdout(
    const process_handle_t *process_handle, char *buf, size_t count);
ssize_t tor_read_all_from_process_stderr(
    const process_handle_t *process_handle, char *buf, size_t count);
char *tor_join_win_cmdline(const char *argv[]);

int tor_process_get_pid(process_handle_t *process_handle);



FILE *tor_process_get_stdout_pipe(process_handle_t *process_handle);







struct smartlist_t * tor_get_lines_from_handle (FILE *handle, enum stream_status *stream_status)

                                                              ;


int
tor_terminate_process(process_handle_t *process_handle);

void tor_process_handle_destroy (process_handle_t *process_handle, int also_terminate_process)

                                                        ;


typedef struct tor_weak_rng_t {
  uint32_t state;
} tor_weak_rng_t;



void tor_init_weak_random(tor_weak_rng_t *weak_rng, unsigned seed);
int32_t tor_weak_random(tor_weak_rng_t *weak_rng);
int32_t tor_weak_random_range(tor_weak_rng_t *rng, int32_t top);




int format_hex_number_sigsafe(unsigned long x, char *buf, int max_len);
int format_dec_number_sigsafe(unsigned long x, char *buf, int max_len);
# 566 "../common/util.h"
const char *libor_get_digests(void);
# 10 "../common/container.h" 2
# 1 "../ext/siphash.h" 1



struct sipkey {
  uint64_t k0;
  uint64_t k1;
};
uint64_t siphash24(const void *src, unsigned long src_sz, const struct sipkey *key);

void siphash_set_global_key(const struct sipkey *key);
uint64_t siphash24g(const void *src, unsigned long src_sz);
# 11 "../common/container.h" 2







typedef struct smartlist_t {





  void **list;
  int num_used;
  int capacity;

} smartlist_t;

smartlist_t * smartlist_new (void);
void smartlist_free (smartlist_t *sl);
void smartlist_clear(smartlist_t *sl);
void smartlist_add(smartlist_t *sl, void *element);
void smartlist_add_all(smartlist_t *sl, const smartlist_t *s2);
void smartlist_remove(smartlist_t *sl, const void *element);
void *smartlist_pop_last(smartlist_t *sl);
void smartlist_reverse(smartlist_t *sl);
void smartlist_string_remove(smartlist_t *sl, const char *element);
int smartlist_contains(const smartlist_t *sl, const void *element);
int smartlist_contains_string(const smartlist_t *sl, const char *element);
int smartlist_string_pos(const smartlist_t *, const char *elt);
int smartlist_contains_string_case(const smartlist_t *sl, const char *element);
int smartlist_contains_int_as_string(const smartlist_t *sl, int num);
int smartlist_strings_eq(const smartlist_t *sl1, const smartlist_t *sl2);
int smartlist_contains_digest(const smartlist_t *sl, const char *element);
int smartlist_ints_eq(const smartlist_t *sl1, const smartlist_t *sl2);
int smartlist_overlap(const smartlist_t *sl1, const smartlist_t *sl2);
void smartlist_intersect(smartlist_t *sl1, const smartlist_t *sl2);
void smartlist_subtract(smartlist_t *sl1, const smartlist_t *sl2);
# 83 "../common/container.h"
static inline void smartlist_swap(smartlist_t *sl, int idx1, int idx2)
{
  if (idx1 != idx2) {
    void *elt = ((sl)->list[idx1]);
    ((sl)->list[idx1] = (((sl)->list[idx2])));
    ((sl)->list[idx2] = (elt));
  }
}

void smartlist_del(smartlist_t *sl, int idx);
void smartlist_del_keeporder(smartlist_t *sl, int idx);
void smartlist_insert(smartlist_t *sl, int idx, void *val);
void smartlist_sort(smartlist_t *sl,
                    int (*compare)(const void **a, const void **b));
void *smartlist_get_most_frequent_(const smartlist_t *sl,
                    int (*compare)(const void **a, const void **b),
                    int *count_out);


void smartlist_uniq(smartlist_t *sl,
                    int (*compare)(const void **a, const void **b),
                    void (*free_fn)(void *elt));

void smartlist_sort_strings(smartlist_t *sl);
void smartlist_sort_digests(smartlist_t *sl);
void smartlist_sort_digests256(smartlist_t *sl);
void smartlist_sort_pointers(smartlist_t *sl);

char *smartlist_get_most_frequent_string(smartlist_t *sl);
char *smartlist_get_most_frequent_string_(smartlist_t *sl, int *count_out);
char *smartlist_get_most_frequent_digest256(smartlist_t *sl);

void smartlist_uniq_strings(smartlist_t *sl);
void smartlist_uniq_digests(smartlist_t *sl);
void smartlist_uniq_digests256(smartlist_t *sl);
void *smartlist_bsearch(smartlist_t *sl, const void *key,
                        int (*compare)(const void *key, const void **member));
int smartlist_bsearch_idx(const smartlist_t *sl, const void *key,
                          int (*compare)(const void *key, const void **member),
                          int *found_out);

void smartlist_pqueue_add(smartlist_t *sl,
                          int (*compare)(const void *a, const void *b),
                          int idx_field_offset,
                          void *item);
void *smartlist_pqueue_pop(smartlist_t *sl,
                           int (*compare)(const void *a, const void *b),
                           int idx_field_offset);
void smartlist_pqueue_remove(smartlist_t *sl,
                             int (*compare)(const void *a, const void *b),
                             int idx_field_offset,
                             void *item);
void smartlist_pqueue_assert_ok(smartlist_t *sl,
                                int (*compare)(const void *a, const void *b),
                                int idx_field_offset);




int smartlist_split_string(smartlist_t *sl, const char *str, const char *sep,
                           int flags, int max);
char *smartlist_join_strings(smartlist_t *sl, const char *join, int terminate,
                             size_t *len_out) __attribute__((malloc));
char *smartlist_join_strings2(smartlist_t *sl, const char *join,
                              size_t join_len, int terminate, size_t *len_out)
  __attribute__((malloc));
# 360 "../common/container.h"
typedef struct strmap_t strmap_t; typedef struct strmap_entry_t *strmap_iter_t; strmap_t* strmap_new (void); void* strmap_set(strmap_t *map, const char * key, void *val); void* strmap_get(const strmap_t *map, const char * key); void* strmap_remove(strmap_t *map, const char * key); void strmap_free (strmap_t *map, void (*free_val)(void*)); int strmap_isempty(const strmap_t *map); int strmap_size(const strmap_t *map); strmap_iter_t *strmap_iter_init(strmap_t *map); strmap_iter_t *strmap_iter_next(strmap_t *map, strmap_iter_t *iter); strmap_iter_t *strmap_iter_next_rmv(strmap_t *map, strmap_iter_t *iter); void strmap_iter_get(strmap_iter_t *iter, const char * *keyp, void **valp); int strmap_iter_done(strmap_iter_t *iter); void strmap_assert_ok(const strmap_t *map);

typedef struct digestmap_t digestmap_t; typedef struct digestmap_entry_t *digestmap_iter_t; digestmap_t* digestmap_new (void); void* digestmap_set(digestmap_t *map, const char * key, void *val); void* digestmap_get(const digestmap_t *map, const char * key); void* digestmap_remove(digestmap_t *map, const char * key); void digestmap_free (digestmap_t *map, void (*free_val)(void*)); int digestmap_isempty(const digestmap_t *map); int digestmap_size(const digestmap_t *map); digestmap_iter_t *digestmap_iter_init(digestmap_t *map); digestmap_iter_t *digestmap_iter_next(digestmap_t *map, digestmap_iter_t *iter); digestmap_iter_t *digestmap_iter_next_rmv(digestmap_t *map, digestmap_iter_t *iter); void digestmap_iter_get(digestmap_iter_t *iter, const char * *keyp, void **valp); int digestmap_iter_done(digestmap_iter_t *iter); void digestmap_assert_ok(const digestmap_t *map);


typedef struct digest256map_t digest256map_t; typedef struct digest256map_entry_t *digest256map_iter_t; digest256map_t* digest256map_new (void); void* digest256map_set(digest256map_t *map, const uint8_t * key, void *val); void* digest256map_get(const digest256map_t *map, const uint8_t * key); void* digest256map_remove(digest256map_t *map, const uint8_t * key); void digest256map_free (digest256map_t *map, void (*free_val)(void*)); int digest256map_isempty(const digest256map_t *map); int digest256map_size(const digest256map_t *map); digest256map_iter_t *digest256map_iter_init(digest256map_t *map); digest256map_iter_t *digest256map_iter_next(digest256map_t *map, digest256map_iter_t *iter); digest256map_iter_t *digest256map_iter_next_rmv(digest256map_t *map, digest256map_iter_t *iter); void digest256map_iter_get(digest256map_iter_t *iter, const uint8_t * *keyp, void **valp); int digest256map_iter_done(digest256map_iter_t *iter); void digest256map_assert_ok(const digest256map_t *map);
# 494 "../common/container.h"
void* strmap_set_lc(strmap_t *map, const char *key, void *val);
void* strmap_get_lc(const strmap_t *map, const char *key);
void* strmap_remove_lc(strmap_t *map, const char *key);
# 583 "../common/container.h"
typedef unsigned int bitarray_t;

static inline bitarray_t *
bitarray_init_zero(unsigned int n_bits)
{

  size_t sz = (n_bits+((1u<<5)-1)) >> 5;
  return tor_calloc_(sz, sizeof(unsigned int) );
}



static inline bitarray_t *
bitarray_expand(bitarray_t *ba,
                unsigned int n_bits_old, unsigned int n_bits_new)
{
  size_t sz_old = (n_bits_old+((1u<<5)-1)) >> 5;
  size_t sz_new = (n_bits_new+((1u<<5)-1)) >> 5;
  char *ptr;
  if (sz_new <= sz_old)
    return ba;
  ptr = tor_reallocarray_((ba), (sz_new), (sizeof(unsigned int)) );


  memset(ptr+sz_old*sizeof(unsigned int), 0,
         (sz_new-sz_old)*sizeof(unsigned int));
  return (bitarray_t*) ptr;
}

static inline void
bitarray_free(bitarray_t *ba)
{
  (void) ({ if (__builtin_expect(!!((ba)!=((void *)0)), 1)) { free(ba); (ba)=((void *)0); } });
}

static inline void
bitarray_set(bitarray_t *b, int bit)
{
  b[bit >> 5] |= (1u << (bit & ((1u<<5)-1)));
}

static inline void
bitarray_clear(bitarray_t *b, int bit)
{
  b[bit >> 5] &= ~ (1u << (bit & ((1u<<5)-1)));
}


static inline unsigned int
bitarray_is_set(bitarray_t *b, int bit)
{
  return b[bit >> 5] & (1u << (bit & ((1u<<5)-1)));
}


typedef struct {
  int mask;

  bitarray_t *ba;
} digestset_t;



static inline void
digestset_add(digestset_t *set, const char *digest)
{
  const uint64_t x = siphash24g(digest, 20);
  const uint32_t d1 = (uint32_t) x;
  const uint32_t d2 = (uint32_t)( (x>>16) + x);
  const uint32_t d3 = (uint32_t)( (x>>32) + x);
  const uint32_t d4 = (uint32_t)( (x>>48) + x);
  bitarray_set(set->ba, ((d1) & set->mask));
  bitarray_set(set->ba, ((d2) & set->mask));
  bitarray_set(set->ba, ((d3) & set->mask));
  bitarray_set(set->ba, ((d4) & set->mask));
}



static inline int
digestset_contains(const digestset_t *set, const char *digest)
{
  const uint64_t x = siphash24g(digest, 20);
  const uint32_t d1 = (uint32_t) x;
  const uint32_t d2 = (uint32_t)( (x>>16) + x);
  const uint32_t d3 = (uint32_t)( (x>>32) + x);
  const uint32_t d4 = (uint32_t)( (x>>48) + x);
  return bitarray_is_set(set->ba, ((d1) & set->mask)) &&
         bitarray_is_set(set->ba, ((d2) & set->mask)) &&
         bitarray_is_set(set->ba, ((d3) & set->mask)) &&
         bitarray_is_set(set->ba, ((d4) & set->mask));
}


digestset_t *digestset_new(int max_elements);
void digestset_free(digestset_t* set);





int find_nth_int(int *array, int n_elements, int nth);
time_t find_nth_time(time_t *array, int n_elements, int nth);
double find_nth_double(double *array, int n_elements, int nth);
int32_t find_nth_int32(int32_t *array, int n_elements, int nth);
uint32_t find_nth_uint32(uint32_t *array, int n_elements, int nth);
long find_nth_long(long *array, int n_elements, int nth);
static inline int
median_int(int *array, int n_elements)
{
  return find_nth_int(array, n_elements, (n_elements-1)/2);
}
static inline time_t
median_time(time_t *array, int n_elements)
{
  return find_nth_time(array, n_elements, (n_elements-1)/2);
}
static inline double
median_double(double *array, int n_elements)
{
  return find_nth_double(array, n_elements, (n_elements-1)/2);
}
static inline uint32_t
median_uint32(uint32_t *array, int n_elements)
{
  return find_nth_uint32(array, n_elements, (n_elements-1)/2);
}
static inline int32_t
median_int32(int32_t *array, int n_elements)
{
  return find_nth_int32(array, n_elements, (n_elements-1)/2);
}

static inline uint32_t
third_quartile_uint32(uint32_t *array, int n_elements)
{
  return find_nth_uint32(array, n_elements, (n_elements*3)/4);
}
# 93 "or.h" 2
# 1 "../common/torgzip.h" 1
# 18 "../common/torgzip.h"
typedef enum {
  NO_METHOD=0, GZIP_METHOD=1, ZLIB_METHOD=2, UNKNOWN_METHOD=3
} compress_method_t;






typedef enum {
  HIGH_COMPRESSION, MEDIUM_COMPRESSION, LOW_COMPRESSION
} zlib_compression_level_t;

int
tor_gzip_compress(char **out, size_t *out_len,
                  const char *in, size_t in_len,
                  compress_method_t method);
int
tor_gzip_uncompress(char **out, size_t *out_len,
                    const char *in, size_t in_len,
                    compress_method_t method,
                    int complete_only,
                    int protocol_warn_level);

int is_gzip_supported(void);

const char *
tor_zlib_get_version_str(void);

const char *
tor_zlib_get_header_version_str(void);

compress_method_t detect_compression_method(const char *in, size_t in_len);



typedef enum {
  TOR_ZLIB_OK, TOR_ZLIB_DONE, TOR_ZLIB_BUF_FULL, TOR_ZLIB_ERR
} tor_zlib_output_t;

typedef struct tor_zlib_state_t tor_zlib_state_t;
tor_zlib_state_t *tor_zlib_new(int compress, compress_method_t method,
                               zlib_compression_level_t level);

tor_zlib_output_t tor_zlib_process(tor_zlib_state_t *state,
                                   char **out, size_t *out_len,
                                   const char **in, size_t *in_len,
                                   int finish);
void tor_zlib_free(tor_zlib_state_t *state);

size_t tor_zlib_state_size(const tor_zlib_state_t *state);
size_t tor_zlib_get_total_allocation(void);
# 94 "or.h" 2
# 1 "../common/address.h" 1
# 15 "../common/address.h"
# 1 "../win32/orconfig.h" 1
# 16 "../common/address.h" 2
# 51 "../common/address.h"
typedef uint8_t maskbits_t;

struct in_addr;


typedef struct tor_addr_t
{
  sa_family_t family;
  union {
    uint32_t dummy_;

    struct in_addr in_addr;
    struct in6_addr in6_addr;
  } addr;
} tor_addr_t;


typedef struct tor_addr_port_t
{
  tor_addr_t addr;
  uint16_t port;
} tor_addr_port_t;



static inline const struct in6_addr *tor_addr_to_in6(const tor_addr_t *a);
static inline uint32_t tor_addr_to_ipv4n(const tor_addr_t *a);
static inline uint32_t tor_addr_to_ipv4h(const tor_addr_t *a);
static inline uint32_t tor_addr_to_mapped_ipv4h(const tor_addr_t *a);
static inline sa_family_t tor_addr_family(const tor_addr_t *a);
static inline const struct in_addr *tor_addr_to_in(const tor_addr_t *a);
static inline int tor_addr_eq_ipv4h(const tor_addr_t *a, uint32_t u);

socklen_t tor_addr_to_sockaddr(const tor_addr_t *a, uint16_t port,
                               struct sockaddr *sa_out, socklen_t len);
int tor_addr_from_sockaddr(tor_addr_t *a, const struct sockaddr *sa,
                           uint16_t *port_out);
void tor_addr_make_unspec(tor_addr_t *a);
void tor_addr_make_null(tor_addr_t *a, sa_family_t family);
char *tor_sockaddr_to_str(const struct sockaddr *sa);



static inline const struct in6_addr *
tor_addr_to_in6(const tor_addr_t *a)
{
  return a->family == AF_INET6 ? &a->addr.in6_addr : ((void *)0);
}
# 118 "../common/address.h"
static inline uint32_t
tor_addr_to_ipv4n(const tor_addr_t *a)
{
  return a->family == AF_INET ? a->addr.in_addr.s_addr : 0;
}


static inline uint32_t
tor_addr_to_ipv4h(const tor_addr_t *a)
{
  return ntohl(tor_addr_to_ipv4n(a));
}




static inline uint32_t
tor_addr_to_mapped_ipv4h(const tor_addr_t *a)
{
  if (a->family == AF_INET6) {
    uint32_t *addr32 = ((void *)0);


    addr32 = ((uint32_t*)((char*)&(*tor_addr_to_in6(a)).s6_addr));


    (void) ({ if (__builtin_expect(!!(!(addr32)), 0)) { tor_assertion_failed_(("../common/address.h"), 144, "???", "addr32"); abort(); } });
    return ntohl(addr32[3]);
  } else {
    return 0;
  }
}


static inline sa_family_t
tor_addr_family(const tor_addr_t *a)
{
  return a->family;
}


static inline const struct in_addr *
tor_addr_to_in(const tor_addr_t *a)
{
  return a->family == AF_INET ? &a->addr.in_addr : ((void *)0);
}


static inline int
tor_addr_eq_ipv4h(const tor_addr_t *a, uint32_t u)
{
  return a->family == AF_INET ? (tor_addr_to_ipv4h(a) == u) : 0;
}
# 181 "../common/address.h"
int tor_addr_lookup(const char *name, uint16_t family, tor_addr_t *addr_out);
char *tor_dup_addr(const tor_addr_t *addr) __attribute__((malloc));







const char *fmt_addr_impl(const tor_addr_t *addr, int decorate);
const char *fmt_addrport(const tor_addr_t *addr, uint16_t port);
const char * fmt_addr32(uint32_t addr);
int get_interface_address6 (int severity, sa_family_t family, tor_addr_t *addr)
                  ;





typedef enum {
  CMP_EXACT,
  CMP_SEMANTIC,
} tor_addr_comparison_t;

int tor_addr_compare(const tor_addr_t *addr1, const tor_addr_t *addr2,
                     tor_addr_comparison_t how);
int tor_addr_compare_masked(const tor_addr_t *addr1, const tor_addr_t *addr2,
                            maskbits_t mask, tor_addr_comparison_t how);




uint64_t tor_addr_hash(const tor_addr_t *addr);
int tor_addr_is_v4(const tor_addr_t *addr);
int tor_addr_is_internal_(const tor_addr_t *ip, int for_listening,
                          const char *filename, int lineno);






int tor_addr_to_PTR_name(char *out, size_t outlen,
                                    const tor_addr_t *addr);
int tor_addr_parse_PTR_name(tor_addr_t *result, const char *address,
                                       int family, int accept_regular);

int tor_addr_port_lookup(const char *s, tor_addr_t *addr_out,
                        uint16_t *port_out);

int tor_addr_parse_mask_ports(const char *s, unsigned flags,
                              tor_addr_t *addr_out, maskbits_t *mask_out,
                              uint16_t *port_min_out, uint16_t *port_max_out);
const char * tor_addr_to_str(char *dest, const tor_addr_t *addr, size_t len,
                             int decorate);
int tor_addr_parse(tor_addr_t *addr, const char *src);
void tor_addr_copy(tor_addr_t *dest, const tor_addr_t *src);
void tor_addr_copy_tight(tor_addr_t *dest, const tor_addr_t *src);
void tor_addr_from_ipv4n(tor_addr_t *dest, uint32_t v4addr);




void tor_addr_from_ipv6_bytes(tor_addr_t *dest, const char *bytes);



void tor_addr_from_in6(tor_addr_t *dest, const struct in6_addr *in6);
int tor_addr_is_null(const tor_addr_t *addr);
int tor_addr_is_loopback(const tor_addr_t *addr);

int tor_addr_port_split(int severity, const char *addrport,
                        char **address_out, uint16_t *port_out);

int tor_addr_port_parse(int severity, const char *addrport,
                        tor_addr_t *address_out, uint16_t *port_out,
                        int default_port);

int tor_addr_hostname_is_local(const char *name);


int addr_port_lookup(int severity, const char *addrport, char **address,
                    uint32_t *addr, uint16_t *port_out);
int parse_port_range(const char *port, uint16_t *port_min_out,
                     uint16_t *port_max_out);
int addr_mask_get_bits(uint32_t mask);


int tor_inet_ntoa(const struct in_addr *in, char *buf, size_t buf_len);
char *tor_dup_ip(uint32_t addr) __attribute__((malloc));
int get_interface_address (int severity, uint32_t *addr);

tor_addr_port_t *tor_addr_port_new(const tor_addr_t *addr, uint16_t port);
# 95 "or.h" 2
# 1 "../common/compat_libevent.h" 1






# 1 "../win32/orconfig.h" 1
# 8 "../common/compat_libevent.h" 2


struct event;
struct event_base;







# 1 "/usr/include/event2/util.h" 1 3 4
# 40 "/usr/include/event2/util.h" 3 4
# 1 "/usr/include/event2/event-config.h" 1 3 4
# 41 "/usr/include/event2/util.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 55 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 189 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 43 "/usr/include/event2/util.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 2 3 4
# 46 "/usr/include/event2/util.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 54 "/usr/include/event2/util.h" 2 3 4
# 63 "/usr/include/event2/util.h" 3 4
# 1 "/usr/include/netdb.h" 1 3 4
# 27 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 23 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/socket.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/uio.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/uio.h" 1 3 4
# 43 "/usr/include/x86_64-linux-gnu/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 29 "/usr/include/x86_64-linux-gnu/sys/uio.h" 2 3 4
# 39 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
# 50 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
# 65 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 77 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 120 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4

# 27 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4
# 38 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/socket.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4





typedef __socklen_t socklen_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 147 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,






    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 272 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));
# 299 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01





  };
# 345 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 2 3 4
# 346 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 379 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 39 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 113 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 137 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, const struct sockaddr * __addr,
         socklen_t __addr_len);
# 174 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);
# 202 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
# 219 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 243 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);
# 261 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));
# 283 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4

# 24 "/usr/include/netinet/in.h" 2 3 4






typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/x86_64-linux-gnu/bits/in.h" 1 3 4
# 112 "/usr/include/x86_64-linux-gnu/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 209 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 237 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 374 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 386 "/usr/include/netinet/in.h" 2 3 4
# 501 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 628 "/usr/include/netinet/in.h" 3 4

# 28 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ , __leaf__));
extern void endrpcent (void) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));



# 33 "/usr/include/netdb.h" 2 3 4
# 42 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 43 "/usr/include/netdb.h" 2 3 4
# 53 "/usr/include/netdb.h" 3 4








extern int *__h_errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 92 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) __attribute__ ((__nothrow__ , __leaf__));


extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ , __leaf__));




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
# 155 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
# 167 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 198 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
# 237 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
# 308 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 374 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 395 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
# 412 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 423 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 451 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
# 463 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 479 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
# 491 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 505 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
# 515 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
# 528 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
# 539 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
# 551 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 560 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};
# 662 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ , __leaf__));


extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ , __leaf__));





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
# 713 "/usr/include/netdb.h" 3 4

# 64 "/usr/include/event2/util.h" 2 3 4
# 288 "/usr/include/event2/util.h" 3 4
int evutil_socketpair(int d, int type, int protocol, int sv[2]);





int evutil_make_socket_nonblocking(int sock);
# 307 "/usr/include/event2/util.h" 3 4
int evutil_make_listen_socket_reuseable(int sock);







int evutil_make_socket_closeonexec(int sock);







int evutil_closesocket(int sock);
# 431 "/usr/include/event2/util.h" 3 4
int64_t evutil_strtoll(const char *s, char **endptr, int base);
# 444 "/usr/include/event2/util.h" 3 4
int evutil_snprintf(char *buf, size_t buflen, const char *format, ...)

 __attribute__((format(printf, 3, 4)))

;



int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)

 __attribute__((format(printf, 3, 0)))

;


const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);

int evutil_inet_pton(int af, const char *src, void *dst);
struct sockaddr;
# 484 "/usr/include/event2/util.h" 3 4
int evutil_parse_sockaddr_port(const char *str, struct sockaddr *out, int *outlen);






int evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,
    int include_port);




int evutil_ascii_strcasecmp(const char *str1, const char *str2);



int evutil_ascii_strncasecmp(const char *str1, const char *str2, size_t n);
# 629 "/usr/include/event2/util.h" 3 4
struct addrinfo;
# 641 "/usr/include/event2/util.h" 3 4
int evutil_getaddrinfo(const char *nodename, const char *servname,
    const struct addrinfo *hints_in, struct addrinfo **res);


void evutil_freeaddrinfo(struct addrinfo *ai);

const char *evutil_gai_strerror(int err);







void evutil_secure_rng_get_bytes(void *buf, size_t n);
# 673 "/usr/include/event2/util.h" 3 4
int evutil_secure_rng_init(void);
# 689 "/usr/include/event2/util.h" 3 4
void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);
# 20 "../common/compat_libevent.h" 2





void configure_libevent_logging(void);
void suppress_libevent_log_msg(const char *msg);
# 45 "../common/compat_libevent.h"
void tor_event_free(struct event *ev);

typedef struct periodic_timer_t periodic_timer_t;

periodic_timer_t *periodic_timer_new(struct event_base *base,
             const struct timeval *tv,
             void (*cb)(periodic_timer_t *timer, void *data),
             void *data);
void periodic_timer_free(periodic_timer_t *);
# 64 "../common/compat_libevent.h"
typedef struct tor_libevent_cfg {

  int disable_iocp;

  int num_cpus;


  int msec_per_tick;
} tor_libevent_cfg;

void tor_libevent_initialize(tor_libevent_cfg *cfg);
struct event_base * tor_libevent_get_base (void);
const char *tor_libevent_get_method(void);
void tor_check_libevent_version(const char *m, int server,
                                const char **badness_out);
void tor_check_libevent_header_compatibility(void);
const char *tor_libevent_get_version_str(void);
const char *tor_libevent_get_header_version_str(void);
# 92 "../common/compat_libevent.h"
int tor_init_libevent_rng(void);

void tor_gettimeofday_cached(struct timeval *tv);
void tor_gettimeofday_cache_clear(void);



void tor_gettimeofday_cached_monotonic(struct timeval *tv);
# 96 "or.h" 2
# 1 "../ext/ht.h" 1
# 64 "../ext/ht.h"
static inline unsigned
ht_improve_hash(unsigned h)
{


  h += ~(h << 9);
  h ^= ((h >> 14) | (h << 18));
  h += (h << 4);
  h ^= ((h >> 10) | (h << 22));
  return h;
}
# 97 "or.h" 2
# 1 "replaycache.h" 1
# 12 "replaycache.h"
typedef struct replaycache_s replaycache_t;
# 36 "replaycache.h"
void replaycache_free(replaycache_t *r);
replaycache_t * replaycache_new(time_t horizon, time_t interval);
# 60 "replaycache.h"
int replaycache_add_and_test(replaycache_t *r, const void *data, size_t len);
int replaycache_add_test_and_elapsed(
    replaycache_t *r, const void *data, size_t len, time_t *elapsed);
void replaycache_scrub_if_needed(replaycache_t *r);
# 98 "or.h" 2
# 1 "../common/crypto_curve25519.h" 1
# 18 "../common/crypto_curve25519.h"
typedef struct curve25519_public_key_t {
  uint8_t public_key[32];
} curve25519_public_key_t;


typedef struct curve25519_secret_key_t {
  uint8_t secret_key[32];
} curve25519_secret_key_t;


typedef struct curve25519_keypair_t {
  curve25519_public_key_t pubkey;
  curve25519_secret_key_t seckey;
} curve25519_keypair_t;






int curve25519_public_key_is_ok(const curve25519_public_key_t *);

int curve25519_secret_key_generate(curve25519_secret_key_t *key_out,
                                   int extra_strong);
void curve25519_public_key_generate(curve25519_public_key_t *key_out,
                                    const curve25519_secret_key_t *seckey);
int curve25519_keypair_generate(curve25519_keypair_t *keypair_out,
                                int extra_strong);

void curve25519_handshake(uint8_t *output,
                          const curve25519_secret_key_t *,
                          const curve25519_public_key_t *);

int curve25519_keypair_write_to_file(const curve25519_keypair_t *keypair,
                                     const char *fname,
                                     const char *tag);

int curve25519_keypair_read_from_file(curve25519_keypair_t *keypair_out,
                                      char **tag_out,
                                      const char *fname);

int curve25519_rand_seckey_bytes(uint8_t *out, int extra_strong);
# 68 "../common/crypto_curve25519.h"
int curve25519_public_from_base64(curve25519_public_key_t *pkey,
                                  const char *input);
int curve25519_public_to_base64(char *output,
                                const curve25519_public_key_t *pkey);

int crypto_write_tagged_contents_to_file(const char *fname,
                                         const char *typestring,
                                         const char *tag,
                                         const uint8_t *data,
                                         size_t datalen);

ssize_t crypto_read_tagged_contents_from_file(const char *fname,
                                              const char *typestring,
                                              char **tag_out,
                                              uint8_t *data_out,
                                              ssize_t data_out_len);
# 99 "or.h" 2
# 1 "../ext/tor_queue.h" 1
# 100 "or.h" 2
# 190 "or.h"
typedef enum {
  CIRC_ID_TYPE_LOWER=0,
  CIRC_ID_TYPE_HIGHER=1,


  CIRC_ID_TYPE_NEITHER=2
} circ_id_type_t;
# 776 "or.h"
typedef enum rend_auth_type_t {
  REND_NO_AUTH = 0,
  REND_BASIC_AUTH = 1,
  REND_STEALTH_AUTH = 2,
} rend_auth_type_t;


typedef struct rend_service_authorization_t {
  char descriptor_cookie[16];
  char onion_address[(16+1+5)+1];
  rend_auth_type_t auth_type;
} rend_service_authorization_t;




typedef struct rend_data_t {

  char onion_address[16 +1];


  char descriptor_cookie[16];


  rend_auth_type_t auth_type;


  char rend_pk_digest[20];


  char rend_cookie[20];
} rend_data_t;







typedef enum {
  CELL_DIRECTION_IN=1,
  CELL_DIRECTION_OUT=2,
} cell_direction_t;
# 903 "or.h"
static int get_cell_network_size(int wide_circ_ids);
static inline int get_cell_network_size(int wide_circ_ids)
{
  return wide_circ_ids ? 514 : 514 - 2;
}
static int get_var_cell_header_size(int wide_circ_ids);
static inline int get_var_cell_header_size(int wide_circ_ids)
{
  return wide_circ_ids ? 7 :
    7 - 2;
}
static int get_circ_id_size(int wide_circ_ids);
static inline int get_circ_id_size(int wide_circ_ids)
{
  return wide_circ_ids ? 4 : 2;
}
# 927 "or.h"
typedef uint32_t circid_t;

typedef uint16_t streamid_t;



typedef struct channel_s channel_t;



typedef struct channel_listener_s channel_listener_t;



typedef enum {
# 950 "or.h"
  CHANNEL_STATE_CLOSED = 0,
# 961 "or.h"
  CHANNEL_STATE_OPENING,
# 973 "or.h"
  CHANNEL_STATE_OPEN,
# 985 "or.h"
  CHANNEL_STATE_MAINT,
# 996 "or.h"
  CHANNEL_STATE_CLOSING,
# 1008 "or.h"
  CHANNEL_STATE_ERROR,



  CHANNEL_STATE_LAST
} channel_state_t;



typedef enum {
# 1026 "or.h"
  CHANNEL_LISTENER_STATE_CLOSED = 0,
# 1037 "or.h"
  CHANNEL_LISTENER_STATE_LISTENING,
# 1047 "or.h"
  CHANNEL_LISTENER_STATE_CLOSING,
# 1057 "or.h"
  CHANNEL_LISTENER_STATE_ERROR,



  CHANNEL_LISTENER_STATE_LAST
} channel_listener_state_t;



typedef struct channel_tls_s channel_tls_t;



typedef struct circuitmux_s circuitmux_t;



typedef struct cell_t {
  circid_t circ_id;
  uint8_t command;

  uint8_t payload[509];
} cell_t;


typedef struct var_cell_t {

  uint8_t command;

  circid_t circ_id;

  uint16_t payload_len;

  uint8_t payload[0];
} var_cell_t;


typedef struct ext_or_cmd_t {
  uint16_t cmd;
  uint16_t len;
  char body[0];
} ext_or_cmd_t;


typedef struct packed_cell_t {

  struct { struct packed_cell_t *sqe_next; } next;
  char body[514];
  uint32_t inserted_time;

} packed_cell_t;



typedef struct cell_queue_t {

  struct cell_simpleq { struct packed_cell_t *sqh_first; struct packed_cell_t **sqh_last; } head;
  int n;
} cell_queue_t;


typedef struct {
  uint8_t command;
  uint16_t recognized;
  streamid_t stream_id;
  char integrity[4];
  uint16_t length;
} relay_header_t;

typedef struct buf_t buf_t;
typedef struct socks_request_t socks_request_t;






typedef struct entry_port_cfg_t {

  uint8_t isolation_flags;
  int session_group;





  unsigned int socks_prefer_no_auth : 1;


  unsigned int ipv4_traffic : 1;
  unsigned int ipv6_traffic : 1;
  unsigned int prefer_ipv6 : 1;





  unsigned int cache_ipv4_answers : 1;
  unsigned int cache_ipv6_answers : 1;





  unsigned int use_cached_ipv4_answers : 1;
  unsigned int use_cached_ipv6_answers : 1;



  unsigned int prefer_ipv6_virtaddr : 1;

} entry_port_cfg_t;

typedef struct server_port_cfg_t {

  unsigned int no_advertise : 1;
  unsigned int no_listen : 1;
  unsigned int all_addrs : 1;
  unsigned int bind_ipv4_only : 1;
  unsigned int bind_ipv6_only : 1;
} server_port_cfg_t;
# 1207 "or.h"
typedef struct connection_t {
  uint32_t magic;


  uint8_t state;
  unsigned int type:5;
  unsigned int purpose:5;




  unsigned int read_blocked_on_bw:1;

  unsigned int write_blocked_on_bw:1;


  unsigned int hold_open_until_flushed:1;


  unsigned int inbuf_reached_eof:1;



  unsigned int in_flushed_some:1;


  unsigned int in_connection_handle_write:1;



  unsigned int linked:1;


  unsigned int reading_from_linked_conn:1;

  unsigned int writing_to_linked_conn:1;


  unsigned int active_on_link:1;


  unsigned int linked_conn_is_closed:1;


  unsigned int proxy_state:4;



  int s;
  int conn_array_index;

  struct event *read_event;
  struct event *write_event;
  buf_t *inbuf;
  buf_t *outbuf;
  size_t outbuf_flushlen;

  time_t timestamp_lastread;

  time_t timestamp_lastwritten;






  time_t timestamp_created;


  int socket_family;


  tor_addr_t addr;

  uint16_t port;

  uint16_t marked_for_close;



  const char *marked_for_close_file;

  char *address;


  struct connection_t *linked_conn;


  uint64_t global_identifier;



  uint32_t n_read_conn_bw;



  uint32_t n_written_conn_bw;
} connection_t;


typedef struct listener_connection_t {
  connection_t base_;



  struct evdns_server_port *dns_server_port;

  entry_port_cfg_t entry_cfg;

} listener_connection_t;
# 1361 "or.h"
typedef struct or_handshake_state_t {


  time_t sent_versions_at;

  unsigned int started_here : 1;

  unsigned int received_versions : 1;

  unsigned int received_auth_challenge : 1;

  unsigned int received_certs_cell : 1;

  unsigned int received_authenticate : 1;


  unsigned int authenticated : 1;


  unsigned int sent_netinfo : 1;
# 1391 "or.h"
  unsigned int digest_sent_data : 1;
  unsigned int digest_received_data : 1;




  uint8_t authenticated_peer_id[20];






  crypto_digest_t *digest_sent;
  crypto_digest_t *digest_received;
# 1414 "or.h"
  tor_cert_t *auth_cert;

  tor_cert_t *id_cert;

} or_handshake_state_t;
# 1437 "or.h"
typedef struct or_connection_t {
  connection_t base_;



  char identity_digest[20];


  char *ext_or_conn_id;





  char *ext_or_auth_correct_client_hash;



  char *ext_or_transport;

  char *nickname;

  tor_tls_t *tls;
  int tls_error;




  channel_tls_t *chan;

  tor_addr_t real_addr;
# 1477 "or.h"
  unsigned int is_canonical:1;




  unsigned int is_connection_with_client:1;

  unsigned int is_outgoing:1;
  unsigned int proxy_type:2;
  unsigned int wide_circ_ids:1;


  unsigned int have_noted_bootstrap_problem:1;

  uint16_t link_proto;

  uint16_t idle_timeout;



  or_handshake_state_t *handshake_state;


  time_t timestamp_lastempty;


  int bandwidthrate;
  int bandwidthburst;

  int read_bucket;


  int write_bucket;







  struct or_connection_t *next_with_same_id;



  uint32_t read_emptied_time;


  uint32_t write_emptied_time;





  uint64_t bytes_xmitted, bytes_xmitted_by_tls;
} or_connection_t;



typedef struct edge_connection_t {
  connection_t base_;

  struct edge_connection_t *next_stream;

  int package_window;

  int deliver_window;

  struct circuit_t *on_circuit;




  struct crypt_path_t *cpath_layer;


  rend_data_t *rend_data;

  uint32_t address_ttl;

  uint32_t begincell_flags;


  streamid_t stream_id;



  uint16_t end_reason;


  uint32_t n_read;


  uint32_t n_written;


  unsigned int is_dns_request:1;

  unsigned int is_reverse_dns_lookup:1;

  unsigned int edge_has_sent_end:1;





  unsigned int edge_blocked_on_circ:1;




  uint64_t dirreq_id;
} edge_connection_t;



typedef struct entry_connection_t {
  edge_connection_t edge_;


  char *chosen_exit_name;

  socks_request_t *socks_request;



  entry_port_cfg_t entry_cfg;

  unsigned nym_epoch;


  char *original_dest_address;
# 1616 "or.h"
  uint8_t num_socks_retries;




  buf_t *pending_optimistic_data;



  buf_t *sending_optimistic_data;



  struct evdns_server_request *dns_server_request;






  unsigned int num_circuits_launched:4;



  unsigned int want_onehop:1;


  unsigned int use_begindir:1;



  unsigned int chosen_exit_optional:1;




  unsigned int chosen_exit_retries:3;



  unsigned int is_transparent_ap:1;





  unsigned int may_use_optimistic_data : 1;


  unsigned int is_socks_socket:1;
} entry_connection_t;

typedef enum {
    DIR_SPOOL_NONE=0, DIR_SPOOL_SERVER_BY_DIGEST, DIR_SPOOL_SERVER_BY_FP,
    DIR_SPOOL_EXTRA_BY_DIGEST, DIR_SPOOL_EXTRA_BY_FP,
    DIR_SPOOL_CACHED_DIR, DIR_SPOOL_NETWORKSTATUS,
    DIR_SPOOL_MICRODESC,
} dir_spool_source_t;




typedef struct dir_connection_t {
  connection_t base_;







  char *requested_resource;
  unsigned int dirconn_direct:1;





  unsigned dir_spool_src : 3;



  uint8_t router_purpose;

  smartlist_t *fingerprint_stack;

  struct cached_dir_t *cached_dir;

  off_t cached_dir_offset;

  tor_zlib_state_t *zlib_state;


  rend_data_t *rend_data;

  char identity_digest[20];





  uint64_t dirreq_id;
} dir_connection_t;


typedef struct control_connection_t {
  connection_t base_;

  uint64_t event_mask;




  unsigned int have_sent_protocolinfo:1;


  unsigned int is_owning_control_connection:1;





  char *safecookie_client_hash;


  uint32_t incoming_cmd_len;

  uint32_t incoming_cmd_cur_len;


  char *incoming_cmd;
} control_connection_t;
# 1761 "or.h"
static or_connection_t *TO_OR_CONN(connection_t *);


static dir_connection_t *TO_DIR_CONN(connection_t *);


static edge_connection_t *TO_EDGE_CONN(connection_t *);


static entry_connection_t *TO_ENTRY_CONN(connection_t *);


static entry_connection_t *EDGE_TO_ENTRY_CONN(edge_connection_t *);


static control_connection_t *TO_CONTROL_CONN(connection_t *);


static listener_connection_t *TO_LISTENER_CONN(connection_t *);

static inline or_connection_t *TO_OR_CONN(connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->magic == 0x7D31FF03u)), 0)) { tor_assertion_failed_(("or.h"), 1783, "???", "c->magic == OR_CONNECTION_MAGIC"); abort(); } });
  return ((or_connection_t*)((void*) ( ((char*)(c)) - __builtin_offsetof(or_connection_t, base_) )));
}
static inline dir_connection_t *TO_DIR_CONN(connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->magic == 0x9988ffeeu)), 0)) { tor_assertion_failed_(("or.h"), 1788, "???", "c->magic == DIR_CONNECTION_MAGIC"); abort(); } });
  return ((dir_connection_t*)((void*) ( ((char*)(c)) - __builtin_offsetof(dir_connection_t, base_) )));
}
static inline edge_connection_t *TO_EDGE_CONN(connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->magic == 0xF0374013u || c->magic == 0xbb4a5703)), 0)) { tor_assertion_failed_((
 "or.h"
# 1793 "or.h"
  ),
 1794
# 1793 "or.h"
  , "???", "c->magic == EDGE_CONNECTION_MAGIC || c->magic == ENTRY_CONNECTION_MAGIC"); abort(); } })
                                                ;
  return ((edge_connection_t*)((void*) ( ((char*)(c)) - __builtin_offsetof(edge_connection_t, base_) )));
}
static inline entry_connection_t *TO_ENTRY_CONN(connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->magic == 0xbb4a5703)), 0)) { tor_assertion_failed_(("or.h"), 1799, "???", "c->magic == ENTRY_CONNECTION_MAGIC"); abort(); } });
  return (entry_connection_t*) ((void*) ( ((char*)(c)) - __builtin_offsetof(entry_connection_t, edge_.base_) ));
}
static inline entry_connection_t *EDGE_TO_ENTRY_CONN(edge_connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->base_.magic == 0xbb4a5703)), 0)) { tor_assertion_failed_(("or.h"), 1804, "???", "c->base_.magic == ENTRY_CONNECTION_MAGIC"); abort(); } });
  return (entry_connection_t*) ((void*) ( ((char*)(c)) - __builtin_offsetof(entry_connection_t, edge_) ));
}
static inline control_connection_t *TO_CONTROL_CONN(connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->magic == 0x8abc765du)), 0)) { tor_assertion_failed_(("or.h"), 1809, "???", "c->magic == CONTROL_CONNECTION_MAGIC"); abort(); } });
  return ((control_connection_t*)((void*) ( ((char*)(c)) - __builtin_offsetof(control_connection_t, base_) )));
}
static inline listener_connection_t *TO_LISTENER_CONN(connection_t *c)
{
  (void) ({ if (__builtin_expect(!!(!(c->magic == 0x1a1ac741u)), 0)) { tor_assertion_failed_(("or.h"), 1814, "???", "c->magic == LISTENER_CONNECTION_MAGIC"); abort(); } });
  return ((listener_connection_t*)((void*) ( ((char*)(c)) - __builtin_offsetof(listener_connection_t, base_) )));
}
# 1864 "or.h"
typedef enum {
  ADDR_POLICY_ACCEPT=1,
  ADDR_POLICY_REJECT=2,
} addr_policy_action_t;



typedef struct addr_policy_t {
  int refcnt;

  unsigned policy_type:2;
  unsigned int is_private:1;

  unsigned int is_canonical:1;


  maskbits_t maskbits;
# 1891 "or.h"
  tor_addr_t addr;
  uint16_t prt_min;
  uint16_t prt_max;
} addr_policy_t;



typedef struct cached_dir_t {
  char *dir;
  char *dir_z;
  size_t dir_len;
  size_t dir_z_len;
  time_t published;
  digests_t digests;
  int refcnt;
} cached_dir_t;



typedef enum {


  SAVED_NOWHERE=0,



  SAVED_IN_CACHE,






  SAVED_IN_JOURNAL
} saved_location_t;




typedef enum {
  DL_SCHED_GENERIC = 0,
  DL_SCHED_CONSENSUS = 1,
  DL_SCHED_BRIDGE = 2,
} download_schedule_t;




typedef struct download_status_t {
  time_t next_attempt_at;

  uint8_t n_download_failures;

  unsigned schedule : 8;

} download_status_t;
# 1957 "or.h"
typedef struct signed_descriptor_t {



  char *signed_descriptor_body;

  size_t annotations_len;

  size_t signed_descriptor_len;


  char signed_descriptor_digest[20];

  char identity_digest[20];

  time_t published_on;

  char extra_info_digest[20];


  download_status_t ei_dl_status;

  saved_location_t saved_location;


  off_t saved_offset;


  int routerlist_index;


  time_t last_listed_as_valid_until;

  unsigned int do_not_cache : 1;

  unsigned int is_extrainfo : 1;


  unsigned int extrainfo_is_bogus : 1;

  unsigned int send_unencrypted : 1;
} signed_descriptor_t;


typedef int16_t country_t;


typedef struct {
  signed_descriptor_t cache_info;
  char *nickname;

  uint32_t addr;
  uint16_t or_port;
  uint16_t dir_port;





  tor_addr_t ipv6_addr;
  uint16_t ipv6_orport;

  crypto_pk_t *onion_pkey;
  crypto_pk_t *identity_pkey;

  curve25519_public_key_t *onion_curve25519_pkey;

  char *platform;


  uint32_t bandwidthrate;

  uint32_t bandwidthburst;

  uint32_t bandwidthcapacity;
  smartlist_t *exit_policy;



  struct short_policy_t *ipv6_exit_policy;
  long uptime;
  smartlist_t *declared_family;

  char *contact_info;
  unsigned int is_hibernating:1;

  unsigned int caches_extra_info:1;

  unsigned int allow_single_hop_exits:1;


  unsigned int wants_to_be_hs_dir:1;

  unsigned int policy_is_reject_star:1;



  unsigned int needs_retest_if_added:1;
# 2076 "or.h"
  uint8_t purpose;
} routerinfo_t;


typedef struct extrainfo_t {
  signed_descriptor_t cache_info;

  char nickname[19 +1];


  unsigned int bad_sig : 1;


  char *pending_sig;

  size_t pending_sig_len;
} extrainfo_t;



typedef struct routerstatus_t {
  time_t published_on;
  char nickname[19 +1];

  char identity_digest[20];



  char descriptor_digest[32];
  uint32_t addr;
  uint16_t or_port;
  uint16_t dir_port;
  tor_addr_t ipv6_addr;
  uint16_t ipv6_orport;
  unsigned int is_authority:1;
  unsigned int is_exit:1;
  unsigned int is_stable:1;
  unsigned int is_fast:1;




  unsigned int is_flagged_running:1;
  unsigned int is_named:1;
  unsigned int is_unnamed:1;

  unsigned int is_valid:1;
  unsigned int is_possible_guard:1;

  unsigned int is_bad_exit:1;

  unsigned int is_hs_dir:1;




  unsigned int version_known:1;



  unsigned int version_supports_microdesc_cache:1;


  unsigned int version_supports_extend2_cells:1;

  unsigned int has_bandwidth:1;
  unsigned int has_exitsummary:1;
  unsigned int bw_is_unmeasured:1;


  uint32_t bandwidth_kb;



  unsigned int has_guardfraction:1;

  uint32_t guardfraction_percentage;

  char *exitsummary;





  time_t last_dir_503_at;

  download_status_t dl_status;

} routerstatus_t;


typedef struct short_policy_entry_t {
  uint16_t min_port, max_port;
} short_policy_entry_t;


typedef struct short_policy_t {


  unsigned int is_accept : 1;

  unsigned int n_entries : 31;




  short_policy_entry_t entries[0];
} short_policy_t;






typedef struct microdesc_t {

  struct { struct microdesc_t *hte_next; unsigned hte_hash; } node;






  time_t last_listed;

  unsigned saved_location : 3;

  unsigned int no_save : 1;

  unsigned int held_in_map : 1;

  unsigned int held_by_nodes;



  off_t off;







  char *body;

  size_t bodylen;

  char digest[32];




  crypto_pk_t *onion_pkey;

  curve25519_public_key_t *onion_curve25519_pkey;

  tor_addr_t ipv6_addr;

  uint16_t ipv6_orport;

  smartlist_t *family;

  short_policy_t *exit_policy;

  short_policy_t *ipv6_exit_policy;

} microdesc_t;
# 2259 "or.h"
typedef struct node_t {



  struct { struct node_t *hte_next; unsigned hte_hash; } ht_ent;

  int nodelist_idx;



  char identity[20];

  microdesc_t *md;
  routerinfo_t *ri;
  routerstatus_t *rs;





  unsigned int is_running:1;

  unsigned int is_valid:1;

  unsigned int is_fast:1;
  unsigned int is_stable:1;
  unsigned int is_possible_guard:1;
  unsigned int is_exit:1;
  unsigned int is_bad_exit:1;

  unsigned int is_hs_dir:1;




  unsigned int name_lookup_warned:1;




  unsigned int rejects_all:1;


  unsigned int using_as_guard:1;




  unsigned int ipv6_preferred:1;



  country_t country;





  time_t last_reachable;
  time_t last_reachable6;

} node_t;




typedef struct vote_microdesc_hash_t {

  struct vote_microdesc_hash_t *next;


  char *microdesc_hash_line;
} vote_microdesc_hash_t;


typedef struct vote_routerstatus_t {
  routerstatus_t status;




  uint64_t flags;

  char *version;

  unsigned int has_measured_bw:1;
  uint32_t measured_bw_kb;

  vote_microdesc_hash_t *microdesc;
} vote_routerstatus_t;


typedef struct document_signature_t {

  char identity_digest[20];

  char signing_key_digest[20];

  digest_algorithm_t alg;

  char *signature;

  int signature_len;
  unsigned int bad_signature : 1;

  unsigned int good_signature : 1;

} document_signature_t;


typedef struct networkstatus_voter_info_t {

  char identity_digest[20];
  char *nickname;


  char legacy_id_digest[20];
  char *address;
  uint32_t addr;
  uint16_t dir_port;
  uint16_t or_port;
  char *contact;
  char vote_digest[20];



  smartlist_t *sigs;
} networkstatus_voter_info_t;


typedef enum {
  NS_TYPE_VOTE,
  NS_TYPE_CONSENSUS,
  NS_TYPE_OPINION,
} networkstatus_type_t;




typedef enum {
  FLAV_NS = 0,
  FLAV_MICRODESC = 1,
} consensus_flavor_t;






typedef struct networkstatus_t {
  networkstatus_type_t type;
  consensus_flavor_t flavor;
  unsigned int has_measured_bws : 1;


  time_t published;
  time_t valid_after;
  time_t fresh_until;

  time_t valid_until;



  int consensus_method;

  smartlist_t *supported_methods;


  smartlist_t *package_lines;



  int vote_seconds;


  int dist_seconds;



  char *client_versions;
  char *server_versions;


  smartlist_t *known_flags;



  smartlist_t *net_params;



  smartlist_t *weight_params;




  smartlist_t *voters;

  struct authority_cert_t *cert;


  digests_t digests;




  smartlist_t *routerstatus_list;



  digestmap_t *desc_digest_map;
} networkstatus_t;



typedef struct ns_detached_signatures_t {
  time_t valid_after;
  time_t fresh_until;
  time_t valid_until;
  strmap_t *digests;
  strmap_t *signatures;

} ns_detached_signatures_t;


typedef enum store_type_t {
  ROUTER_STORE = 0,
  EXTRAINFO_STORE = 1
} store_type_t;



typedef struct desc_store_t {



  const char *fname_base;

  const char *description;

  tor_mmap_t *mmap;

  store_type_t type;


  size_t journal_len;

  size_t store_len;


  size_t bytes_dropped;
} desc_store_t;


typedef struct {

  struct digest_ri_map_t *identity_map;


  struct digest_sd_map_t *desc_digest_map;


  struct digest_ei_map_t *extra_info_map;



  struct digest_sd_map_t *desc_by_eid_map;

  smartlist_t *routers;


  smartlist_t *old_routers;



  desc_store_t desc_store;

  desc_store_t extrainfo_store;
} routerlist_t;





typedef struct extend_info_t {
  char nickname[(40 +1)+1];

  char identity_digest[20];
  uint16_t port;
  tor_addr_t addr;
  crypto_pk_t *onion_key;
  curve25519_public_key_t curve25519_onion_key;
} extend_info_t;



typedef struct authority_cert_t {

  signed_descriptor_t cache_info;

  crypto_pk_t *identity_key;

  crypto_pk_t *signing_key;

  char signing_key_digest[20];

  time_t expires;

  uint32_t addr;

  uint16_t dir_port;
} authority_cert_t;
# 2581 "or.h"
typedef enum {
  NO_DIRINFO = 0,

  V3_DIRINFO = 1 << 2,

  BRIDGE_DIRINFO = 1 << 4,

  EXTRAINFO_DIRINFO=1 << 5,

  MICRODESC_DIRINFO=1 << 6,
} dirinfo_type_t;





struct fast_handshake_state_t;
struct ntor_handshake_state_t;




typedef struct {
  uint16_t tag;
  union {
    struct fast_handshake_state_t *fast;
    crypto_dh_t *tap;
    struct ntor_handshake_state_t *ntor;
  } u;
} onion_handshake_state_t;



typedef struct crypt_path_t {
  uint32_t magic;




  crypto_cipher_t *f_crypto;


  crypto_cipher_t *b_crypto;


  crypto_digest_t *f_digest;

  crypto_digest_t *b_digest;



  onion_handshake_state_t handshake_state;


  crypto_dh_t *rend_dh_handshake_state;


  char rend_circ_nonce[20];


  extend_info_t *extend_info;






  uint8_t state;



  struct crypt_path_t *next;


  struct crypt_path_t *prev;


  int package_window;

  int deliver_window;

} crypt_path_t;





typedef struct {

  unsigned int refcount;


  crypt_path_t *cpath;
} crypt_path_reference_t;






typedef struct {

  int desired_path_len;

  extend_info_t *chosen_exit;

  unsigned int need_uptime : 1;

  unsigned int need_capacity : 1;

  unsigned int is_internal : 1;



  unsigned int onehop_tunnel : 1;

  crypt_path_t *pending_final_cpath;


  crypt_path_reference_t *service_pending_final_cpath_ref;

  int failure_count;

  time_t expiry_time;
} cpath_build_state_t;
# 2716 "or.h"
struct create_cell_t;



typedef struct testing_cell_stats_entry_t {
  uint8_t command;




  unsigned int waiting_time:22;
  unsigned int removed:1;
  unsigned int exitward:1;
} testing_cell_stats_entry_t;
# 2754 "or.h"
typedef struct circuit_t {
  uint32_t magic;



  channel_t *n_chan;
# 2768 "or.h"
  circid_t n_circ_id;





  circuitmux_t *n_mux;


  cell_queue_t n_chan_cells;





  extend_info_t *n_hop;



  unsigned int streams_blocked_on_n_chan : 1;


  unsigned int streams_blocked_on_p_chan : 1;



  unsigned int p_delete_pending : 1;


  unsigned int n_delete_pending : 1;


  unsigned int received_destroy : 1;

  uint8_t state;
  uint8_t purpose;




  int package_window;




  int deliver_window;


  uint32_t age_tmp;


  struct create_cell_t *n_chan_create_cell;
# 2831 "or.h"
  struct timeval timestamp_began;


  struct timeval timestamp_created;
# 2848 "or.h"
  time_t timestamp_dirty;

  uint16_t marked_for_close;


  const char *marked_for_close_file;



  uint64_t dirreq_id;


  int global_circuitlist_idx;




  struct circuit_t *next_active_on_n_chan;



  struct circuit_t *prev_active_on_n_chan;




  smartlist_t *testing_cell_stats;
} circuit_t;
# 2896 "or.h"
typedef enum {


    PATH_STATE_NEW_CIRC = 0,


    PATH_STATE_BUILD_ATTEMPTED = 1,

    PATH_STATE_BUILD_SUCCEEDED = 2,
# 2913 "or.h"
    PATH_STATE_USE_ATTEMPTED = 3,







    PATH_STATE_USE_SUCCEEDED = 4,





    PATH_STATE_USE_FAILED = 5,






    PATH_STATE_ALREADY_COUNTED = 6,
} path_state_t;




typedef struct origin_circuit_t {
  circuit_t base_;



  edge_connection_t *p_streams;




  uint32_t n_read_circ_bw;




  uint32_t n_written_circ_bw;




  cpath_build_state_t *build_state;





  crypt_path_t *cpath;


  rend_data_t *rend_data;



  unsigned int remaining_relay_early_cells : 4;


  unsigned int is_ancient : 1;



  unsigned int has_opened : 1;






  unsigned path_state : 3;



  unsigned int unusable_for_new_conns : 1;
# 3000 "or.h"
  uint8_t pathbias_shouldcount;






  streamid_t pathbias_probe_id;



  uint32_t pathbias_probe_nonce;
# 3027 "or.h"
  unsigned int hs_circ_has_timed_out : 1;



  unsigned int relaxed_timeout : 1;







  unsigned int hs_service_side_rend_circ_has_been_relaunched : 1;



  uint8_t relay_early_commands[8];



  int relay_early_cells_sent;



  streamid_t next_stream_id;




  crypto_pk_t *intro_key;



  uint32_t global_identifier;






  unsigned int isolation_values_set : 1;





  unsigned int isolation_any_streams_attached : 1;




  uint8_t isolation_flags_mixed;
# 3093 "or.h"
  uint8_t client_proto_type;
  uint8_t client_proto_socksver;
  uint16_t dest_port;
  tor_addr_t client_addr;
  char *dest_address;
  int session_group;
  unsigned nym_epoch;
  size_t socks_username_len;
  uint8_t socks_password_len;


  char *socks_username;
  char *socks_password;


  uint64_t associated_isolated_stream_global_id;




  smartlist_t *prepend_policy;
} origin_circuit_t;

struct onion_queue_t;



typedef struct or_circuit_t {
  circuit_t base_;




  struct circuit_t *next_active_on_p_chan;



  struct circuit_t *prev_active_on_p_chan;


  struct onion_queue_t *onionqueue_entry;



  struct workqueue_entry_s *workqueue_entry;


  circid_t p_circ_id;

  cell_queue_t p_chan_cells;

  channel_t *p_chan;




  circuitmux_t *p_mux;

  edge_connection_t *n_streams;


  edge_connection_t *resolving_streams;


  crypto_cipher_t *p_crypto;


  crypto_cipher_t *n_crypto;




  crypto_digest_t *p_digest;



  crypto_digest_t *n_digest;



  struct or_circuit_t *rend_splice;

  struct or_circuit_rendinfo_s *rendinfo;


  char rend_circ_nonce[20];



  unsigned int remaining_relay_early_cells : 4;


  unsigned int already_received_introduce1 : 1;


  unsigned int is_first_hop : 1;



  unsigned int circuit_carries_hs_traffic_stats : 1;



  uint32_t processed_cells;




  uint64_t total_cell_waiting_time;





  uint32_t max_middle_cells;
} or_circuit_t;

typedef struct or_circuit_rendinfo_s {
# 3221 "or.h"
  char rend_token[20];



  unsigned is_rend_circ;

} or_circuit_rendinfo_t;






static or_circuit_t *TO_OR_CIRCUIT(circuit_t *);
static const or_circuit_t *CONST_TO_OR_CIRCUIT(const circuit_t *);


static origin_circuit_t *TO_ORIGIN_CIRCUIT(circuit_t *);
static const origin_circuit_t *CONST_TO_ORIGIN_CIRCUIT(const circuit_t *);




static inline int node_is_good_exit(const node_t *node)
{
  return node->is_exit && ! node->is_bad_exit;
}

static inline or_circuit_t *TO_OR_CIRCUIT(circuit_t *x)
{
  (void) ({ if (__builtin_expect(!!(!(x->magic == 0x98ABC04Fu)), 0)) { tor_assertion_failed_(("or.h"), 3251, "???", "x->magic == OR_CIRCUIT_MAGIC"); abort(); } });
  return ((or_circuit_t*)((void*) ( ((char*)(x)) - __builtin_offsetof(or_circuit_t, base_) )));
}
static inline const or_circuit_t *CONST_TO_OR_CIRCUIT(const circuit_t *x)
{
  (void) ({ if (__builtin_expect(!!(!(x->magic == 0x98ABC04Fu)), 0)) { tor_assertion_failed_(("or.h"), 3256, "???", "x->magic == OR_CIRCUIT_MAGIC"); abort(); } });
  return ((or_circuit_t*)((void*) ( ((char*)(x)) - __builtin_offsetof(or_circuit_t, base_) )));
}
static inline origin_circuit_t *TO_ORIGIN_CIRCUIT(circuit_t *x)
{
  (void) ({ if (__builtin_expect(!!(!(x->magic == 0x35315243u)), 0)) { tor_assertion_failed_(("or.h"), 3261, "???", "x->magic == ORIGIN_CIRCUIT_MAGIC"); abort(); } });
  return ((origin_circuit_t*)((void*) ( ((char*)(x)) - __builtin_offsetof(origin_circuit_t, base_) )));
}
static inline const origin_circuit_t *CONST_TO_ORIGIN_CIRCUIT(
    const circuit_t *x)
{
  (void) ({ if (__builtin_expect(!!(!(x->magic == 0x35315243u)), 0)) { tor_assertion_failed_(("or.h"), 3267, "???", "x->magic == ORIGIN_CIRCUIT_MAGIC"); abort(); } });
  return ((origin_circuit_t*)((void*) ( ((char*)(x)) - __builtin_offsetof(origin_circuit_t, base_) )));
}


typedef enum invalid_router_usage_t {
  ALLOW_INVALID_ENTRY =1,
  ALLOW_INVALID_EXIT =2,
  ALLOW_INVALID_MIDDLE =4,
  ALLOW_INVALID_RENDEZVOUS =8,
  ALLOW_INVALID_INTRODUCTION=16,
} invalid_router_usage_t;
# 3321 "or.h"
typedef struct port_cfg_t {
  tor_addr_t addr;
  int port;

  uint8_t type;
  unsigned is_unix_addr : 1;

  entry_port_cfg_t entry_cfg;

  server_port_cfg_t server_cfg;



  char unix_addr[0];
} port_cfg_t;
# 3346 "or.h"
typedef struct config_line_t {
  char *key;
  char *value;
  struct config_line_t *next;

  unsigned int command:2;



  unsigned int fragile:1;
} config_line_t;

typedef struct routerset_t routerset_t;






typedef struct {
  uint32_t magic_;


  enum {
    CMD_RUN_TOR=0, CMD_LIST_FINGERPRINT, CMD_HASH_PASSWORD,
    CMD_VERIFY_CONFIG, CMD_RUN_UNITTESTS, CMD_DUMP_CONFIG
  } command;
  char *command_arg;

  config_line_t *Logs;

  int LogTimeGranularity;

  int LogMessageDomains;

  int TruncateLogFile;


  char *DebugLogFile;
  char *DataDirectory;
  char *Nickname;
  char *Address;
  char *PidFile;

  int DynamicDHGroups;

  routerset_t *ExitNodes;


  routerset_t *EntryNodes;


  int StrictNodes;


  routerset_t *ExcludeNodes;



  routerset_t *ExcludeExitNodes;




  routerset_t *ExcludeExitNodesUnion_;

  int DisableAllSwap;



  smartlist_t *AllowInvalidNodes;

  invalid_router_usage_t AllowInvalid_;
  config_line_t *ExitPolicy;
  int ExitPolicyRejectPrivate;
  config_line_t *SocksPolicy;
  config_line_t *DirPolicy;

  config_line_t *SocksListenAddress;


  config_line_t *TransListenAddress;

  config_line_t *NATDListenAddress;

  config_line_t *DNSListenAddress;

  config_line_t *ORListenAddress;

  config_line_t *DirListenAddress;

  config_line_t *ControlListenAddress;

  config_line_t *OutboundBindAddress;

  tor_addr_t OutboundBindAddressIPv4_;

  tor_addr_t OutboundBindAddressIPv6_;


  config_line_t *RecommendedVersions;
  config_line_t *RecommendedClientVersions;
  config_line_t *RecommendedServerVersions;
  config_line_t *RecommendedPackages;

  int DirAllowPrivateAddresses;

  int ExtendAllowPrivateAddresses;
  char *User;
  char *Group;
  config_line_t *ORPort_lines;

  config_line_t *ExtORPort_lines;

  config_line_t *SocksPort_lines;

  config_line_t *TransPort_lines;
  const char *TransProxyType;


  enum {
    TPT_DEFAULT,
    TPT_PF_DIVERT,
    TPT_IPFW,
    TPT_TPROXY,
  } TransProxyType_parsed;
  config_line_t *NATDPort_lines;

  config_line_t *ControlPort_lines;

  config_line_t *ControlSocket;


  int ControlSocketsGroupWritable;
  int SocksSocketsGroupWritable;

  config_line_t *DirPort_lines;
  config_line_t *DNSPort_lines;



  uint64_t MaxMemInQueues_raw;
  uint64_t MaxMemInQueues;


  uint64_t MaxMemInQueues_low_threshold;
# 3501 "or.h"
  unsigned int ORPort_set : 1;
  unsigned int SocksPort_set : 1;
  unsigned int TransPort_set : 1;
  unsigned int NATDPort_set : 1;
  unsigned int ControlPort_set : 1;
  unsigned int DirPort_set : 1;
  unsigned int DNSPort_set : 1;
  unsigned int ExtORPort_set : 1;


  int AssumeReachable;
  int AuthoritativeDir;
  int V3AuthoritativeDir;

  int VersioningAuthoritativeDir;


  int BridgeAuthoritativeDir;




  char *BridgePassword;


  char *BridgePassword_AuthDigest_;

  int UseBridges;
  config_line_t *Bridges;

  config_line_t *ClientTransportPlugin;


  config_line_t *ServerTransportPlugin;



  config_line_t *ServerTransportListenAddr;


  config_line_t *ServerTransportOptions;

  int BridgeRelay;





  int UpdateBridgesFromAuthority;

  int AvoidDiskWrites;

  int ClientOnly;


  smartlist_t *PublishServerDescriptor;

  dirinfo_type_t PublishServerDescriptor_;

  int PublishHidServDescriptors;
  int FetchServerDescriptors;
  int FetchHidServDescriptors;
  int HidServDirectoryV2;

  int VoteOnHidServDirectoriesV2;

  int MinUptimeHidServDirectoryV2;


  int FetchUselessDescriptors;
  int AllDirActionsPrivate;





  int Tor2webMode;


  routerset_t *Tor2webRendezvousPoints;




  int CloseHSClientCircuitsImmediatelyOnTimeout;



  int CloseHSServiceRendCircuitsImmediatelyOnTimeout;

  int ConnLimit;
  int ConnLimit_;
  int RunAsDaemon;
  int FascistFirewall;
  smartlist_t *FirewallPorts;

  config_line_t *ReachableAddresses;
  config_line_t *ReachableORAddresses;
  config_line_t *ReachableDirAddresses;

  int ConstrainedSockets;
  uint64_t ConstrainedSockSize;





  int RefuseUnknownExits;



  smartlist_t *LongLivedPorts;




  smartlist_t *RejectPlaintextPorts;



  smartlist_t *WarnPlaintextPorts;

  smartlist_t *TrackHostExits;
  int TrackHostExitsExpire;

  config_line_t *AddressMap;
  int AutomapHostsOnResolve;





  smartlist_t *AutomapHostsSuffixes;
  int RendPostPeriod;

  int KeepalivePeriod;

  int SocksTimeout;

  int LearnCircuitBuildTimeout;


  int CircuitBuildTimeout;


  int CircuitIdleTimeout;

  int CircuitStreamTimeout;



  int MaxOnionQueueDelay;
  int NewCircuitPeriod;

  int MaxCircuitDirtiness;

  int PredictedPortsRelevanceTime;



  uint64_t BandwidthRate;

  uint64_t BandwidthBurst;

  uint64_t MaxAdvertisedBandwidth;

  uint64_t RelayBandwidthRate;

  uint64_t RelayBandwidthBurst;

  uint64_t PerConnBWRate;
  uint64_t PerConnBWBurst;
  int NumCPUs;


  config_line_t *RendConfigLines;

  config_line_t *HidServAuth;

  char *ContactInfo;

  int HeartbeatPeriod;


  char *HTTPProxy;
  tor_addr_t HTTPProxyAddr;
  uint16_t HTTPProxyPort;
  char *HTTPProxyAuthenticator;

  char *HTTPSProxy;
  tor_addr_t HTTPSProxyAddr;
  uint16_t HTTPSProxyPort;
  char *HTTPSProxyAuthenticator;

  char *Socks4Proxy;
  tor_addr_t Socks4ProxyAddr;
  uint16_t Socks4ProxyPort;

  char *Socks5Proxy;
  tor_addr_t Socks5ProxyAddr;
  uint16_t Socks5ProxyPort;
  char *Socks5ProxyUsername;
  char *Socks5ProxyPassword;




  config_line_t *DirAuthorities;


  config_line_t *FallbackDir;



  double DirAuthorityFallbackRate;



  config_line_t *AlternateDirAuthority;


  config_line_t *AlternateBridgeAuthority;

  char *MyFamily;
  config_line_t *NodeFamilies;

  smartlist_t *NodeFamilySets;
  config_line_t *AuthDirBadExit;

  config_line_t *AuthDirReject;

  config_line_t *AuthDirInvalid;
# 3741 "or.h"
  smartlist_t *AuthDirBadExitCCs;
  smartlist_t *AuthDirInvalidCCs;
  smartlist_t *AuthDirRejectCCs;


  int AuthDirListBadExits;

  int AuthDirMaxServersPerAddr;

  int AuthDirMaxServersPerAuthAddr;


  int AuthDirHasIPv6Connectivity;



  uint64_t AuthDirFastGuarantee;



  uint64_t AuthDirGuardBWGuarantee;

  char *AccountingStart;

  uint64_t AccountingMax;





  char *AccountingRule_option;
  enum { ACCT_MAX, ACCT_SUM } AccountingRule;


  config_line_t *HashedControlPassword;

  config_line_t *HashedControlSessionPassword;

  int CookieAuthentication;

  char *CookieAuthFile;

  char *ExtORPortCookieAuthFile;

  int CookieAuthFileGroupReadable;
  int ExtORPortCookieAuthFileGroupReadable;

  int LeaveStreamsUnattached;


  int DisablePredictedCircuits;





  char *OwningControllerProcess;

  int ShutdownWaitLength;

  char *SafeLogging;


  enum {
    SAFELOG_SCRUB_ALL, SAFELOG_SCRUB_RELAY, SAFELOG_SCRUB_NONE
  } SafeLogging_;

  int Sandbox;
  int SafeSocks;



  int ProtocolWarnings;

  int TestSocks;

  int HardwareAccel;


  int TokenBucketRefillInterval;
  char *AccelName;
  char *AccelDir;
  int UseEntryGuards;

  int NumEntryGuards;
  int UseEntryGuardsAsDirGuards;





  int UseGuardFraction;

  int NumDirectoryGuards;

  int RephistTrackTime;
  int FastFirstHopPK;



  int FetchDirInfoEarly;


  int FetchDirInfoExtraEarly;

  char *VirtualAddrNetworkIPv4;

  char *VirtualAddrNetworkIPv6;

  int ServerDNSSearchDomains;


  int ServerDNSDetectHijacking;

  int ServerDNSRandomizeCase;

  char *ServerDNSResolvConfFile;


  char *DirPortFrontPage;



  int DisableDebuggerAttachment;



  int ServerDNSAllowBrokenConfig;


  int CountPrivateBandwidth;
  smartlist_t *ServerDNSTestAddresses;


  int EnforceDistinctSubnets;

  int PortForwarding;

  char *PortForwardingHelper;

  int AllowNonRFC953Hostnames;


  int ServerDNSAllowNonRFC953Hostnames;



  int DownloadExtraInfo;



  int AllowSingleHopExits;


  int ExcludeSingleHopRelays;


  int AllowSingleHopCircuits;






  int AllowDotExit;



  int WarnUnsafeSocks;



  int DirReqStatistics_option;


  int DirReqStatistics;


  int ExitPortStatistics;


  int ConnDirectionStatistics;


  int CellStatistics;


  int EntryStatistics;



  int HiddenServiceStatistics;


  int ExtraInfoStatistics;




  int ClientDNSRejectInternalAddresses;



  int ClientRejectInternalAddresses;




  int ClientUseIPv6;

  int ClientPreferIPv6ORPort;


  int V3AuthVotingInterval;

  int V3AuthVoteDelay;

  int V3AuthDistDelay;

  int V3AuthNIntervalsValid;



  int V3AuthUseLegacyKey;


  char *V3BandwidthsFile;


  char *GuardfractionFile;



  char *ConsensusParams;



  int MinMeasuredBWsForAuthToIgnoreAdvertised;



  int TestingV3AuthInitialVotingInterval;



  int TestingV3AuthInitialVoteDelay;



  int TestingV3AuthInitialDistDelay;



  int TestingV3AuthVotingStartOffset;




  int TestingAuthDirTimeToLearnReachability;




  int TestingEstimatedDescriptorPropagationTime;



  smartlist_t *TestingServerDownloadSchedule;



  smartlist_t *TestingClientDownloadSchedule;



  smartlist_t *TestingServerConsensusDownloadSchedule;



  smartlist_t *TestingClientConsensusDownloadSchedule;



  smartlist_t *TestingBridgeDownloadSchedule;




  int TestingClientMaxIntervalWithoutRequest;



  int TestingDirConnectionMaxStall;



  int TestingConsensusMaxDownloadTries;



  int TestingDescriptorMaxDownloadTries;



  int TestingMicrodescMaxDownloadTries;



  int TestingCertMaxDownloadTries;




  int TestingTorNetwork;


  uint64_t TestingMinExitFlagThreshold;


  uint64_t TestingMinFastFlagThreshold;



  routerset_t *TestingDirAuthVoteExit;



  routerset_t *TestingDirAuthVoteGuard;




  routerset_t *TestingDirAuthVoteHSDir;


  int TestingEnableConnBwEvent;


  int TestingEnableCellStatsEvent;


  int TestingEnableTbEmptyEvent;




  int BridgeRecordUsageByCountry;


  char *GeoIPFile;
  char *GeoIPv6File;




  int GeoIPExcludeUnknown;



  int ReloadTorrcOnSIGHUP;
# 4115 "or.h"
  double CircuitPriorityHalflife;



  int DisableIOCP;

  int UseFilteringSSLBufferevents;




  int UsingTestNetworkDefaults_;



  int UseMicrodescriptors;


  char *ControlPortWriteToFile;

  int ControlPortFileGroupReadable;




  int MaxClientCircuitsPending;



  int OptimisticData;




  int UserspaceIOCPBuffers;



  int DisableNetwork;
# 4180 "or.h"
  int PathBiasCircThreshold;
  double PathBiasNoticeRate;
  double PathBiasWarnRate;
  double PathBiasExtremeRate;
  int PathBiasDropGuards;
  int PathBiasScaleThreshold;
# 4206 "or.h"
  int PathBiasUseThreshold;
  double PathBiasNoticeUseRate;
  double PathBiasExtremeUseRate;
  int PathBiasScaleUseThreshold;


  int IPv6Exit;

  char *TLSECGroup;


  int UseNTorHandshake;


  double PathsNeededToBuildCircuits;



  int SSLKeyLifetime;


  int GuardLifetime;




  uint64_t SchedulerLowWaterMark__;



  uint64_t SchedulerHighWaterMark__;



  int SchedulerMaxFlushCells__;






  int ExitRelay;

} or_options_t;


typedef struct {
  uint32_t magic_;



  time_t next_write;


  time_t LastWritten;


  time_t AccountingIntervalStart;
  uint64_t AccountingBytesReadInInterval;
  uint64_t AccountingBytesWrittenInInterval;
  int AccountingSecondsActive;
  int AccountingSecondsToReachSoftLimit;
  time_t AccountingSoftLimitHitAt;
  uint64_t AccountingBytesAtSoftLimit;
  uint64_t AccountingExpectedUsage;


  config_line_t *EntryGuards;

  config_line_t *TransportProxies;
# 4285 "or.h"
  time_t BWHistoryReadEnds;
  int BWHistoryReadInterval;
  smartlist_t *BWHistoryReadValues;
  smartlist_t *BWHistoryReadMaxima;
  time_t BWHistoryWriteEnds;
  int BWHistoryWriteInterval;
  smartlist_t *BWHistoryWriteValues;
  smartlist_t *BWHistoryWriteMaxima;
  time_t BWHistoryDirReadEnds;
  int BWHistoryDirReadInterval;
  smartlist_t *BWHistoryDirReadValues;
  smartlist_t *BWHistoryDirReadMaxima;
  time_t BWHistoryDirWriteEnds;
  int BWHistoryDirWriteInterval;
  smartlist_t *BWHistoryDirWriteValues;
  smartlist_t *BWHistoryDirWriteMaxima;


  config_line_t * BuildtimeHistogram;
  unsigned int TotalBuildTimes;
  unsigned int CircuitBuildAbandonedCount;


  char *TorVersion;



  config_line_t *ExtraLines;


  time_t LastRotatedOnionKey;
} or_state_t;




static inline void or_state_mark_dirty(or_state_t *state, time_t when)
{
  if (state->next_write > when)
    state->next_write = when;
}
# 4347 "or.h"
struct socks_request_t {



  uint8_t socks_version;



  uint8_t auth_type;

  uint8_t command;

  uint8_t listener_type;
  size_t replylen;
  uint8_t reply[1024];





  char address[256];

  uint16_t port;
  unsigned int has_finished : 1;


  unsigned int got_auth : 1;



  unsigned int socks_prefer_no_auth : 1;


  size_t usernamelen;

  uint8_t passwordlen;



  char *username;


  char *password;
};
# 4417 "or.h"
typedef uint32_t build_time_t;
# 4468 "or.h"
double circuit_build_times_quantile_cutoff(void);
# 4484 "or.h"
int32_t circuit_build_times_initial_timeout(void);






typedef struct {

  time_t network_last_live;

  int nonlive_timeouts;


  int8_t *timeouts_after_firsthop;

  int num_recent_circs;

  int after_firsthop_idx;
} network_liveness_t;

typedef struct circuit_build_times_s circuit_build_times_t;




typedef enum setopt_err_t {
  SETOPT_OK = 0,
  SETOPT_ERR_MISC = -1,
  SETOPT_ERR_PARSE = -2,
  SETOPT_ERR_TRANSITION = -3,
  SETOPT_ERR_SETTING = -4,
} setopt_err_t;




typedef enum {

  ADDRMAPSRC_CONTROLLER,


  ADDRMAPSRC_AUTOMAP,


  ADDRMAPSRC_TORRC,


  ADDRMAPSRC_TRACKEXIT,


  ADDRMAPSRC_DNS,




  ADDRMAPSRC_NONE
} addressmap_entry_source_t;






typedef enum circuit_status_event_t {
  CIRC_EVENT_LAUNCHED = 0,
  CIRC_EVENT_BUILT = 1,
  CIRC_EVENT_EXTENDED = 2,
  CIRC_EVENT_FAILED = 3,
  CIRC_EVENT_CLOSED = 4,
} circuit_status_event_t;



typedef enum circuit_status_minor_event_t {
  CIRC_MINOR_EVENT_PURPOSE_CHANGED,
  CIRC_MINOR_EVENT_CANNIBALIZED,
} circuit_status_minor_event_t;



typedef enum stream_status_event_t {
  STREAM_EVENT_SENT_CONNECT = 0,
  STREAM_EVENT_SENT_RESOLVE = 1,
  STREAM_EVENT_SUCCEEDED = 2,
  STREAM_EVENT_FAILED = 3,
  STREAM_EVENT_CLOSED = 4,
  STREAM_EVENT_NEW = 5,
  STREAM_EVENT_NEW_RESOLVE = 6,
  STREAM_EVENT_FAILED_RETRIABLE = 7,
  STREAM_EVENT_REMAP = 8
} stream_status_event_t;



typedef enum or_conn_status_event_t {
  OR_CONN_EVENT_LAUNCHED = 0,
  OR_CONN_EVENT_CONNECTED = 1,
  OR_CONN_EVENT_FAILED = 2,
  OR_CONN_EVENT_CLOSED = 3,
  OR_CONN_EVENT_NEW = 4,
} or_conn_status_event_t;


typedef enum buildtimeout_set_event_t {
  BUILDTIMEOUT_SET_EVENT_COMPUTED = 0,
  BUILDTIMEOUT_SET_EVENT_RESET = 1,
  BUILDTIMEOUT_SET_EVENT_SUSPENDED = 2,
  BUILDTIMEOUT_SET_EVENT_DISCARD = 3,
  BUILDTIMEOUT_SET_EVENT_RESUME = 4
} buildtimeout_set_event_t;
# 4616 "or.h"
typedef enum {
  BOOTSTRAP_STATUS_UNDEF=-1,
  BOOTSTRAP_STATUS_STARTING=0,
  BOOTSTRAP_STATUS_CONN_DIR=5,
  BOOTSTRAP_STATUS_HANDSHAKE=-2,
  BOOTSTRAP_STATUS_HANDSHAKE_DIR=10,
  BOOTSTRAP_STATUS_ONEHOP_CREATE=15,
  BOOTSTRAP_STATUS_REQUESTING_STATUS=20,
  BOOTSTRAP_STATUS_LOADING_STATUS=25,
  BOOTSTRAP_STATUS_LOADING_KEYS=40,
  BOOTSTRAP_STATUS_REQUESTING_DESCRIPTORS=45,
  BOOTSTRAP_STATUS_LOADING_DESCRIPTORS=50,
  BOOTSTRAP_STATUS_CONN_OR=80,
  BOOTSTRAP_STATUS_HANDSHAKE_OR=85,
  BOOTSTRAP_STATUS_CIRCUIT_CREATE=90,
  BOOTSTRAP_STATUS_DONE=100
} bootstrap_status_t;




typedef struct {
  char first[20];
  char second[20];
} fp_pair_t;





typedef enum {

  NS_V2,

  NS_V3_CONSENSUS,

  NS_V3_VOTE,

  NS_CONTROL_PORT,

  NS_V3_CONSENSUS_MICRODESC
} routerstatus_format_type_t;
# 4671 "or.h"
typedef struct vote_timing_t {


  int vote_interval;

  int n_intervals_valid;

  int vote_delay;

  int dist_delay;
} vote_timing_t;







typedef enum {

  GEOIP_CLIENT_CONNECT = 0,

  GEOIP_CLIENT_NETWORKSTATUS = 1,
} geoip_client_action_t;


typedef enum {

  GEOIP_SUCCESS = 0,


  GEOIP_REJECT_NOT_ENOUGH_SIGS = 1,

  GEOIP_REJECT_UNAVAILABLE = 2,

  GEOIP_REJECT_NOT_FOUND = 3,

  GEOIP_REJECT_NOT_MODIFIED = 4,

  GEOIP_REJECT_BUSY = 5,
} geoip_ns_response_t;




typedef enum {
  DIRREQ_DIRECT = 0,
  DIRREQ_TUNNELED = 1,
} dirreq_type_t;



typedef enum {



  DIRREQ_IS_FOR_NETWORK_STATUS = 0,



  DIRREQ_FLUSHING_DIR_CONN_FINISHED = 1,

  DIRREQ_END_CELL_SENT = 2,


  DIRREQ_CIRC_QUEUE_FLUSHED = 3,



  DIRREQ_CHANNEL_BUFFER_FLUSHED = 4
} dirreq_state_t;





typedef struct microdesc_cache_t microdesc_cache_t;





typedef enum version_status_t {
  VS_RECOMMENDED=0,
  VS_OLD=1,
  VS_NEW=2,
  VS_NEW_IN_SERIES=3,


  VS_UNRECOMMENDED=4,
  VS_EMPTY=5,
  VS_UNKNOWN,
} version_status_t;




typedef enum {

  ADDR_POLICY_ACCEPTED=0,

  ADDR_POLICY_REJECTED=-1,


  ADDR_POLICY_PROBABLY_ACCEPTED=1,


  ADDR_POLICY_PROBABLY_REJECTED=2,
} addr_policy_result_t;





typedef enum {
  SIGN_DIR, SIGN_RTR,
  VERIFY_DIR, VERIFY_RTR,
  ENC_ONIONSKIN, DEC_ONIONSKIN,
  TLS_HANDSHAKE_C, TLS_HANDSHAKE_S,
  REND_CLIENT, REND_MID, REND_SERVER,
} pk_op_t;




typedef struct rend_authorized_client_t {
  char *client_name;
  char descriptor_cookie[16];
  crypto_pk_t *client_key;
} rend_authorized_client_t;


typedef struct rend_encoded_v2_service_descriptor_t {
  char desc_id[20];
  char *desc_str;
} rend_encoded_v2_service_descriptor_t;
# 4836 "or.h"
typedef struct rend_intro_point_t {
  extend_info_t *extend_info;
  crypto_pk_t *intro_key;







  unsigned int timed_out : 1;




  unsigned int unreachable_count : 3;



  unsigned int listed_in_last_desc : 1;




  unsigned int rend_service_note_removing_intro_point_called : 1;




  replaycache_t *accepted_intro_rsa_parts;




  int accepted_introduce2_count;




  time_t time_published;




  time_t time_to_expire;
# 4890 "or.h"
  time_t time_expiring;
} rend_intro_point_t;





typedef struct rend_service_descriptor_t {
  crypto_pk_t *pk;
  int version;
  time_t timestamp;


  unsigned protocols : 16;


  smartlist_t *intro_nodes;

  int all_uploads_performed;




  smartlist_t *successful_uploads;
} rend_service_descriptor_t;


typedef struct rend_cache_entry_t {
  size_t len;
  time_t last_served;

  char *desc;
  rend_service_descriptor_t *parsed;
} rend_cache_entry_t;





typedef struct dir_server_t {
  char *description;
  char *nickname;
  char *address;
  uint32_t addr;
  uint16_t dir_port;
  uint16_t or_port;
  double weight;
  char digest[20];
  char v3_identity_digest[20];


  unsigned int is_running:1;
  unsigned int is_authority:1;




  unsigned int has_accepted_serverdesc:1;


  dirinfo_type_t type;

  time_t addr_current_at;


  routerstatus_t fake_status;




} dir_server_t;
# 5002 "or.h"
typedef enum bandwidth_weight_rule_t {
  NO_WEIGHTING, WEIGHT_FOR_EXIT, WEIGHT_FOR_MID, WEIGHT_FOR_GUARD,
  WEIGHT_FOR_DIR
} bandwidth_weight_rule_t;



typedef enum {
  CRN_NEED_UPTIME = 1<<0,
  CRN_NEED_CAPACITY = 1<<1,
  CRN_NEED_GUARD = 1<<2,
  CRN_ALLOW_INVALID = 1<<3,

  CRN_WEIGHT_AS_EXIT = 1<<5,
  CRN_NEED_DESC = 1<<6
} router_crn_flags_t;


typedef enum was_router_added_t {

  ROUTER_ADDED_SUCCESSFULLY = 1,

  ROUTER_ADDED_NOTIFY_GENERATOR = 0,



  ROUTER_BAD_EI = -1,

  ROUTER_IS_ALREADY_KNOWN = -2,


  ROUTER_NOT_IN_CONSENSUS = -3,



  ROUTER_NOT_IN_CONSENSUS_OR_NETWORKSTATUS = -4,

  ROUTER_AUTHDIR_REJECTS = -5,


  ROUTER_WAS_NOT_WANTED = -6,


  ROUTER_WAS_TOO_OLD = -7,
} was_router_added_t;
# 5056 "or.h"
typedef struct tor_version_t {
  int major;
  int minor;
  int micro;


  enum { VER_PRE=0, VER_RC=1, VER_RELEASE=2, } status;
  int patchlevel;
  char status_tag[32];
  int svn_revision;

  int git_tag_len;
  char git_tag[20];
} tor_version_t;
# 16 "routerlist.c" 2
# 1 "circuitstats.h" 1
# 15 "circuitstats.h"
const circuit_build_times_t *get_circuit_build_times(void);
circuit_build_times_t *get_circuit_build_times_mutable(void);
double get_circuit_build_close_time_ms(void);
double get_circuit_build_timeout_ms(void);

int circuit_build_times_disabled(void);
int circuit_build_times_enough_to_compute(const circuit_build_times_t *cbt);
void circuit_build_times_update_state(const circuit_build_times_t *cbt,
                                      or_state_t *state);
int circuit_build_times_parse_state(circuit_build_times_t *cbt,
                                    or_state_t *state);
void circuit_build_times_count_timeout(circuit_build_times_t *cbt,
                                       int did_onehop);
int circuit_build_times_count_close(circuit_build_times_t *cbt,
                                    int did_onehop, time_t start_time);
void circuit_build_times_set_timeout(circuit_build_times_t *cbt);
int circuit_build_times_add_time(circuit_build_times_t *cbt,
                                 build_time_t time);
int circuit_build_times_needs_circuits(const circuit_build_times_t *cbt);

int circuit_build_times_needs_circuits_now(const circuit_build_times_t *cbt);
void circuit_build_times_init(circuit_build_times_t *cbt);
void circuit_build_times_free_timeouts(circuit_build_times_t *cbt);
void circuit_build_times_new_consensus_params(circuit_build_times_t *cbt,
                                              networkstatus_t *ns);
double circuit_build_times_timeout_rate(const circuit_build_times_t *cbt);
double circuit_build_times_close_rate(const circuit_build_times_t *cbt);

void circuit_build_times_update_last_circ(circuit_build_times_t *cbt);
# 66 "circuitstats.h"
void circuit_build_times_network_is_live(circuit_build_times_t *cbt);
int circuit_build_times_network_check_live(const circuit_build_times_t *cbt);
void circuit_build_times_network_circ_success(circuit_build_times_t *cbt);
# 17 "routerlist.c" 2
# 1 "config.h" 1
# 15 "config.h"
# 1 "../common/testsupport.h" 1
# 16 "config.h" 2

const char *get_dirportfrontpage(void);
const or_options_t * get_options (void);
or_options_t *get_options_mutable(void);
int set_options(or_options_t *new_val, char **msg);
void config_free_all(void);
const char *safe_str_client(const char *address);
const char *safe_str(const char *address);
const char *escaped_safe_str_client(const char *address);
const char *escaped_safe_str(const char *address);
const char *get_version(void);
const char *get_short_version(void);
setopt_err_t options_trial_assign(config_line_t *list, int use_defaults,
                                  int clear_first, char **msg);

uint32_t get_last_resolved_addr(void);
void reset_last_resolved_addr(void);
int resolve_my_address(int warn_severity, const or_options_t *options,
                       uint32_t *addr_out,
                       const char **method_out, char **hostname_out);
int is_local_addr (const tor_addr_t *addr);
void options_init(or_options_t *options);




char *options_dump(const or_options_t *options, int how_to_dump);
int options_init_from_torrc(int argc, char **argv);
setopt_err_t options_init_from_string(const char *cf_defaults, const char *cf,
                            int command, const char *command_arg, char **msg);
int option_is_recognized(const char *key);
const char *option_get_canonical_name(const char *key);
config_line_t *option_get_assignment(const or_options_t *options,
                                     const char *key);
int options_save_current(void);
const char *get_torrc_fname(int defaults_fname);
char *options_get_datadir_fname2_suffix(const or_options_t *options,
                                        const char *sub1, const char *sub2,
                                        const char *suffix);
# 69 "config.h"
int check_or_create_data_subdir(const char *subdir);
int write_to_data_subdir(const char* subdir, const char* fname,
                         const char* str, const char* descr);

int get_num_cpus(const or_options_t *options);

const smartlist_t *get_configured_ports(void);
int get_first_advertised_port_by_type_af(int listener_type,
                                         int address_family);





char *get_first_listener_addrport_string(int listener_type);

int options_need_geoip_info(const or_options_t *options,
                            const char **reason_out);

smartlist_t *get_list_of_ports_to_forward(void);

int getinfo_helper_config(control_connection_t *conn,
                          const char *question, char **answer,
                          const char **errmsg);

const char *tor_get_digests(void);
uint32_t get_effective_bwrate(const or_options_t *options);
uint32_t get_effective_bwburst(const or_options_t *options);

char *get_transport_bindaddr_from_config(const char *transport);

int init_cookie_authentication(const char *fname, const char *header,
                               int cookie_len, int group_readable,
                               uint8_t **cookie_out, int *cookie_is_set_out);

or_options_t *options_new(void);

int config_parse_commandline(int argc, char **argv, int ignore_errors,
                             config_line_t **result,
                             config_line_t **cmdline_result);

void config_register_addressmaps(const or_options_t *options);

int addressmap_register_auto(const char *from, const char *to,
                             time_t expires,
                             addressmap_entry_source_t addrmap_source,
                             const char **msg);
int config_parse_unix_port(const char *addrport, char **path_out);


typedef struct bridge_line_t {
  tor_addr_t addr;
  uint16_t port;
  char *transport_name;

  char digest[20];
  smartlist_t *socks_args;

} bridge_line_t;

void bridge_line_free(bridge_line_t *bridge_line);
bridge_line_t *parse_bridge_line(const char *line);
smartlist_t *get_options_from_transport_options_line(const char *line,
                                                     const char *transport);
smartlist_t *get_options_for_server_transport(const char *transport);
# 18 "routerlist.c" 2
# 1 "connection.h" 1
# 16 "connection.h"
# 1 "buffers.h" 1
# 17 "buffers.h"
buf_t *buf_new(void);
buf_t *buf_new_with_capacity(size_t size);
size_t buf_get_default_chunk_size(const buf_t *buf);
void buf_free(buf_t *buf);
void buf_clear(buf_t *buf);
buf_t *buf_copy(const buf_t *buf);

size_t buf_datalen (const buf_t *buf);
size_t buf_allocation(const buf_t *buf);
size_t buf_slack(const buf_t *buf);

uint32_t buf_get_oldest_chunk_timestamp(const buf_t *buf, uint32_t now);
size_t buf_get_total_allocation(void);

int read_to_buf(int s, size_t at_most, buf_t *buf, int *reached_eof,
                int *socket_error);
int read_to_buf_tls(tor_tls_t *tls, size_t at_most, buf_t *buf);

int flush_buf(int s, buf_t *buf, size_t sz, size_t *buf_flushlen);
int flush_buf_tls(tor_tls_t *tls, buf_t *buf, size_t sz, size_t *buf_flushlen);

int write_to_buf(const char *string, size_t string_len, buf_t *buf);
int write_to_buf_zlib(buf_t *buf, tor_zlib_state_t *state,
                      const char *data, size_t data_len, int done);
int move_buf_to_buf(buf_t *buf_out, buf_t *buf_in, size_t *buf_flushlen);
int fetch_from_buf(char *string, size_t string_len, buf_t *buf);
int fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto);
int fetch_from_buf_http(buf_t *buf,
                        char **headers_out, size_t max_headerlen,
                        char **body_out, size_t *body_used, size_t max_bodylen,
                        int force_complete);
socks_request_t *socks_request_new(void);
void socks_request_free(socks_request_t *req);
int fetch_from_buf_socks(buf_t *buf, socks_request_t *req,
                         int log_sockstype, int safe_socks);
int fetch_from_buf_socks_client(buf_t *buf, int state, char **reason);
int fetch_from_buf_line(buf_t *buf, char *data_out, size_t *data_len);

int peek_buf_has_control0_command(buf_t *buf);

int fetch_ext_or_command_from_buf(buf_t *buf, ext_or_cmd_t **out);
# 97 "buffers.h"
int generic_buffer_set_to_copy(buf_t **output,
                               const buf_t *input);

void assert_buf_ok(buf_t *buf);
# 17 "connection.h" 2

const char *conn_type_to_string(int type);
const char *conn_state_to_string(int type, int state);
int conn_listener_type_supports_af_unix(int type);

dir_connection_t *dir_connection_new(int socket_family);
or_connection_t *or_connection_new(int type, int socket_family);
edge_connection_t *edge_connection_new(int type, int socket_family);
entry_connection_t *entry_connection_new(int type, int socket_family);
control_connection_t *control_connection_new(int socket_family);
listener_connection_t *listener_connection_new(int type, int socket_family);
connection_t *connection_new(int type, int socket_family);

void connection_link_connections(connection_t *conn_a, connection_t *conn_b);
void connection_free(connection_t *conn);
void connection_free_all(void);
void connection_about_to_close_connection(connection_t *conn);
void connection_close_immediate(connection_t *conn);
void connection_mark_for_close_(connection_t *conn,
                                int line, const char *file);
void connection_mark_for_close_internal_(connection_t *conn,
                                         int line, const char *file);
# 87 "connection.h"
void connection_expire_held_open(void);

int connection_connect(connection_t *conn, const char *address,
                       const tor_addr_t *addr,
                       uint16_t port, int *socket_error);
# 108 "connection.h"
int connection_proxy_connect(connection_t *conn, int type);
int connection_read_proxy_handshake(connection_t *conn);
void log_failed_proxy_connection(connection_t *conn);
int get_proxy_addrport(tor_addr_t *addr, uint16_t *port, int *proxy_type,
                       const connection_t *conn);

int retry_all_listeners(smartlist_t *replaced_conns,
                        smartlist_t *new_conns,
                        int close_all_noncontrol);

void connection_mark_all_noncontrol_listeners(void);
void connection_mark_all_noncontrol_connections(void);

ssize_t connection_bucket_write_limit(connection_t *conn, time_t now);
int global_write_bucket_low(connection_t *conn, size_t attempt, int priority);
void connection_bucket_init(void);
void connection_bucket_refill(int seconds_elapsed, time_t now);

int connection_handle_read(connection_t *conn);

int connection_fetch_from_buf(char *string, size_t len, connection_t *conn);
int connection_fetch_from_buf_line(connection_t *conn, char *data,
                                   size_t *data_len);
int connection_fetch_from_buf_http(connection_t *conn,
                               char **headers_out, size_t max_headerlen,
                               char **body_out, size_t *body_used,
                               size_t max_bodylen, int force_complete);

int connection_wants_to_flush(connection_t *conn);
int connection_outbuf_too_full(connection_t *conn);
int connection_handle_write(connection_t *conn, int force);
int connection_flush(connection_t *conn);

void connection_write_to_buf_impl_ (const char *string, size_t len, connection_t *conn, int zlib)
                                                                         ;

static void connection_write_to_buf(const char *string, size_t len,
                                    connection_t *conn);

static void connection_write_to_buf_zlib(const char *string, size_t len,
                                         dir_connection_t *conn, int done);
static inline void
connection_write_to_buf(const char *string, size_t len, connection_t *conn)
{
  connection_write_to_buf_impl_(string, len, conn, 0);
}
static inline void
connection_write_to_buf_zlib(const char *string, size_t len,
                             dir_connection_t *conn, int done)
{
  connection_write_to_buf_impl_(string, len, (&(((conn)->base_))), done ? -1 : 1);
}


static size_t connection_get_inbuf_len(connection_t *conn);

static size_t connection_get_outbuf_len(connection_t *conn);

static inline size_t
connection_get_inbuf_len(connection_t *conn)
{
  (void)0

     ; {
    return conn->inbuf ? buf_datalen(conn->inbuf) : 0;
  }
}

static inline size_t
connection_get_outbuf_len(connection_t *conn)
{
  (void)0

     ; {
    return conn->outbuf ? buf_datalen(conn->outbuf) : 0;
  }
}

connection_t *connection_get_by_global_id(uint64_t id);

connection_t *connection_get_by_type(int type);
connection_t *connection_get_by_type_addr_port_purpose(int type,
                                                   const tor_addr_t *addr,
                                                   uint16_t port, int purpose);
connection_t *connection_get_by_type_state(int type, int state);
connection_t *connection_get_by_type_state_rendquery(int type, int state,
                                                     const char *rendquery);
dir_connection_t *connection_dir_get_by_purpose_and_resource(
                                           int state, const char *resource);

int any_other_active_or_conns(const or_connection_t *this_conn);



int connection_is_listener(connection_t *conn);
int connection_state_is_open(connection_t *conn);
int connection_state_is_connecting(connection_t *conn);

char *alloc_http_authenticator(const char *authenticator);

void assert_connection_ok(connection_t *conn, time_t now);
int connection_or_nonopen_was_started_here(or_connection_t *conn);
void connection_dump_buffer_mem_stats(int severity);
void remove_file_if_very_old(const char *fname, time_t now);
# 19 "routerlist.c" 2
# 1 "control.h" 1
# 15 "control.h"
void control_update_global_event_mask(void);
void control_adjust_event_log_severity(void);

void control_ports_write_to_file(void);
# 28 "control.h"
int connection_control_finished_flushing(control_connection_t *conn);
int connection_control_reached_eof(control_connection_t *conn);
void connection_control_closed(control_connection_t *conn);

int connection_control_process_inbuf(control_connection_t *conn);



int control_event_is_interesting(int event);

int control_event_circuit_status(origin_circuit_t *circ,
                                 circuit_status_event_t e, int reason);
int control_event_circuit_purpose_changed(origin_circuit_t *circ,
                                          int old_purpose);
int control_event_circuit_cannibalized(origin_circuit_t *circ,
                                       int old_purpose,
                                       const struct timeval *old_tv_created);
int control_event_stream_status(entry_connection_t *conn,
                                stream_status_event_t e,
                                int reason);
int control_event_or_conn_status(or_connection_t *conn,
                                 or_conn_status_event_t e, int reason);
int control_event_bandwidth_used(uint32_t n_read, uint32_t n_written);
int control_event_stream_bandwidth(edge_connection_t *edge_conn);
int control_event_stream_bandwidth_used(void);
int control_event_circ_bandwidth_used(void);
int control_event_conn_bandwidth(connection_t *conn);
int control_event_conn_bandwidth_used(void);
int control_event_circuit_cell_stats(void);
int control_event_tb_empty(const char *bucket, uint32_t read_empty_time,
                           uint32_t write_empty_time,
                           int milliseconds_elapsed);
void control_event_logmsg(int severity, uint32_t domain, const char *msg);
int control_event_descriptors_changed(smartlist_t *routers);
int control_event_address_mapped(const char *from, const char *to,
                                 time_t expires, const char *error,
                                 const int cached);
int control_event_or_authdir_new_descriptor(const char *action,
                                            const char *desc,
                                            size_t desclen,
                                            const char *msg);
int control_event_my_descriptor_changed(void);
int control_event_networkstatus_changed(smartlist_t *statuses);

int control_event_newconsensus(const networkstatus_t *consensus);
int control_event_networkstatus_changed_single(const routerstatus_t *rs);
int control_event_general_status(int severity, const char *format, ...)
  __attribute__ ((format(printf, 2, 3)));
int control_event_client_status(int severity, const char *format, ...)
  __attribute__ ((format(printf, 2, 3)));
int control_event_server_status(int severity, const char *format, ...)
  __attribute__ ((format(printf, 2, 3)));
int control_event_guard(const char *nickname, const char *digest,
                        const char *status);
int control_event_conf_changed(const smartlist_t *elements);
int control_event_buildtimeout_set(buildtimeout_set_event_t type,
                                   const char *args);
int control_event_signal(uintptr_t signal);

int init_control_cookie_authentication(int enabled);
char *get_controller_cookie_file_name(void);
smartlist_t *decode_hashed_passwords(config_line_t *passwords);
void disable_control_logging(void);
void enable_control_logging(void);

void monitor_owning_controller_process(const char *process_spec);

int control_event_bootstrap(bootstrap_status_t status, int progress);
void control_event_bootstrap_problem (const char *warn, int reason, or_connection_t *or_conn)

                                                                           ;

void control_event_clients_seen(const char *controller_str);
void control_event_transport_launched(const char *mode,
                                      const char *transport_name,
                                      tor_addr_t *addr, uint16_t port);
const char *rend_auth_type_to_string(rend_auth_type_t auth_type);
const char * node_describe_longname_by_id (const char *id_digest);
void control_event_hs_descriptor_requested(const rend_data_t *rend_query,
                                           const char *desc_id_base32,
                                           const char *hs_dir);
void control_event_hs_descriptor_receive_end(const char *action,
                                        const rend_data_t *rend_query,
                                        const char *hs_dir,
                                        const char *reason);
void control_event_hs_descriptor_received(const rend_data_t *rend_query,
                                          const char *hs_dir);
void control_event_hs_descriptor_failed(const rend_data_t *rend_query,
                                        const char *hs_dir,
                                        const char *reason);

void control_free_all(void);
# 20 "routerlist.c" 2
# 1 "directory.h" 1
# 15 "directory.h"
int directories_have_accepted_server_descriptor(void);
void directory_post_to_dirservers(uint8_t dir_purpose, uint8_t router_purpose,
                                  dirinfo_type_t type, const char *payload,
                                  size_t payload_len, size_t extrainfo_len);
void directory_get_from_dirserver (uint8_t dir_purpose, uint8_t router_purpose, const char *resource, int pds_flags)


                                                              ;
void directory_get_from_all_authorities(uint8_t dir_purpose,
                                        uint8_t router_purpose,
                                        const char *resource);


typedef enum {


  DIRIND_ONEHOP=0,

  DIRIND_ANONYMOUS=1,

  DIRIND_DIRECT_CONN,

  DIRIND_ANON_DIRPORT,
} dir_indirection_t;

void directory_initiate_command_routerstatus(const routerstatus_t *status,
                                             uint8_t dir_purpose,
                                             uint8_t router_purpose,
                                             dir_indirection_t indirection,
                                             const char *resource,
                                             const char *payload,
                                             size_t payload_len,
                                             time_t if_modified_since);
void directory_initiate_command_routerstatus_rend(const routerstatus_t *status,
                                                  uint8_t dir_purpose,
                                                  uint8_t router_purpose,
                                                 dir_indirection_t indirection,
                                                  const char *resource,
                                                  const char *payload,
                                                  size_t payload_len,
                                                  time_t if_modified_since,
                                                const rend_data_t *rend_query);

int parse_http_response(const char *headers, int *code, time_t *date,
                        compress_method_t *compression, char **response);

int connection_dir_is_encrypted(dir_connection_t *conn);
int connection_dir_reached_eof(dir_connection_t *conn);
int connection_dir_process_inbuf(dir_connection_t *conn);
int connection_dir_finished_flushing(dir_connection_t *conn);
int connection_dir_finished_connecting(dir_connection_t *conn);
void connection_dir_about_to_close(dir_connection_t *dir_conn);
void directory_initiate_command(const tor_addr_t *addr,
                                uint16_t or_port, uint16_t dir_port,
                                const char *digest,
                                uint8_t dir_purpose, uint8_t router_purpose,
                                dir_indirection_t indirection,
                                const char *resource,
                                const char *payload, size_t payload_len,
                                time_t if_modified_since);





int dir_split_resource_into_fingerprints(const char *resource,
                                     smartlist_t *fp_out, int *compressed_out,
                                     int flags);

int dir_split_resource_into_fingerprint_pairs(const char *res,
                                              smartlist_t *pairs_out);
char *directory_dump_request_log(void);
void note_request(const char *key, size_t bytes);
int router_supports_extrainfo(const char *identity_digest, int is_authority);

time_t download_status_increment_failure(download_status_t *dls,
                                         int status_code, const char *item,
                                         int server, time_t now);






void download_status_reset(download_status_t *dls);
static int download_status_is_ready(download_status_t *dls, time_t now,
                                    int max_failures);


static inline int
download_status_is_ready(download_status_t *dls, time_t now,
                         int max_failures)
{
  return (dls->n_download_failures <= max_failures
          && dls->next_attempt_at <= now);
}

static void download_status_mark_impossible(download_status_t *dl);

static inline void
download_status_mark_impossible(download_status_t *dl)
{
  dl->n_download_failures = 255;
}

int download_status_get_n_failures(const download_status_t *dls);
# 21 "routerlist.c" 2
# 1 "dirserv.h" 1
# 35 "dirserv.h"
int connection_dirserv_flushed_some(dir_connection_t *conn);

int dirserv_add_own_fingerprint(crypto_pk_t *pk);
int dirserv_load_fingerprint_file(void);
void dirserv_free_fingerprint_list(void);
enum was_router_added_t dirserv_add_multiple_descriptors(
                                     const char *desc, uint8_t purpose,
                                     const char *source,
                                     const char **msg);
enum was_router_added_t dirserv_add_descriptor(routerinfo_t *ri,
                                               const char **msg,
                                               const char *source);
void dirserv_set_router_is_running(routerinfo_t *router, time_t now);
int list_server_status_v1(smartlist_t *routers, char **router_status_out,
                          int for_controller);
int dirserv_dump_directory_to_string(char **dir_out,
                                     crypto_pk_t *private_key);
char *dirserv_get_flag_thresholds_line(void);
void dirserv_compute_bridge_flag_thresholds(routerlist_t *rl);

int directory_fetches_from_authorities(const or_options_t *options);
int directory_fetches_dir_info_early(const or_options_t *options);
int directory_fetches_dir_info_later(const or_options_t *options);
int directory_caches_unknown_auth_certs(const or_options_t *options);
int directory_caches_dir_info(const or_options_t *options);
int directory_permits_begindir_requests(const or_options_t *options);
int directory_too_idle_to_fetch_descriptors(const or_options_t *options,
                                            time_t now);

cached_dir_t *dirserv_get_consensus(const char *flavor_name);
void dirserv_set_cached_consensus_networkstatus(const char *consensus,
                                                const char *flavor_name,
                                                const digests_t *digests,
                                                time_t published);
void dirserv_clear_old_networkstatuses(time_t cutoff);
int dirserv_get_routerdesc_fingerprints(smartlist_t *fps_out, const char *key,
                                        const char **msg,
                                        int for_unencrypted_conn,
                                        int is_extrainfo);
int dirserv_get_routerdescs(smartlist_t *descs_out, const char *key,
                            const char **msg);
void dirserv_orconn_tls_done(const tor_addr_t *addr,
                             uint16_t or_port,
                             const char *digest_rcvd);
int dirserv_should_launch_reachability_test(const routerinfo_t *ri,
                                            const routerinfo_t *ri_old);
void dirserv_single_reachability_test(time_t now, routerinfo_t *router);
void dirserv_test_reachability(time_t now);
int authdir_wants_to_reject_router(routerinfo_t *ri, const char **msg,
                                   int complain,
                                   int *valid_out);
uint32_t dirserv_router_get_status(const routerinfo_t *router,
                                   const char **msg);
void dirserv_set_node_flags_from_authoritative_status(node_t *node,
                                                      uint32_t authstatus);

int dirserv_would_reject_router(const routerstatus_t *rs);
int dirserv_remove_old_statuses(smartlist_t *fps, time_t cutoff);
int dirserv_have_any_serverdesc(smartlist_t *fps, int spool_src);
int dirserv_have_any_microdesc(const smartlist_t *fps);
size_t dirserv_estimate_data_size(smartlist_t *fps, int is_serverdescs,
                                  int compressed);
size_t dirserv_estimate_microdesc_size(const smartlist_t *fps, int compressed);

char *routerstatus_format_entry(
                              const routerstatus_t *rs, const char *platform,
                              routerstatus_format_type_t format,
                              const vote_routerstatus_t *vrs);
void dirserv_free_all(void);
void cached_dir_decref(cached_dir_t *d);
cached_dir_t *new_cached_dir(char *s, time_t published);

int validate_recommended_package_line(const char *line);
# 134 "dirserv.h"
int dirserv_read_measured_bandwidths(const char *from_file,
                                     smartlist_t *routerstatuses);

int dirserv_read_guardfraction_file(const char *fname,
                                 smartlist_t *vote_routerstatuses);
# 22 "routerlist.c" 2
# 1 "dirvote.h" 1
# 94 "dirvote.h"
void dirvote_free_all(void);


char *networkstatus_compute_consensus(smartlist_t *votes,
                                      int total_authorities,
                                      crypto_pk_t *identity_key,
                                      crypto_pk_t *signing_key,
                                      const char *legacy_identity_key_digest,
                                      crypto_pk_t *legacy_signing_key,
                                      consensus_flavor_t flavor);
int networkstatus_add_detached_signatures(networkstatus_t *target,
                                          ns_detached_signatures_t *sigs,
                                          const char *source,
                                          int severity,
                                          const char **msg_out);
char *networkstatus_get_detached_signatures(smartlist_t *consensuses);
void ns_detached_signatures_free(ns_detached_signatures_t *s);


authority_cert_t *authority_cert_dup(authority_cert_t *cert);


void dirvote_get_preferred_voting_intervals(vote_timing_t *timing_out);
time_t dirvote_get_start_of_next_interval(time_t now,
                                          int interval,
                                          int offset);
void dirvote_recalculate_timing(const or_options_t *options, time_t now);
void dirvote_act(const or_options_t *options, time_t now);


struct pending_vote_t * dirvote_add_vote(const char *vote_body,
                                         const char **msg_out,
                                         int *status_out);
int dirvote_add_signatures(const char *detached_signatures_body,
                           const char *source,
                           const char **msg_out);


const char *dirvote_get_pending_consensus(consensus_flavor_t flav);
const char *dirvote_get_pending_detached_signatures(void);



const cached_dir_t *dirvote_get_vote(const char *fp, int flags);
void set_routerstatus_from_routerinfo(routerstatus_t *rs,
                                      node_t *node,
                                      routerinfo_t *ri, time_t now,
                                      int listbadexits,
                                      int vote_on_hsdirs);
networkstatus_t *
dirserv_generate_networkstatus_vote_obj(crypto_pk_t *private_key,
                                        authority_cert_t *cert);

microdesc_t *dirvote_create_microdescriptor(const routerinfo_t *ri,
                                            int consensus_method);
ssize_t dirvote_format_microdesc_vote_line(char *out, size_t out_len,
                                           const microdesc_t *md,
                                           int consensus_method_low,
                                           int consensus_method_high);
vote_microdesc_hash_t *dirvote_format_all_microdesc_vote_lines(
                                        const routerinfo_t *ri,
                                        time_t now,
                                        smartlist_t *microdescriptors_out);

int vote_routerstatus_find_microdesc_hash(char *digest256_out,
                                          const vote_routerstatus_t *vrs,
                                          int method,
                                          digest_algorithm_t alg);
document_signature_t *voter_get_sig_by_algorithm(
                           const networkstatus_voter_info_t *voter,
                           digest_algorithm_t alg);
# 23 "routerlist.c" 2
# 1 "entrynodes.h" 1
# 23 "entrynodes.h"
typedef struct entry_guard_t {
  char nickname[19 +1];
  char identity[20];
  time_t chosen_on_date;

  char *chosen_by_version;

  unsigned int made_contact : 1;

  unsigned int can_retry : 1;

  unsigned int path_bias_noticed : 1;

  unsigned int path_bias_warned : 1;

  unsigned int path_bias_extreme : 1;

  unsigned int path_bias_disabled : 1;

  unsigned int path_bias_use_noticed : 1;

  unsigned int path_bias_use_extreme : 1;

  unsigned int is_dir_cache : 1;
  time_t bad_since;


  time_t unreachable_since;


  time_t last_attempted;


  double circ_attempts;
  double circ_successes;

  double successful_circuits_closed;

  double collapsed_circuits;


  double unusable_circuits;

  double timeouts;

  double use_attempts;
  double use_successes;

} entry_guard_t;

entry_guard_t *entry_guard_get_by_id_digest(const char *digest);
void entry_guards_changed(void);
const smartlist_t *get_entry_guards(void);
int num_live_entry_guards(int for_directory);
# 112 "entrynodes.h"
void remove_all_entry_guards(void);

void entry_guards_compute_status(const or_options_t *options, time_t now);
int entry_guard_register_connect_status(const char *digest, int succeeded,
                                        int mark_relay_status, time_t now);
void entry_nodes_should_be_added(void);
int entry_list_is_constrained(const or_options_t *options);
const node_t *choose_random_entry(cpath_build_state_t *state);
const node_t *choose_random_dirguard(dirinfo_type_t t);
int entry_guards_parse_state(or_state_t *state, int set, char **msg);
void entry_guards_update_state(or_state_t *state);
int getinfo_helper_entry_guards(control_connection_t *conn,
                                const char *question, char **answer,
                                const char **errmsg);

void mark_bridge_list(void);
void sweep_bridge_list(void);

int routerinfo_is_a_configured_bridge(const routerinfo_t *ri);
int node_is_a_configured_bridge(const node_t *node);
void learned_router_identity(const tor_addr_t *addr, uint16_t port,
                             const char *digest);
struct bridge_line_t;
void bridge_add_from_config(struct bridge_line_t *bridge_line);
void retry_bridge_descriptor_fetch_directly(const char *digest);
void fetch_bridge_descriptors(const or_options_t *options, time_t now);
void learned_bridge_descriptor(routerinfo_t *ri, int from_cache);
int any_bridge_descriptors_known(void);
int entries_known_but_down(const or_options_t *options);
void entries_retry_all(const or_options_t *options);

int any_bridge_supports_microdescriptors(void);
const smartlist_t *get_socks_args_by_bridge_addrport(const tor_addr_t *addr,
                                                     uint16_t port);

int any_bridges_dont_support_microdescriptors(void);

void entry_guards_free_all(void);

const char *find_transport_name_by_bridge_addrport(const tor_addr_t *addr,
                                                   uint16_t port);
struct transport_t;
int get_transport_by_bridge_addrport(const tor_addr_t *addr, uint16_t port,
                                      const struct transport_t **transport);

int transport_is_needed (const char *transport_name);
int validate_pluggable_transports_config(void);

double pathbias_get_close_success_count(entry_guard_t *guard);
double pathbias_get_use_success_count(entry_guard_t *guard);



typedef struct guardfraction_bandwidth_t {

  int guard_bw;

  int non_guard_bw;
} guardfraction_bandwidth_t;

int should_apply_guardfraction(const networkstatus_t *ns);

void
guard_get_guardfraction_bandwidth(guardfraction_bandwidth_t *guardfraction_bw,
                                  int orig_bandwidth,
                                  uint32_t guardfraction_percentage);
# 24 "routerlist.c" 2
# 1 "fp_pair.h" 1
# 16 "fp_pair.h"
typedef struct fp_pair_map_entry_s fp_pair_map_entry_t;
typedef struct fp_pair_map_s fp_pair_map_t;
typedef fp_pair_map_entry_t *fp_pair_map_iter_t;

fp_pair_map_t * fp_pair_map_new(void);
void * fp_pair_map_set(fp_pair_map_t *map, const fp_pair_t *key, void *val);
void * fp_pair_map_set_by_digests(fp_pair_map_t *map,
                                  const char *first, const char *second,
                                  void *val);
void * fp_pair_map_get(const fp_pair_map_t *map, const fp_pair_t *key);
void * fp_pair_map_get_by_digests(const fp_pair_map_t *map,
                                  const char *first, const char *second);
void * fp_pair_map_remove(fp_pair_map_t *map, const fp_pair_t *key);
void fp_pair_map_free(fp_pair_map_t *map, void (*free_val)(void*));
int fp_pair_map_isempty(const fp_pair_map_t *map);
int fp_pair_map_size(const fp_pair_map_t *map);
fp_pair_map_iter_t * fp_pair_map_iter_init(fp_pair_map_t *map);
fp_pair_map_iter_t * fp_pair_map_iter_next(fp_pair_map_t *map,
                                           fp_pair_map_iter_t *iter);
fp_pair_map_iter_t * fp_pair_map_iter_next_rmv(fp_pair_map_t *map,
                                               fp_pair_map_iter_t *iter);
void fp_pair_map_iter_get(fp_pair_map_iter_t *iter,
                          fp_pair_t *key_out, void **val_out);
int fp_pair_map_iter_done(fp_pair_map_iter_t *iter);
void fp_pair_map_assert_ok(const fp_pair_map_t *map);
# 25 "routerlist.c" 2
# 1 "geoip.h" 1
# 22 "geoip.h"
int should_record_bridge_info(const or_options_t *options);
int geoip_load_file(sa_family_t family, const char *filename);
int geoip_get_country_by_addr (const tor_addr_t *addr);
int geoip_get_n_countries (void);
const char *geoip_get_country_name(country_t num);
int geoip_is_loaded (sa_family_t family);
const char *geoip_db_digest(sa_family_t family);
country_t geoip_get_country (const char *countrycode);

void geoip_note_client_seen(geoip_client_action_t action,
                            const tor_addr_t *addr, const char *transport_name,
                            time_t now);
void geoip_remove_old_clients(time_t cutoff);

void geoip_note_ns_response(geoip_ns_response_t response);
char *geoip_get_transport_history(void);
int geoip_get_client_history(geoip_client_action_t action,
                             char **country_str, char **ipver_str);
char *geoip_get_request_history(void);
int getinfo_helper_geoip(control_connection_t *control_conn,
                         const char *question, char **answer,
                         const char **errmsg);
void geoip_free_all(void);

void geoip_start_dirreq(uint64_t dirreq_id, size_t response_size,
                        dirreq_type_t type);
void geoip_change_dirreq_state(uint64_t dirreq_id, dirreq_type_t type,
                               dirreq_state_t new_state);

void geoip_dirreq_stats_init(time_t now);
void geoip_reset_dirreq_stats(time_t now);
char *geoip_format_dirreq_stats(time_t now);
time_t geoip_dirreq_stats_write(time_t now);
void geoip_dirreq_stats_term(void);
void geoip_entry_stats_init(time_t now);
time_t geoip_entry_stats_write(time_t now);
void geoip_entry_stats_term(void);
void geoip_reset_entry_stats(time_t now);
char *geoip_format_entry_stats(time_t now);
void geoip_bridge_stats_init(time_t now);
char *geoip_format_bridge_stats(time_t now);
time_t geoip_bridge_stats_write(time_t now);
void geoip_bridge_stats_term(void);
const char *geoip_get_bridge_stats_extrainfo(time_t);
char *geoip_get_bridge_stats_controller(time_t);
char *format_client_stats_heartbeat(time_t now);
# 26 "routerlist.c" 2
# 1 "hibernate.h" 1
# 17 "hibernate.h"
int accounting_parse_options(const or_options_t *options, int validate_only);
int accounting_is_enabled (const or_options_t *options);
int accounting_get_interval_length(void);
time_t accounting_get_end_time (void);
void configure_accounting(time_t now);
void accounting_run_housekeeping(time_t now);
void accounting_add_bytes(size_t n_read, size_t n_written, int seconds);
int accounting_record_bandwidth_usage(time_t now, or_state_t *state);
void hibernate_begin_shutdown(void);
int we_are_hibernating (void);
void consider_hibernation(time_t now);
int getinfo_helper_accounting(control_connection_t *conn,
                              const char *question, char **answer,
                              const char **errmsg);
uint64_t get_accounting_max_total(void);
# 27 "routerlist.c" 2
# 1 "main.h" 1
# 15 "main.h"
int have_completed_a_circuit(void);
void note_that_we_completed_a_circuit(void);
void note_that_we_maybe_cant_complete_circuits(void);

int connection_add_impl(connection_t *conn, int is_connecting);


int connection_remove(connection_t *conn);
void connection_unregister_events(connection_t *conn);
int connection_in_array(connection_t *conn);
void add_connection_to_closeable_list(connection_t *conn);
int connection_is_on_closeable_list(connection_t *conn);

smartlist_t *get_connection_array(void);
uint64_t get_bytes_read (void);
uint64_t get_bytes_written (void);



typedef enum watchable_events {

  READ_EVENT=0x02,
  WRITE_EVENT=0x04
} watchable_events_t;
void connection_watch_events(connection_t *conn, watchable_events_t events);
int connection_is_reading(connection_t *conn);
void connection_stop_reading (connection_t *conn);
void connection_start_reading (connection_t *conn);

int connection_is_writing(connection_t *conn);
void connection_stop_writing (connection_t *conn);
void connection_start_writing (connection_t *conn);

void connection_stop_reading_from_linked_conn(connection_t *conn);

void directory_all_unreachable(time_t now);
void directory_info_has_arrived(time_t now, int from_cache);

void ip_address_changed(int at_interface);
void dns_servers_relaunch_checks(void);
void reschedule_descriptor_update_check(void);

long get_uptime (void);

unsigned get_signewnym_epoch(void);

void handle_signals(int is_parent);
void process_signal(uintptr_t sig);

int try_locking(const or_options_t *options, int err_if_locked);
int have_lockfile(void);
void release_lockfile(void);

void tor_cleanup(void);
void tor_free_all(int postfork);

int tor_main(int argc, char *argv[]);

int do_main_loop(void);
int tor_init(int argc, char **argv);
# 28 "routerlist.c" 2
# 1 "microdesc.h" 1
# 15 "microdesc.h"
microdesc_cache_t *get_microdesc_cache(void);

void microdesc_check_counts(void);

smartlist_t *microdescs_add_to_cache(microdesc_cache_t *cache,
                        const char *s, const char *eos, saved_location_t where,
                        int no_save, time_t listed_at,
                        smartlist_t *requested_digests256);
smartlist_t *microdescs_add_list_to_cache(microdesc_cache_t *cache,
                        smartlist_t *descriptors, saved_location_t where,
                        int no_save);

void microdesc_cache_clean(microdesc_cache_t *cache, time_t cutoff, int force);
int microdesc_cache_rebuild(microdesc_cache_t *cache, int force);
int microdesc_cache_reload(microdesc_cache_t *cache);
void microdesc_cache_clear(microdesc_cache_t *cache);

microdesc_t *microdesc_cache_lookup_by_digest256(microdesc_cache_t *cache,
                                                 const char *d);

size_t microdesc_average_size(microdesc_cache_t *cache);

smartlist_t *microdesc_list_missing_digest256(networkstatus_t *ns,
                                              microdesc_cache_t *cache,
                                              int downloadable_only,
                                              digest256map_t *skip);

void microdesc_free_(microdesc_t *md, const char *fname, int line);


void microdesc_free_all(void);

void update_microdesc_downloads(time_t now);
void update_microdescs_from_networkstatus(time_t now);

int usable_consensus_flavor(void);
int we_fetch_microdescriptors(const or_options_t *options);
int we_fetch_router_descriptors(const or_options_t *options);
int we_use_microdescriptors_for_circuits(const or_options_t *options);
# 29 "routerlist.c" 2
# 1 "networkstatus.h" 1
# 17 "networkstatus.h"
void networkstatus_reset_warnings(void);
void networkstatus_reset_download_failures(void);
int router_reload_consensus_networkstatus(void);
void routerstatus_free(routerstatus_t *rs);
void networkstatus_vote_free(networkstatus_t *ns);
networkstatus_voter_info_t *networkstatus_get_voter_by_id(
                                       networkstatus_t *vote,
                                       const char *identity);
int networkstatus_check_consensus_signature(networkstatus_t *consensus,
                                            int warn);
int networkstatus_check_document_signature(const networkstatus_t *consensus,
                                           document_signature_t *sig,
                                           const authority_cert_t *cert);
int compare_digest_to_routerstatus_entry(const void *_key,
                                         const void **_member);
int compare_digest_to_vote_routerstatus_entry(const void *_key,
                                              const void **_member);
const routerstatus_t *networkstatus_vote_find_entry(networkstatus_t *ns,
                                              const char *digest);
routerstatus_t *networkstatus_vote_find_mutable_entry(networkstatus_t *ns,
                                              const char *digest);
int networkstatus_vote_find_entry_idx(networkstatus_t *ns,
                                      const char *digest, int *found_out);

download_status_t * router_get_dl_status_by_descriptor_digest (const char *d)
                          ;

const routerstatus_t *router_get_consensus_status_by_id(const char *digest);
routerstatus_t *router_get_mutable_consensus_status_by_id(
                                   const char *digest);
const routerstatus_t *router_get_consensus_status_by_descriptor_digest(
                                   networkstatus_t *consensus,
                                   const char *digest);
routerstatus_t * router_get_mutable_consensus_status_by_descriptor_digest (networkstatus_t *consensus, const char *digest)

                                                           ;
const routerstatus_t *router_get_consensus_status_by_nickname(
                                   const char *nickname,
                                   int warn_if_unnamed);
const char *networkstatus_get_router_digest_by_nickname(const char *nickname);
int networkstatus_nickname_is_unnamed(const char *nickname);
void networkstatus_consensus_download_failed(int status_code,
                                             const char *flavname);
void update_consensus_networkstatus_fetch_time(time_t now);
int should_delay_dir_fetches(const or_options_t *options,const char **msg_out);
void update_networkstatus_downloads(time_t now);
void update_certificate_downloads(time_t now);
int consensus_is_waiting_for_certs(void);
int client_would_use_router(const routerstatus_t *rs, time_t now,
                            const or_options_t *options);
networkstatus_t *networkstatus_get_latest_consensus(void);
networkstatus_t * networkstatus_get_latest_consensus_by_flavor (consensus_flavor_t f)
                                 ;
networkstatus_t *networkstatus_get_live_consensus(time_t now);
networkstatus_t *networkstatus_get_reasonably_live_consensus(time_t now,
                                                             int flavor);





int networkstatus_set_current_consensus(const char *consensus,
                                        const char *flavor,
                                        unsigned flags);
void networkstatus_note_certs_arrived(void);
void routers_update_all_from_networkstatus(time_t now, int dir_version);
void routers_update_status_from_consensus_networkstatus(smartlist_t *routers,
                                                        int reset_failures);
void signed_descs_update_status_from_consensus_networkstatus(
                                                         smartlist_t *descs);

char *networkstatus_getinfo_helper_single(const routerstatus_t *rs);
char *networkstatus_getinfo_by_purpose(const char *purpose_string, time_t now);
void networkstatus_dump_bridge_status_to_file(time_t now);
int32_t networkstatus_get_param(const networkstatus_t *ns,
                                const char *param_name,
                                int32_t default_val, int32_t min_val,
                                int32_t max_val);
int getinfo_helper_networkstatus(control_connection_t *conn,
                                 const char *question, char **answer,
                                 const char **errmsg);
int32_t networkstatus_get_bw_weight(networkstatus_t *ns, const char *weight,
                                    int32_t default_val);
const char *networkstatus_get_flavor_name(consensus_flavor_t flav);
int networkstatus_parse_flavor_name(const char *flavname);
void document_signature_free(document_signature_t *sig);
document_signature_t *document_signature_dup(const document_signature_t *sig);
void networkstatus_free_all(void);
int networkstatus_get_weight_scale_param(networkstatus_t *ns);
# 30 "routerlist.c" 2
# 1 "nodelist.h" 1
# 19 "nodelist.h"
node_t *node_get_mutable_by_id(const char *identity_digest);
const node_t * node_get_by_id (const char *identity_digest);
const node_t *node_get_by_hex_id(const char *identity_digest);
node_t *nodelist_set_routerinfo(routerinfo_t *ri, routerinfo_t **ri_old_out);
node_t *nodelist_add_microdesc(microdesc_t *md);
void nodelist_set_consensus(networkstatus_t *ns);

void nodelist_remove_microdesc(const char *identity_digest, microdesc_t *md);
void nodelist_remove_routerinfo(routerinfo_t *ri);
void nodelist_purge(void);
smartlist_t *nodelist_find_nodes_with_microdesc(const microdesc_t *md);

void nodelist_free_all(void);
void nodelist_assert_ok(void);

const node_t * node_get_by_nickname (const char *nickname, int warn_if_unnamed)
                                                ;
void node_get_verbose_nickname(const node_t *node,
                               char *verbose_name_out);
void node_get_verbose_nickname_by_id(const char *id_digest,
                                char *verbose_name_out);
int node_is_named(const node_t *node);
int node_is_dir(const node_t *node);
int node_has_descriptor(const node_t *node);
int node_get_purpose(const node_t *node);


int node_is_me(const node_t *node);
int node_exit_policy_rejects_all(const node_t *node);
int node_exit_policy_is_exact(const node_t *node, sa_family_t family);
smartlist_t *node_get_all_orports(const node_t *node);
int node_allows_single_hop_exits(const node_t *node);
const char *node_get_nickname(const node_t *node);
const char *node_get_platform(const node_t *node);
uint32_t node_get_prim_addr_ipv4h(const node_t *node);
void node_get_address_string(const node_t *node, char *cp, size_t len);
long node_get_declared_uptime(const node_t *node);
time_t node_get_published_on(const node_t *node);
const smartlist_t *node_get_declared_family(const node_t *node);
int node_ipv6_preferred(const node_t *node);
int node_get_prim_orport(const node_t *node, tor_addr_port_t *ap_out);
void node_get_pref_orport(const node_t *node, tor_addr_port_t *ap_out);
void node_get_pref_ipv6_orport(const node_t *node, tor_addr_port_t *ap_out);
int node_has_curve25519_onion_key(const node_t *node);

smartlist_t * nodelist_get_list (void);


void node_get_addr(const node_t *node, tor_addr_t *addr_out);


void nodelist_refresh_countries(void);
void node_set_country(node_t *node);
void nodelist_add_node_and_family(smartlist_t *nodes, const node_t *node);
int nodes_in_same_family(const node_t *node1, const node_t *node2);

const node_t *router_find_exact_exit_enclave(const char *address,
                                             uint16_t port);
int node_is_unreliable(const node_t *router, int need_uptime,
                         int need_capacity, int need_guard);
int router_exit_policy_all_nodes_reject(const tor_addr_t *addr, uint16_t port,
                                        int need_uptime);
void router_set_status(const char *digest, int up);
# 90 "nodelist.h"
int router_have_minimum_dir_info(void);
# 101 "nodelist.h"
typedef enum {

  CONSENSUS_PATH_UNKNOWN = -1,


  CONSENSUS_PATH_INTERNAL = 0,


  CONSENSUS_PATH_EXIT = 1
} consensus_path_type_t;
consensus_path_type_t router_have_consensus_path(void);

void router_dir_info_changed(void);
const char *get_dir_info_status_string(void);
int count_loading_descriptors_progress(void);
# 31 "routerlist.c" 2
# 1 "policies.h" 1
# 25 "policies.h"
typedef int exit_policy_parser_cfg_t;

int firewall_is_fascist_or(void);
int fascist_firewall_allows_address_or(const tor_addr_t *addr, uint16_t port);
int fascist_firewall_allows_or(const routerinfo_t *ri);
int fascist_firewall_allows_node(const node_t *node);
int fascist_firewall_allows_address_dir(const tor_addr_t *addr, uint16_t port);
int dir_policy_permits_address(const tor_addr_t *addr);
int socks_policy_permits_address(const tor_addr_t *addr);
int authdir_policy_permits_address(uint32_t addr, uint16_t port);
int authdir_policy_valid_address(uint32_t addr, uint16_t port);
int authdir_policy_badexit_address(uint32_t addr, uint16_t port);

int validate_addr_policies(const or_options_t *options, char **msg);
void policy_expand_private(smartlist_t **policy);
void policy_expand_unspec(smartlist_t **policy);
int policies_parse_from_options(const or_options_t *options);

addr_policy_t *addr_policy_get_canonical_entry(addr_policy_t *ent);
int cmp_addr_policies(smartlist_t *a, smartlist_t *b);
addr_policy_result_t compare_tor_addr_to_addr_policy (const tor_addr_t *addr, uint16_t port, const smartlist_t *policy)
                                                                       ;

addr_policy_result_t compare_tor_addr_to_node_policy(const tor_addr_t *addr,
                              uint16_t port, const node_t *node);







int policies_parse_exit_policy_from_options(const or_options_t *or_options,
                                            uint32_t local_address,
                                            smartlist_t **result);
int policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,
                               exit_policy_parser_cfg_t options,
                               uint32_t local_address);
void policies_exit_policy_append_reject_star(smartlist_t **dest);
void addr_policy_append_reject_addr(smartlist_t **dest,
                                    const tor_addr_t *addr);
void policies_set_node_exitpolicy_to_reject_all(node_t *exitrouter);
int exit_policy_is_general_exit(smartlist_t *policy);
int policy_is_reject_star(const smartlist_t *policy, sa_family_t family);
int getinfo_helper_policies(control_connection_t *conn,
                            const char *question, char **answer,
                            const char **errmsg);
int policy_write_item(char *buf, size_t buflen, addr_policy_t *item,
                      int format_for_desc);

void addr_policy_list_free(smartlist_t *p);
void addr_policy_free(addr_policy_t *p);
void policies_free_all(void);

char *policy_summarize(smartlist_t *policy, sa_family_t family);

short_policy_t *parse_short_policy(const char *summary);
char *write_short_policy(const short_policy_t *policy);
void short_policy_free(short_policy_t *policy);
int short_policy_is_reject_star(const short_policy_t *policy);
addr_policy_result_t compare_tor_addr_to_short_policy(
                          const tor_addr_t *addr, uint16_t port,
                          const short_policy_t *policy);
# 32 "routerlist.c" 2
# 1 "reasons.h" 1
# 15 "reasons.h"
const char *stream_end_reason_to_control_string(int reason);
const char *stream_end_reason_to_string(int reason);
socks5_reply_status_t stream_end_reason_to_socks5_response(int reason);
uint8_t errno_to_stream_end_reason(int e);

const char *orconn_end_reason_to_control_string(int r);
int tls_error_to_orconn_end_reason(int e);
int errno_to_orconn_end_reason(int e);

const char *circuit_end_reason_to_control_string(int reason);
const char *socks4_response_code_to_string(uint8_t code);
const char *socks5_response_code_to_string(uint8_t code);

const char *bandwidth_weight_rule_to_string(enum bandwidth_weight_rule_t rule);
# 33 "routerlist.c" 2
# 1 "rendcommon.h" 1
# 16 "rendcommon.h"
static inline void
rend_data_free(rend_data_t *data)
{
  (void) ({ if (__builtin_expect(!!((data)!=((void *)0)), 1)) { free(data); (data)=((void *)0); } });
}

int rend_cmp_service_ids(const char *one, const char *two);

void rend_process_relay_cell(circuit_t *circ, const crypt_path_t *layer_hint,
                             int command, size_t length,
                             const uint8_t *payload);

void rend_service_descriptor_free(rend_service_descriptor_t *desc);
int rend_get_service_id(crypto_pk_t *pk, char *out);
void rend_encoded_v2_service_descriptor_free(
                               rend_encoded_v2_service_descriptor_t *desc);
void rend_intro_point_free(rend_intro_point_t *intro);

void rend_cache_init(void);
void rend_cache_clean(time_t now);
void rend_cache_clean_v2_descs_as_dir(time_t now, size_t min_to_remove);
void rend_cache_purge(void);
void rend_cache_free_all(void);
int rend_valid_service_id(const char *query);
int rend_cache_lookup_entry(const char *query, int version,
                            rend_cache_entry_t **entry_out);
int rend_cache_lookup_v2_desc_as_dir(const char *query, const char **desc);

typedef enum {
  RCS_NOTDIR = -2,
  RCS_BADDESC = -1,
  RCS_OKAY = 0
} rend_cache_store_status_t;

rend_cache_store_status_t rend_cache_store_v2_desc_as_dir(const char *desc);
rend_cache_store_status_t rend_cache_store_v2_desc_as_client(const char *desc,
                                       const char *desc_id_base32,
                                       const rend_data_t *rend_query);
int rend_encode_v2_descriptors(smartlist_t *descs_out,
                               rend_service_descriptor_t *desc, time_t now,
                               uint8_t period, rend_auth_type_t auth_type,
                               crypto_pk_t *client_key,
                               smartlist_t *client_cookies);
int rend_compute_v2_desc_id(char *desc_id_out, const char *service_id,
                            const char *descriptor_cookie,
                            time_t now, uint8_t replica);
int rend_id_is_in_interval(const char *a, const char *b, const char *c);
void rend_get_descriptor_id_bytes(char *descriptor_id_out,
                                  const char *service_id,
                                  const char *secret_id_part);
size_t rend_cache_get_total_allocation(void);
# 34 "routerlist.c" 2
# 1 "rendservice.h" 1
# 17 "rendservice.h"
typedef struct rend_intro_cell_s rend_intro_cell_t;
# 67 "rendservice.h"
int num_rend_services(void);
int rend_config_services(const or_options_t *options, int validate_only);
int rend_service_load_all_keys(void);
void rend_services_add_filenames_to_lists(smartlist_t *open_lst,
                                          smartlist_t *stat_lst);
void rend_services_introduce(void);
void rend_consider_services_upload(time_t now);
void rend_hsdir_routers_changed(void);
void rend_consider_descriptor_republication(void);

void rend_service_intro_has_opened(origin_circuit_t *circuit);
int rend_service_intro_established(origin_circuit_t *circuit,
                                   const uint8_t *request,
                                   size_t request_len);
void rend_service_rendezvous_has_opened(origin_circuit_t *circuit);
int rend_service_introduce(origin_circuit_t *circuit, const uint8_t *request,
                           size_t request_len);
int rend_service_decrypt_intro(rend_intro_cell_t *request,
                               crypto_pk_t *key,
                               char **err_msg_out);
void rend_service_free_intro(rend_intro_cell_t *request);
rend_intro_cell_t * rend_service_begin_parse_intro(const uint8_t *request,
                                                   size_t request_len,
                                                   uint8_t type,
                                                   char **err_msg_out);
int rend_service_parse_intro_plaintext(rend_intro_cell_t *intro,
                                       char **err_msg_out);
int rend_service_validate_intro_early(const rend_intro_cell_t *intro,
                                      char **err_msg_out);
int rend_service_validate_intro_late(const rend_intro_cell_t *intro,
                                     char **err_msg_out);
void rend_service_relaunch_rendezvous(origin_circuit_t *oldcirc);
int rend_service_set_connection_addr_port(edge_connection_t *conn,
                                          origin_circuit_t *circ);
void rend_service_dump_stats(int severity);
void rend_service_free_all(void);
# 35 "routerlist.c" 2
# 1 "rephist.h" 1
# 15 "rephist.h"
void rep_hist_init(void);
void rep_hist_note_connect_failed(const char* nickname, time_t when);
void rep_hist_note_connect_succeeded(const char* nickname, time_t when);
void rep_hist_note_disconnect(const char* nickname, time_t when);
void rep_hist_note_connection_died(const char* nickname, time_t when);
void rep_hist_note_extend_succeeded(const char *from_name,
                                    const char *to_name);
void rep_hist_note_extend_failed(const char *from_name, const char *to_name);
void rep_hist_dump_stats(time_t now, int severity);
void rep_hist_note_bytes_read(size_t num_bytes, time_t when);
void rep_hist_note_bytes_written(size_t num_bytes, time_t when);

void rep_hist_make_router_pessimal(const char *id, time_t when);

void rep_hist_note_dir_bytes_read(size_t num_bytes, time_t when);
void rep_hist_note_dir_bytes_written(size_t num_bytes, time_t when);

int rep_hist_bandwidth_assess(void);
char *rep_hist_get_bandwidth_lines(void);
void rep_hist_update_state(or_state_t *state);
int rep_hist_load_state(or_state_t *state, char **err);
void rep_history_clean(time_t before);

void rep_hist_note_router_reachable(const char *id, const tor_addr_t *at_addr,
                                    const uint16_t at_port, time_t when);
void rep_hist_note_router_unreachable(const char *id, time_t when);
int rep_hist_record_mtbf_data(time_t now, int missing_means_down);
int rep_hist_load_mtbf_data(time_t now);

time_t rep_hist_downrate_old_runs(time_t now);
long rep_hist_get_uptime(const char *id, time_t when);
double rep_hist_get_stability(const char *id, time_t when);
double rep_hist_get_weighted_fractional_uptime(const char *id, time_t when);
long rep_hist_get_weighted_time_known(const char *id, time_t when);
int rep_hist_have_measured_enough_stability(void);

void rep_hist_note_used_port(time_t now, uint16_t port);
smartlist_t *rep_hist_get_predicted_ports(time_t now);
void rep_hist_remove_predicted_ports(const smartlist_t *rmv_ports);
void rep_hist_note_used_resolve(time_t now);
void rep_hist_note_used_internal(time_t now, int need_uptime,
                                 int need_capacity);
int rep_hist_get_predicted_internal(time_t now, int *need_uptime,
                                    int *need_capacity);

int any_predicted_circuits(time_t now);
int rep_hist_circbuilding_dormant(time_t now);

void note_crypto_pk_op(pk_op_t operation);
void dump_pk_ops(int severity);

void rep_hist_exit_stats_init(time_t now);
void rep_hist_reset_exit_stats(time_t now);
void rep_hist_exit_stats_term(void);
char *rep_hist_format_exit_stats(time_t now);
time_t rep_hist_exit_stats_write(time_t now);
void rep_hist_note_exit_bytes(uint16_t port, size_t num_written,
                              size_t num_read);
void rep_hist_note_exit_stream_opened(uint16_t port);

void rep_hist_buffer_stats_init(time_t now);
void rep_hist_buffer_stats_add_circ(circuit_t *circ,
                                    time_t end_of_interval);
time_t rep_hist_buffer_stats_write(time_t now);
void rep_hist_buffer_stats_term(void);
void rep_hist_add_buffer_stats(double mean_num_cells_in_queue,
     double mean_time_cells_in_queue, uint32_t processed_cells);
char *rep_hist_format_buffer_stats(time_t now);
void rep_hist_reset_buffer_stats(time_t now);

void rep_hist_desc_stats_init(time_t now);
void rep_hist_note_desc_served(const char * desc);
void rep_hist_desc_stats_term(void);
time_t rep_hist_desc_stats_write(time_t now);

void rep_hist_conn_stats_init(time_t now);
void rep_hist_note_or_conn_bytes(uint64_t conn_id, size_t num_read,
                                 size_t num_written, time_t when);
void rep_hist_reset_conn_stats(time_t now);
char *rep_hist_format_conn_stats(time_t now);
time_t rep_hist_conn_stats_write(time_t now);
void rep_hist_conn_stats_term(void);

void rep_hist_note_circuit_handshake_requested(uint16_t type);
void rep_hist_note_circuit_handshake_assigned(uint16_t type);
void rep_hist_log_circuit_handshake_stats(time_t now);

void rep_hist_hs_stats_init(time_t now);
void rep_hist_hs_stats_term(void);
time_t rep_hist_hs_stats_write(time_t now);
char *rep_hist_get_hs_stats_string(void);
void rep_hist_seen_new_rp_cell(void);
void rep_hist_stored_maybe_new_hs(const crypto_pk_t *pubkey);

void rep_hist_free_all(void);

void rep_hist_note_negotiated_link_proto(unsigned link_proto,
                                         int started_here);
void rep_hist_log_link_protocol_counts(void);
# 36 "routerlist.c" 2
# 1 "router.h" 1
# 17 "router.h"
crypto_pk_t *get_onion_key(void);
time_t get_onion_key_set_at(void);
void set_server_identity_key(crypto_pk_t *k);
crypto_pk_t *get_server_identity_key(void);
int server_identity_key_is_set(void);
void set_client_identity_key(crypto_pk_t *k);
crypto_pk_t *get_tlsclient_identity_key(void);
int client_identity_key_is_set(void);
authority_cert_t *get_my_v3_authority_cert(void);
crypto_pk_t *get_my_v3_authority_signing_key(void);
authority_cert_t *get_my_v3_legacy_cert(void);
crypto_pk_t *get_my_v3_legacy_signing_key(void);
void dup_onion_keys(crypto_pk_t **key, crypto_pk_t **last);
void rotate_onion_key(void);
crypto_pk_t *init_key_from_file(const char *fname, int generate,
                                    int severity, int log_greeting);
void v3_authority_check_key_expiry(void);

di_digest256_map_t *construct_ntor_key_map(void);
void ntor_key_map_free(di_digest256_map_t *map);

int router_initialize_tls_context(void);
int init_keys(void);

int check_whether_orport_reachable(void);
int check_whether_dirport_reachable(void);
void consider_testing_reachability(int test_or, int test_dir);
void router_orport_found_reachable(void);
void router_dirport_found_reachable(void);
void router_perform_bandwidth_test(int num_circs, time_t now);

int net_is_disabled(void);

int authdir_mode(const or_options_t *options);
int authdir_mode_v3(const or_options_t *options);
int authdir_mode_any_main(const or_options_t *options);
int authdir_mode_any_nonhidserv(const or_options_t *options);
int authdir_mode_handles_descs(const or_options_t *options, int purpose);
int authdir_mode_publishes_statuses(const or_options_t *options);
int authdir_mode_tests_reachability(const or_options_t *options);
int authdir_mode_bridge(const or_options_t *options);

uint16_t router_get_active_listener_port_by_type_af(int listener_type,
                                                    sa_family_t family);
uint16_t router_get_advertised_or_port(const or_options_t *options);
uint16_t router_get_advertised_or_port_by_af(const or_options_t *options,
                                             sa_family_t family);
uint16_t router_get_advertised_dir_port(const or_options_t *options,
                                        uint16_t dirport);

int server_mode (const or_options_t *options);
int public_server_mode (const or_options_t *options);
int advertised_server_mode(void);
int proxy_mode(const or_options_t *options);
void consider_publishable_server(int force);
int should_refuse_unknown_exits(const or_options_t *options);

void router_upload_dir_desc_to_dirservers(int force);
void mark_my_descriptor_dirty_if_too_old(time_t now);
void mark_my_descriptor_dirty(const char *reason);
void check_descriptor_bandwidth_changed(time_t now);
void check_descriptor_ipaddress_changed(time_t now);
void router_new_address_suggestion(const char *suggestion,
                                   const dir_connection_t *d_conn);
int router_compare_to_my_exit_policy(const tor_addr_t *addr, uint16_t port);
int router_my_exit_policy_is_reject_star(void);
const routerinfo_t * router_get_my_routerinfo (void);
extrainfo_t *router_get_my_extrainfo(void);
const char *router_get_my_descriptor(void);
const char *router_get_descriptor_gen_reason(void);
int router_digest_is_me(const char *digest);
const uint8_t *router_get_my_id_digest(void);
int router_extrainfo_digest_is_me(const char *digest);
int router_is_me(const routerinfo_t *router);
int router_pick_published_address(const or_options_t *options, uint32_t *addr);
int router_rebuild_descriptor(int force);
char *router_dump_router_to_string(routerinfo_t *router,
                                   crypto_pk_t *ident_key);
char *router_dump_exit_policy_to_string(const routerinfo_t *router,
                                         int include_ipv4,
                                         int include_ipv6);
void router_get_prim_orport(const routerinfo_t *router,
                            tor_addr_port_t *addr_port_out);
void router_get_pref_orport(const routerinfo_t *router,
                            tor_addr_port_t *addr_port_out);
void router_get_pref_ipv6_orport(const routerinfo_t *router,
                                 tor_addr_port_t *addr_port_out);
int router_ipv6_preferred(const routerinfo_t *router);
int router_has_addr(const routerinfo_t *router, const tor_addr_t *addr);
int router_has_orport(const routerinfo_t *router,
                      const tor_addr_port_t *orport);
int extrainfo_dump_to_string(char **s, extrainfo_t *extrainfo,
                             crypto_pk_t *ident_key);
int is_legal_nickname(const char *s);
int is_legal_nickname_or_hexdigest(const char *s);
int is_legal_hexdigest(const char *s);
# 122 "router.h"
const char *format_node_description(char *buf,
                                    const char *id_digest,
                                    int is_named,
                                    const char *nickname,
                                    const tor_addr_t *addr,
                                    uint32_t addr32h);
const char *router_get_description(char *buf, const routerinfo_t *ri);
const char *node_get_description(char *buf, const node_t *node);
const char *routerstatus_get_description(char *buf, const routerstatus_t *rs);
const char *extend_info_get_description(char *buf, const extend_info_t *ei);
const char *router_describe(const routerinfo_t *ri);
const char *node_describe(const node_t *node);
const char *routerstatus_describe(const routerstatus_t *ri);
const char *extend_info_describe(const extend_info_t *ei);

void router_get_verbose_nickname(char *buf, const routerinfo_t *router);
void router_reset_warnings(void);
void router_reset_reachability(void);
void router_free_all(void);

const char *router_purpose_to_string(uint8_t p);
uint8_t router_purpose_from_string(const char *s);

smartlist_t *router_get_all_orports(const routerinfo_t *ri);
# 37 "routerlist.c" 2
# 1 "routerlist.h" 1
# 16 "routerlist.h"
int get_n_authorities(dirinfo_type_t type);
int trusted_dirs_reload_certs(void);
# 31 "routerlist.h"
int trusted_dirs_load_certs_from_string(const char *contents, int source,
                                        int flush);
void trusted_dirs_flush_certs_to_disk(void);
authority_cert_t *authority_cert_get_newest_by_id(const char *id_digest);
authority_cert_t *authority_cert_get_by_sk_digest(const char *sk_digest);
authority_cert_t *authority_cert_get_by_digests(const char *id_digest,
                                                const char *sk_digest);
void authority_cert_get_all(smartlist_t *certs_out);
void authority_cert_dl_failed(const char *id_digest,
                              const char *signing_key_digest, int status);
void authority_certs_fetch_missing(networkstatus_t *status, time_t now);
int router_reload_router_list(void);
int authority_cert_dl_looks_uncertain(const char *id_digest);
const smartlist_t *router_get_trusted_dir_servers(void);
const smartlist_t *router_get_fallback_dir_servers(void);
int authority_cert_is_blacklisted(const authority_cert_t *cert);

const routerstatus_t *router_pick_directory_server(dirinfo_type_t type,
                                                   int flags);
dir_server_t *router_get_trusteddirserver_by_digest(const char *d);
dir_server_t *router_get_fallback_dirserver_by_digest(
                                                   const char *digest);
dir_server_t *trusteddirserver_get_by_v3_auth_digest(const char *d);
const routerstatus_t *router_pick_trusteddirserver(dirinfo_type_t type,
                                                   int flags);
const routerstatus_t *router_pick_fallback_dirserver(dirinfo_type_t type,
                                                     int flags);
int router_get_my_share_of_directory_requests(double *v3_share_out);
void router_reset_status_download_failures(void);
int routers_have_same_or_addrs(const routerinfo_t *r1, const routerinfo_t *r2);
void router_add_running_nodes_to_smartlist(smartlist_t *sl, int allow_invalid,
                                           int need_uptime, int need_capacity,
                                           int need_guard, int need_desc);

const routerinfo_t *routerlist_find_my_routerinfo(void);
uint32_t router_get_advertised_bandwidth(const routerinfo_t *router);
uint32_t router_get_advertised_bandwidth_capped(const routerinfo_t *router);

const node_t *node_sl_choose_by_bandwidth(const smartlist_t *sl,
                                          bandwidth_weight_rule_t rule);
double frac_nodes_with_descriptors(const smartlist_t *sl,
                                   bandwidth_weight_rule_t rule);

const node_t *router_choose_random_node(smartlist_t *excludedsmartlist,
                                        struct routerset_t *excludedset,
                                        router_crn_flags_t flags);

int router_is_named(const routerinfo_t *router);
int router_digest_is_trusted_dir_type(const char *digest,
                                      dirinfo_type_t type);



int router_addr_is_trusted_dir(uint32_t addr);
int hexdigest_to_digest(const char *hexdigest, char *digest);
const routerinfo_t *router_get_by_id_digest(const char *digest);
routerinfo_t *router_get_mutable_by_digest(const char *digest);
signed_descriptor_t *router_get_by_descriptor_digest(const char *digest);
signed_descriptor_t * router_get_by_extrainfo_digest (const char *digest)
                               ;
signed_descriptor_t *extrainfo_get_by_descriptor_digest(const char *digest);
const char *signed_descriptor_get_body(const signed_descriptor_t *desc);
const char *signed_descriptor_get_annotations(const signed_descriptor_t *desc);
routerlist_t *router_get_routerlist(void);
void routerinfo_free(routerinfo_t *router);
void extrainfo_free(extrainfo_t *extrainfo);
void routerlist_free(routerlist_t *rl);
void dump_routerlist_mem_usage(int severity);
void routerlist_remove(routerlist_t *rl, routerinfo_t *ri, int make_old,
                       time_t now);
void routerlist_free_all(void);
void routerlist_reset_warnings(void);

static int WRA_WAS_ADDED(was_router_added_t s);
static int WRA_WAS_OUTDATED(was_router_added_t s);
static int WRA_WAS_REJECTED(was_router_added_t s);
static int WRA_NEVER_DOWNLOADABLE(was_router_added_t s);




static inline int
WRA_WAS_ADDED(was_router_added_t s) {
  return s == ROUTER_ADDED_SUCCESSFULLY || s == ROUTER_ADDED_NOTIFY_GENERATOR;
}






static inline int WRA_WAS_OUTDATED(was_router_added_t s)
{
  return (s == ROUTER_WAS_TOO_OLD ||
          s == ROUTER_IS_ALREADY_KNOWN ||
          s == ROUTER_NOT_IN_CONSENSUS ||
          s == ROUTER_NOT_IN_CONSENSUS_OR_NETWORKSTATUS);
}


static inline int WRA_WAS_REJECTED(was_router_added_t s)
{
  return (s == ROUTER_AUTHDIR_REJECTS);
}


static inline int WRA_NEVER_DOWNLOADABLE(was_router_added_t s)
{
  return (s == ROUTER_AUTHDIR_REJECTS ||
          s == ROUTER_BAD_EI ||
          s == ROUTER_WAS_TOO_OLD);
}
was_router_added_t router_add_to_routerlist(routerinfo_t *router,
                                            const char **msg,
                                            int from_cache,
                                            int from_fetch);
was_router_added_t router_add_extrainfo_to_routerlist(
                                        extrainfo_t *ei, const char **msg,
                                        int from_cache, int from_fetch);
void routerlist_descriptors_added(smartlist_t *sl, int from_cache);
void routerlist_remove_old_routers(void);
int router_load_single_router(const char *s, uint8_t purpose, int cache,
                              const char **msg);
int router_load_routers_from_string(const char *s, const char *eos,
                                     saved_location_t saved_location,
                                     smartlist_t *requested_fingerprints,
                                     int descriptor_digests,
                                     const char *prepend_annotations);
void router_load_extrainfo_from_string(const char *s, const char *eos,
                                       saved_location_t saved_location,
                                       smartlist_t *requested_fingerprints,
                                       int descriptor_digests);

void routerlist_retry_directory_downloads(time_t now);

int router_exit_policy_rejects_all(const routerinfo_t *router);

dir_server_t *trusted_dir_server_new(const char *nickname, const char *address,
                       uint16_t dir_port, uint16_t or_port,
                       const char *digest, const char *v3_auth_digest,
                       dirinfo_type_t type, double weight);
dir_server_t *fallback_dir_server_new(const tor_addr_t *addr,
                                      uint16_t dir_port, uint16_t or_port,
                                      const char *id_digest, double weight);
void dir_server_add(dir_server_t *ent);

void authority_cert_free(authority_cert_t *cert);
void clear_dir_servers(void);
void update_consensus_router_descriptor_downloads(time_t now, int is_vote,
                                                  networkstatus_t *consensus);
void update_router_descriptor_downloads(time_t now);
void update_all_descriptor_downloads(time_t now);
void update_extrainfo_downloads(time_t now);
void router_reset_descriptor_download_failures(void);
int router_differences_are_cosmetic(const routerinfo_t *r1,
                                    const routerinfo_t *r2);
int routerinfo_incompatible_with_extrainfo(const routerinfo_t *ri,
                                           extrainfo_t *ei,
                                           signed_descriptor_t *sd,
                                           const char **msg);

void routerlist_assert_ok(const routerlist_t *rl);
const char *esc_router_info(const routerinfo_t *router);
void routers_sort_by_identity(smartlist_t *routers);

void refresh_all_country_info(void);

int hid_serv_get_responsible_directories(smartlist_t *responsible_dirs,
                                         const char *id);
int hid_serv_acting_as_directory(void);
int hid_serv_responsible_for_desc_id(const char *id);

void list_pending_microdesc_downloads(digest256map_t *result);
void launch_descriptor_downloads(int purpose,
                                 smartlist_t *downloadable,
                                 const routerstatus_t *source,
                                 time_t now);

int hex_digest_nickname_decode(const char *hexdigest,
                               char *digest_out,
                               char *nickname_qualifier_out,
                               char *nickname_out);
int hex_digest_nickname_matches(const char *hexdigest,
                                const char *identity_digest,
                                const char *nickname, int is_named);





typedef union u64_dbl_t {
  uint64_t u64;
  double dbl;
} u64_dbl_t;

static int choose_array_element_by_weight(const u64_dbl_t *entries,
                                          int n_entries);
static void scale_array_elements_to_u64(u64_dbl_t *entries, int n_entries,
                                        uint64_t *total_out);

int router_descriptor_is_older_than (const routerinfo_t *router, int seconds)
                                                              ;
static was_router_added_t extrainfo_insert (routerlist_t *rl, extrainfo_t *ei, int warn_if_incompatible)
                                                                        ;

static void initiate_descriptor_downloads (const routerstatus_t *source, int purpose, smartlist_t *digests, int lo, int hi, int pds_flags)

                                          ;
# 38 "routerlist.c" 2
# 1 "routerparse.h" 1
# 15 "routerparse.h"
int router_get_router_hash(const char *s, size_t s_len, char *digest);
int router_get_dir_hash(const char *s, char *digest);
int router_get_networkstatus_v3_hashes(const char *s, digests_t *digests);
int router_get_extrainfo_hash(const char *s, size_t s_len, char *digest);

char *router_get_dirobj_signature(const char *digest,
                                  size_t digest_len,
                                  crypto_pk_t *private_key);
int router_append_dirobj_signature(char *buf, size_t buf_len,
                                   const char *digest,
                                   size_t digest_len,
                                   crypto_pk_t *private_key);
int router_parse_list_from_string(const char **s, const char *eos,
                                  smartlist_t *dest,
                                  saved_location_t saved_location,
                                  int is_extrainfo,
                                  int allow_annotations,
                                  const char *prepend_annotations,
                                  smartlist_t *invalid_digests_out);

routerinfo_t *router_parse_entry_from_string(const char *s, const char *end,
                                             int cache_copy,
                                             int allow_annotations,
                                             const char *prepend_annotations,
                                             int *can_dl_again_out);
extrainfo_t *extrainfo_parse_entry_from_string(const char *s, const char *end,
                             int cache_copy, struct digest_ri_map_t *routermap,
                             int *can_dl_again_out);
addr_policy_t * router_parse_addr_policy_item_from_string (const char *s, int assume_action)
                                       ;
version_status_t tor_version_is_obsolete(const char *myversion,
                                         const char *versionlist);
int tor_version_supports_microdescriptors(const char *platform);
int tor_version_as_new_as(const char *platform, const char *cutoff);
int tor_version_parse(const char *s, tor_version_t *out);
int tor_version_compare(tor_version_t *a, tor_version_t *b);
int tor_version_same_series(tor_version_t *a, tor_version_t *b);
void sort_version_list(smartlist_t *lst, int remove_duplicates);
void assert_addr_policy_ok(smartlist_t *t);
void dump_distinct_digest_count(int severity);

int compare_vote_routerstatus_entries(const void **_a, const void **_b);
int networkstatus_verify_bw_weights(networkstatus_t *ns, int);
networkstatus_t *networkstatus_parse_vote_from_string(const char *s,
                                                 const char **eos_out,
                                                 networkstatus_type_t ns_type);
ns_detached_signatures_t *networkstatus_parse_detached_signatures(
                                          const char *s, const char *eos);

smartlist_t *microdescs_parse_from_string(const char *s, const char *eos,
                                          int allow_annotations,
                                          saved_location_t where,
                                          smartlist_t *invalid_digests_out);

authority_cert_t *authority_cert_parse_from_string(const char *s,
                                                   const char **end_of_string);
int rend_parse_v2_service_descriptor(rend_service_descriptor_t **parsed_out,
                                     char *desc_id_out,
                                     char **intro_points_encrypted_out,
                                     size_t *intro_points_encrypted_size_out,
                                     size_t *encoded_size_out,
                                     const char **next_out, const char *desc,
                                     int as_hsdir);
int rend_decrypt_introduction_points(char **ipos_decrypted,
                                     size_t *ipos_decrypted_size,
                                     const char *descriptor_cookie,
                                     const char *ipos_encrypted,
                                     size_t ipos_encrypted_size);
int rend_parse_introduction_points(rend_service_descriptor_t *parsed,
                                   const char *intro_points_encoded,
                                   size_t intro_points_encoded_size);
int rend_parse_client_keys(strmap_t *parsed_clients, const char *str);
# 39 "routerlist.c" 2
# 1 "routerset.h" 1
# 14 "routerset.h"
routerset_t *routerset_new(void);
void routerset_refresh_countries(routerset_t *rs);
int routerset_parse(routerset_t *target, const char *s,
                    const char *description);
void routerset_union(routerset_t *target, const routerset_t *source);
int routerset_is_list(const routerset_t *set);
int routerset_needs_geoip(const routerset_t *set);
int routerset_is_empty(const routerset_t *set);
int routerset_contains_router(const routerset_t *set, const routerinfo_t *ri,
                              country_t country);
int routerset_contains_routerstatus(const routerset_t *set,
                                    const routerstatus_t *rs,
                                    country_t country);
int routerset_contains_extendinfo(const routerset_t *set,
                                  const extend_info_t *ei);

int routerset_contains_node(const routerset_t *set, const node_t *node);
void routerset_get_all_nodes(smartlist_t *out, const routerset_t *routerset,
                             const routerset_t *excludeset,
                             int running_only);
int routerset_add_unknown_ccs(routerset_t **setp, int only_if_some_cc_set);
void routerset_subtract_nodes(smartlist_t *out,
                                const routerset_t *routerset);

char *routerset_to_string(const routerset_t *routerset);
int routerset_equal(const routerset_t *old, const routerset_t *new);
void routerset_free(routerset_t *routerset);
# 40 "routerlist.c" 2
# 1 "../common/sandbox.h" 1
# 15 "../common/sandbox.h"
# 1 "../win32/orconfig.h" 1
# 16 "../common/sandbox.h" 2
# 32 "../common/sandbox.h"
struct sandbox_cfg_elem;


typedef struct sandbox_cfg_elem sandbox_cfg_t;
# 140 "../common/sandbox.h"
sandbox_cfg_t * sandbox_cfg_new(void);






int sandbox_cfg_allow_open_filename(sandbox_cfg_t **cfg, char *file);


int sandbox_cfg_allow_rename(sandbox_cfg_t **cfg, char *file1, char *file2);






int sandbox_cfg_allow_openat_filename(sandbox_cfg_t **cfg, char *file);
# 171 "../common/sandbox.h"
int sandbox_cfg_allow_stat_filename(sandbox_cfg_t **cfg, char *file);


int sandbox_init(sandbox_cfg_t* cfg);


int sandbox_is_active(void);

void sandbox_disable_getaddrinfo_cache(void);
# 41 "routerlist.c" 2




typedef struct digest_sd_map_t digest_sd_map_t; typedef struct sdmap_iter_t *sdmap_iter_t; __attribute__ ((unused)) static inline digest_sd_map_t* sdmap_new(void) { return (digest_sd_map_t*)digestmap_new(); } __attribute__ ((unused)) static inline digestmap_t* sdmap_to_digestmap(digest_sd_map_t *map) { return (digestmap_t*)map; } __attribute__ ((unused)) static inline signed_descriptor_t* sdmap_get(digest_sd_map_t *map, const char *key) { return (signed_descriptor_t*)digestmap_get((digestmap_t*)map, key); } __attribute__ ((unused)) static inline signed_descriptor_t* sdmap_set(digest_sd_map_t *map, const char *key, signed_descriptor_t *val) { return (signed_descriptor_t*)digestmap_set((digestmap_t*)map, key, val); } __attribute__ ((unused)) static inline signed_descriptor_t* sdmap_remove(digest_sd_map_t *map, const char *key) { return (signed_descriptor_t*)digestmap_remove((digestmap_t*)map, key); } __attribute__ ((unused)) static inline void sdmap_free(digest_sd_map_t *map, void (*free_val)(void*)) { digestmap_free((digestmap_t*)map, free_val); } __attribute__ ((unused)) static inline int sdmap_isempty(digest_sd_map_t *map) { return digestmap_isempty((digestmap_t*)map); } __attribute__ ((unused)) static inline int sdmap_size(digest_sd_map_t *map) { return digestmap_size((digestmap_t*)map); } __attribute__ ((unused)) static inline sdmap_iter_t *sdmap_iter_init(digest_sd_map_t *map) { return (sdmap_iter_t*) digestmap_iter_init((digestmap_t*)map); } __attribute__ ((unused)) static inline sdmap_iter_t *sdmap_iter_next(digest_sd_map_t *map, sdmap_iter_t *iter) { return (sdmap_iter_t*) digestmap_iter_next( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline sdmap_iter_t* sdmap_iter_next_rmv(digest_sd_map_t *map, sdmap_iter_t *iter) { return (sdmap_iter_t*) digestmap_iter_next_rmv( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline void sdmap_iter_get(sdmap_iter_t *iter, const char **keyp, signed_descriptor_t **valp) { void *v; digestmap_iter_get((digestmap_iter_t*) iter, keyp, &v); *valp = v; } __attribute__ ((unused)) static inline int sdmap_iter_done(sdmap_iter_t *iter) { return digestmap_iter_done((digestmap_iter_t*)iter); }
typedef struct digest_ri_map_t digest_ri_map_t; typedef struct rimap_iter_t *rimap_iter_t; __attribute__ ((unused)) static inline digest_ri_map_t* rimap_new(void) { return (digest_ri_map_t*)digestmap_new(); } __attribute__ ((unused)) static inline digestmap_t* rimap_to_digestmap(digest_ri_map_t *map) { return (digestmap_t*)map; } __attribute__ ((unused)) static inline routerinfo_t* rimap_get(digest_ri_map_t *map, const char *key) { return (routerinfo_t*)digestmap_get((digestmap_t*)map, key); } __attribute__ ((unused)) static inline routerinfo_t* rimap_set(digest_ri_map_t *map, const char *key, routerinfo_t *val) { return (routerinfo_t*)digestmap_set((digestmap_t*)map, key, val); } __attribute__ ((unused)) static inline routerinfo_t* rimap_remove(digest_ri_map_t *map, const char *key) { return (routerinfo_t*)digestmap_remove((digestmap_t*)map, key); } __attribute__ ((unused)) static inline void rimap_free(digest_ri_map_t *map, void (*free_val)(void*)) { digestmap_free((digestmap_t*)map, free_val); } __attribute__ ((unused)) static inline int rimap_isempty(digest_ri_map_t *map) { return digestmap_isempty((digestmap_t*)map); } __attribute__ ((unused)) static inline int rimap_size(digest_ri_map_t *map) { return digestmap_size((digestmap_t*)map); } __attribute__ ((unused)) static inline rimap_iter_t *rimap_iter_init(digest_ri_map_t *map) { return (rimap_iter_t*) digestmap_iter_init((digestmap_t*)map); } __attribute__ ((unused)) static inline rimap_iter_t *rimap_iter_next(digest_ri_map_t *map, rimap_iter_t *iter) { return (rimap_iter_t*) digestmap_iter_next( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline rimap_iter_t* rimap_iter_next_rmv(digest_ri_map_t *map, rimap_iter_t *iter) { return (rimap_iter_t*) digestmap_iter_next_rmv( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline void rimap_iter_get(rimap_iter_t *iter, const char **keyp, routerinfo_t **valp) { void *v; digestmap_iter_get((digestmap_iter_t*) iter, keyp, &v); *valp = v; } __attribute__ ((unused)) static inline int rimap_iter_done(rimap_iter_t *iter) { return digestmap_iter_done((digestmap_iter_t*)iter); }
typedef struct digest_ei_map_t digest_ei_map_t; typedef struct eimap_iter_t *eimap_iter_t; __attribute__ ((unused)) static inline digest_ei_map_t* eimap_new(void) { return (digest_ei_map_t*)digestmap_new(); } __attribute__ ((unused)) static inline digestmap_t* eimap_to_digestmap(digest_ei_map_t *map) { return (digestmap_t*)map; } __attribute__ ((unused)) static inline extrainfo_t* eimap_get(digest_ei_map_t *map, const char *key) { return (extrainfo_t*)digestmap_get((digestmap_t*)map, key); } __attribute__ ((unused)) static inline extrainfo_t* eimap_set(digest_ei_map_t *map, const char *key, extrainfo_t *val) { return (extrainfo_t*)digestmap_set((digestmap_t*)map, key, val); } __attribute__ ((unused)) static inline extrainfo_t* eimap_remove(digest_ei_map_t *map, const char *key) { return (extrainfo_t*)digestmap_remove((digestmap_t*)map, key); } __attribute__ ((unused)) static inline void eimap_free(digest_ei_map_t *map, void (*free_val)(void*)) { digestmap_free((digestmap_t*)map, free_val); } __attribute__ ((unused)) static inline int eimap_isempty(digest_ei_map_t *map) { return digestmap_isempty((digestmap_t*)map); } __attribute__ ((unused)) static inline int eimap_size(digest_ei_map_t *map) { return digestmap_size((digestmap_t*)map); } __attribute__ ((unused)) static inline eimap_iter_t *eimap_iter_init(digest_ei_map_t *map) { return (eimap_iter_t*) digestmap_iter_init((digestmap_t*)map); } __attribute__ ((unused)) static inline eimap_iter_t *eimap_iter_next(digest_ei_map_t *map, eimap_iter_t *iter) { return (eimap_iter_t*) digestmap_iter_next( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline eimap_iter_t* eimap_iter_next_rmv(digest_ei_map_t *map, eimap_iter_t *iter) { return (eimap_iter_t*) digestmap_iter_next_rmv( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline void eimap_iter_get(eimap_iter_t *iter, const char **keyp, extrainfo_t **valp) { void *v; digestmap_iter_get((digestmap_iter_t*) iter, keyp, &v); *valp = v; } __attribute__ ((unused)) static inline int eimap_iter_done(eimap_iter_t *iter) { return digestmap_iter_done((digestmap_iter_t*)iter); }
typedef struct digest_ds_map_t digest_ds_map_t; typedef struct dsmap_iter_t *dsmap_iter_t; __attribute__ ((unused)) static inline digest_ds_map_t* dsmap_new(void) { return (digest_ds_map_t*)digestmap_new(); } __attribute__ ((unused)) static inline digestmap_t* dsmap_to_digestmap(digest_ds_map_t *map) { return (digestmap_t*)map; } __attribute__ ((unused)) static inline download_status_t* dsmap_get(digest_ds_map_t *map, const char *key) { return (download_status_t*)digestmap_get((digestmap_t*)map, key); } __attribute__ ((unused)) static inline download_status_t* dsmap_set(digest_ds_map_t *map, const char *key, download_status_t *val) { return (download_status_t*)digestmap_set((digestmap_t*)map, key, val); } __attribute__ ((unused)) static inline download_status_t* dsmap_remove(digest_ds_map_t *map, const char *key) { return (download_status_t*)digestmap_remove((digestmap_t*)map, key); } __attribute__ ((unused)) static inline void dsmap_free(digest_ds_map_t *map, void (*free_val)(void*)) { digestmap_free((digestmap_t*)map, free_val); } __attribute__ ((unused)) static inline int dsmap_isempty(digest_ds_map_t *map) { return digestmap_isempty((digestmap_t*)map); } __attribute__ ((unused)) static inline int dsmap_size(digest_ds_map_t *map) { return digestmap_size((digestmap_t*)map); } __attribute__ ((unused)) static inline dsmap_iter_t *dsmap_iter_init(digest_ds_map_t *map) { return (dsmap_iter_t*) digestmap_iter_init((digestmap_t*)map); } __attribute__ ((unused)) static inline dsmap_iter_t *dsmap_iter_next(digest_ds_map_t *map, dsmap_iter_t *iter) { return (dsmap_iter_t*) digestmap_iter_next( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline dsmap_iter_t* dsmap_iter_next_rmv(digest_ds_map_t *map, dsmap_iter_t *iter) { return (dsmap_iter_t*) digestmap_iter_next_rmv( (digestmap_t*)map, (digestmap_iter_t*)iter); } __attribute__ ((unused)) static inline void dsmap_iter_get(dsmap_iter_t *iter, const char **keyp, download_status_t **valp) { void *v; digestmap_iter_get((digestmap_iter_t*) iter, keyp, &v); *valp = v; } __attribute__ ((unused)) static inline int dsmap_iter_done(dsmap_iter_t *iter) { return digestmap_iter_done((digestmap_iter_t*)iter); }
# 61 "routerlist.c"
typedef struct cert_list_t cert_list_t;


static int compute_weighted_bandwidths(const smartlist_t *sl,
                                       bandwidth_weight_rule_t rule,
                                       u64_dbl_t **bandwidths_out);
static const routerstatus_t *router_pick_directory_server_impl(
                              dirinfo_type_t auth, int flags, int *n_busy_out);
static const routerstatus_t *router_pick_trusteddirserver_impl(
                const smartlist_t *sourcelist, dirinfo_type_t auth,
                int flags, int *n_busy_out);
static const routerstatus_t *router_pick_dirserver_generic(
                              smartlist_t *sourcelist,
                              dirinfo_type_t type, int flags);
static void mark_all_dirservers_up(smartlist_t *server_list);
static void dir_server_free(dir_server_t *ds);
static int signed_desc_digest_is_recognized(signed_descriptor_t *desc);
static const char *signed_descriptor_get_body_impl(
                                              const signed_descriptor_t *desc,
                                              int with_annotations);
static void list_pending_downloads(digestmap_t *result,
                                   digest256map_t *result256,
                                   int purpose, const char *prefix);
static void list_pending_fpsk_downloads(fp_pair_map_t *result);
static void launch_dummy_descriptor_download_as_needed(time_t now,
                                   const or_options_t *options);
static void download_status_reset_by_sk_in_cl(cert_list_t *cl,
                                              const char *digest);
static int download_status_is_ready_by_sk_in_cl(cert_list_t *cl,
                                                const char *digest,
                                                time_t now, int max_failures);





static smartlist_t *trusted_dir_servers = ((void *)0);


static smartlist_t *fallback_dir_servers = ((void *)0);




struct cert_list_t {





  struct digest_ds_map_t *dl_status_map;

  download_status_t dl_status_by_id;
  smartlist_t *certs;
};

static digestmap_t *trusted_dir_certs = ((void *)0);



static int trusted_dir_servers_certs_changed = 0;


static routerlist_t *routerlist = ((void *)0);



static smartlist_t *warned_nicknames = ((void *)0);




static time_t last_descriptor_download_attempted = 0;



int
get_n_authorities(dirinfo_type_t type)
{
  int n = 0;
  if (!trusted_dir_servers)
    return 0;
  (void) ({ int ds_sl_idx, ds_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ds; for (ds_sl_idx = 0; ds_sl_idx < ds_sl_len; ++ds_sl_idx) { ds = (trusted_dir_servers)->list[ds_sl_idx]; { if (ds->type & type) ++n; } ds = ((void *)0); } })

                          ;
  return n;
}


static void
download_status_reset_by_sk_in_cl(cert_list_t *cl, const char *digest)
{
  download_status_t *dlstatus = ((void *)0);

  (void) ({ if (__builtin_expect(!!(!(cl)), 0)) { tor_assertion_failed_(("routerlist.c"), 155, "???", "cl"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(digest)), 0)) { tor_assertion_failed_(("routerlist.c"), 156, "???", "digest"); abort(); } });


  if (!(cl->dl_status_map)) {
    cl->dl_status_map = dsmap_new();
  }

  dlstatus = dsmap_get(cl->dl_status_map, digest);

  if (!dlstatus) {

    dlstatus = tor_malloc_zero_(sizeof(*dlstatus) );
    dsmap_set(cl->dl_status_map, digest, dlstatus);
  }
  (void) ({ if (__builtin_expect(!!(!(dlstatus)), 0)) { tor_assertion_failed_(("routerlist.c"), 170, "???", "dlstatus"); abort(); } });

  download_status_reset(dlstatus);
}





static int
download_status_is_ready_by_sk_in_cl(cert_list_t *cl,
                                     const char *digest,
                                     time_t now, int max_failures)
{
  int rv = 0;
  download_status_t *dlstatus = ((void *)0);

  (void) ({ if (__builtin_expect(!!(!(cl)), 0)) { tor_assertion_failed_(("routerlist.c"), 187, "???", "cl"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(digest)), 0)) { tor_assertion_failed_(("routerlist.c"), 188, "???", "digest"); abort(); } });


  if (!(cl->dl_status_map)) {
    cl->dl_status_map = dsmap_new();
  }

  dlstatus = dsmap_get(cl->dl_status_map, digest);

  if (dlstatus) {

    rv = download_status_is_ready(dlstatus, now, max_failures);
  } else {





    dlstatus = tor_malloc_zero_(sizeof(*dlstatus) );
    download_status_reset(dlstatus);
    dsmap_set(cl->dl_status_map, digest, dlstatus);
    rv = 1;
  }

  return rv;
}



static cert_list_t *
get_cert_list(const char *id_digest)
{
  cert_list_t *cl;
  if (!trusted_dir_certs)
    trusted_dir_certs = digestmap_new();
  cl = digestmap_get(trusted_dir_certs, id_digest);
  if (!cl) {
    cl = tor_malloc_zero_(sizeof(cert_list_t) );
    cl->dl_status_by_id.schedule = DL_SCHED_CONSENSUS;
    cl->certs = smartlist_new();
    cl->dl_status_map = dsmap_new();
    digestmap_set(trusted_dir_certs, id_digest, cl);
  }
  return cl;
}


static void
cert_list_free(cert_list_t *cl)
{
  if (!cl)
    return;

  (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; { authority_cert_free(cert); } cert = ((void *)0); } })
                                              ;
  smartlist_free(cl->certs);
  dsmap_free(cl->dl_status_map, tor_free_);
  (void) ({ if (__builtin_expect(!!((cl)!=((void *)0)), 1)) { free(cl); (cl)=((void *)0); } });
}


static void
cert_list_free_(void *cl)
{
  cert_list_free(cl);
}



int
trusted_dirs_reload_certs(void)
{
  char *filename;
  char *contents;
  int r;

  filename = options_get_datadir_fname2_suffix(get_options(), (("cached-certs")), (((void *)0)), (((void *)0)));
  contents = read_file_to_str(filename, 2, ((void *)0));
  (void) ({ if (__builtin_expect(!!((filename)!=((void *)0)), 1)) { free(filename); (filename)=((void *)0); } });
  if (!contents)
    return 0;
  r = trusted_dirs_load_certs_from_string(
        contents,
        1, 1);
  (void) ({ if (__builtin_expect(!!((contents)!=((void *)0)), 1)) { free(contents); (contents)=((void *)0); } });
  return r;
}



static inline int
already_have_cert(authority_cert_t *cert)
{
  cert_list_t *cl = get_cert_list(cert->cache_info.identity_digest);

  (void) ({ int c_sl_idx, c_sl_len=(cl->certs)->num_used; authority_cert_t * c; for (c_sl_idx = 0; c_sl_idx < c_sl_len; ++c_sl_idx) { c = (cl->certs)->list[c_sl_idx]; { { if (tor_memeq(c->cache_info.signed_descriptor_digest, cert->cache_info.signed_descriptor_digest, 20)) return 1; }; } c = ((void *)0); } })





    ;
  return 0;
}
# 303 "routerlist.c"
int
trusted_dirs_load_certs_from_string(const char *contents, int source,
                                    int flush)
{
  dir_server_t *ds;
  const char *s, *eos;
  int failure_code = 0;
  int from_store = (source == 1);

  for (s = contents; *s; s = eos) {
    authority_cert_t *cert = authority_cert_parse_from_string(s, &eos);
    cert_list_t *cl;
    if (!cert) {
      failure_code = -1;
      break;
    }
    ds = trusteddirserver_get_by_v3_auth_digest(
                                       cert->cache_info.identity_digest);
    (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<13), __PRETTY_FUNCTION__, "Parsed certificate for %s", ds ? ds->nickname : "unknown authority"); })
                                                      ;

    if (already_have_cert(cert)) {

      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Skipping %s certificate for %s that we " "already have.", from_store ? "cached" : "downloaded", ds ? ds->nickname : "an old or new authority")


                                                             ;
# 338 "routerlist.c"
      if (!from_store) {
        if (authdir_mode(get_options())) {
          log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "Got a certificate for %s, but we already have it. " "Maybe they haven't updated it. Waiting for a while.", ds ? ds->nickname : "an old or new authority")


                                                                 ;
        } else {
          log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Got a certificate for %s, but we already have it. " "Maybe they haven't updated it. Waiting for a while.", ds ? ds->nickname : "an old or new authority")


                                                                 ;
        }






        if (source == 2) {
          authority_cert_dl_failed(cert->cache_info.identity_digest,
                                   ((void *)0), 404);
        } else if (source == 3) {
          authority_cert_dl_failed(cert->cache_info.identity_digest,
                                   cert->signing_key_digest, 404);
        }
      }

      authority_cert_free(cert);
      continue;
    }

    if (ds) {
      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Adding %s certificate for directory authority %s with " "signing key %s", from_store ? "cached" : "downloaded", ds->nickname, hex_str(cert->signing_key_digest,20))

                                                                          ;
    } else {
      int adding = directory_caches_unknown_auth_certs(get_options());
      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "%s %s certificate for unrecognized directory " "authority with signing key %s", adding ? "Adding" : "Not adding", from_store ? "cached" : "downloaded", hex_str(cert->signing_key_digest,20))



                                                            ;
      if (!adding) {
        authority_cert_free(cert);
        continue;
      }
    }

    cl = get_cert_list(cert->cache_info.identity_digest);
    smartlist_add(cl->certs, cert);
    if (ds && cert->cache_info.published_on > ds->addr_current_at) {


      if (cert->addr && cert->dir_port &&
          (ds->addr != cert->addr ||
           ds->dir_port != cert->dir_port)) {
        char *a = tor_dup_ip(cert->addr);
        log_fn_(5, (1u<<13), __PRETTY_FUNCTION__, "Updating address for directory authority %s " "from %s:%d to %s:%d based on certificate.", ds->nickname, ds->address, (int)ds->dir_port, a, cert->dir_port)


                                     ;
        (void) ({ if (__builtin_expect(!!((a)!=((void *)0)), 1)) { free(a); (a)=((void *)0); } });
        ds->addr = cert->addr;
        ds->dir_port = cert->dir_port;
      }
      ds->addr_current_at = cert->cache_info.published_on;
    }

    if (!from_store)
      trusted_dir_servers_certs_changed = 1;
  }

  if (flush)
    trusted_dirs_flush_certs_to_disk();



  networkstatus_note_certs_arrived();

  return failure_code;
}


void
trusted_dirs_flush_certs_to_disk(void)
{
  char *filename;
  smartlist_t *chunks;

  if (!trusted_dir_servers_certs_changed || !trusted_dir_certs)
    return;

  chunks = smartlist_new();
  (void) ({ digestmap_iter_t *key_iter; for (key_iter = digestmap_iter_init(trusted_dir_certs); !digestmap_iter_done(key_iter); key_iter = digestmap_iter_next(trusted_dir_certs, key_iter)) { const char * key; void *cl_voidp; cert_list_t * cl; digestmap_iter_get(key_iter, &key, &cl_voidp); cl = cl_voidp; {
    (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; { { sized_chunk_t *c = tor_malloc_(sizeof(sized_chunk_t) ); c->bytes = cert->cache_info.signed_descriptor_body; c->len = cert->cache_info.signed_descriptor_len; smartlist_add(chunks, c); }; } cert = ((void *)0); } })





            ;
  } } }) ;;

  filename = options_get_datadir_fname2_suffix(get_options(), (("cached-certs")), (((void *)0)), (((void *)0)));
  if (write_chunks_to_file(filename, chunks, 0, 0)) {
    log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Error writing certificates to disk.");
  }
  (void) ({ if (__builtin_expect(!!((filename)!=((void *)0)), 1)) { free(filename); (filename)=((void *)0); } });
  (void) ({ int c_sl_idx, c_sl_len=(chunks)->num_used; sized_chunk_t * c; for (c_sl_idx = 0; c_sl_idx < c_sl_len; ++c_sl_idx) { c = (chunks)->list[c_sl_idx]; { (void) ({ if (__builtin_expect(!!((c)!=((void *)0)), 1)) { free(c); (c)=((void *)0); } }); } c = ((void *)0); } });
  smartlist_free(chunks);

  trusted_dir_servers_certs_changed = 0;
}

static int
compare_certs_by_pubdates(const void **_a, const void **_b)
{
  const authority_cert_t *cert1 = *_a, *cert2=*_b;

  if (cert1->cache_info.published_on < cert2->cache_info.published_on)
    return -1;
  else if (cert1->cache_info.published_on > cert2->cache_info.published_on)
    return 1;
  else
    return 0;
}






static void
trusted_dirs_remove_old_certs(void)
{
  time_t now = time(((void *)0));


  if (!trusted_dir_certs)
    return;

  (void) ({ digestmap_iter_t *key_iter; for (key_iter = digestmap_iter_init(trusted_dir_certs); !digestmap_iter_done(key_iter); key_iter = digestmap_iter_next(trusted_dir_certs, key_iter)) { const char * key; void *cl_voidp; cert_list_t * cl; digestmap_iter_get(key_iter, &key, &cl_voidp); cl = cl_voidp; {

    smartlist_sort(cl->certs, compare_certs_by_pubdates);

    (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; {
      if (cert_sl_idx == ((cl->certs)->num_used) - 1) {

        continue;
      }
      authority_cert_t *next_cert = ((cl->certs)->list[cert_sl_idx+1]);
      const time_t next_cert_published = next_cert->cache_info.published_on;
      if (next_cert_published > now) {


        break;
      }
      int should_remove = 0;
      if (cert->expires + (2*24*60*60) < now) {


        should_remove = 1;
      } else if (next_cert_published + (2*24*60*60) < now) {



        should_remove = 1;
      }
      if (should_remove) {
        (void) ({ smartlist_del_keeporder(cl->certs, cert_sl_idx); --cert_sl_idx; --cert_sl_len; });
        authority_cert_free(cert);
        trusted_dir_servers_certs_changed = 1;
      }
    } cert = ((void *)0); } });

  } } }) ;;



  trusted_dirs_flush_certs_to_disk();
}




authority_cert_t *
authority_cert_get_newest_by_id(const char *id_digest)
{
  cert_list_t *cl;
  authority_cert_t *best = ((void *)0);
  if (!trusted_dir_certs ||
      !(cl = digestmap_get(trusted_dir_certs, id_digest)))
    return ((void *)0);

  (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; { { if (!best || cert->cache_info.published_on > best->cache_info.published_on) best = cert; }; } cert = ((void *)0); } })



    ;
  return best;
}




authority_cert_t *
authority_cert_get_by_sk_digest(const char *sk_digest)
{
  authority_cert_t *c;
  if (!trusted_dir_certs)
    return ((void *)0);

  if ((c = get_my_v3_authority_cert()) &&
      tor_memeq(c->signing_key_digest, sk_digest, 20))
    return c;
  if ((c = get_my_v3_legacy_cert()) &&
      tor_memeq(c->signing_key_digest, sk_digest, 20))
    return c;

  (void) ({ digestmap_iter_t *key_iter; for (key_iter = digestmap_iter_init(trusted_dir_certs); !digestmap_iter_done(key_iter); key_iter = digestmap_iter_next(trusted_dir_certs, key_iter)) { const char * key; void *cl_voidp; cert_list_t * cl; digestmap_iter_get(key_iter, &key, &cl_voidp); cl = cl_voidp; {
    (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; { { if (tor_memeq(cert->signing_key_digest, sk_digest, 20)) return cert; }; } cert = ((void *)0); } })



      ;
  } } }) ;;
  return ((void *)0);
}




authority_cert_t *
authority_cert_get_by_digests(const char *id_digest,
                              const char *sk_digest)
{
  cert_list_t *cl;
  if (!trusted_dir_certs ||
      !(cl = digestmap_get(trusted_dir_certs, id_digest)))
    return ((void *)0);
  (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; { if (tor_memeq(cert->signing_key_digest, sk_digest, 20)) return cert;; } cert = ((void *)0); } })

                    ;

  return ((void *)0);
}


void
authority_cert_get_all(smartlist_t *certs_out)
{
  (void) ({ if (__builtin_expect(!!(!(certs_out)), 0)) { tor_assertion_failed_(("routerlist.c"), 589, "???", "certs_out"); abort(); } });
  if (!trusted_dir_certs)
    return;

  (void) ({ digestmap_iter_t *key_iter; for (key_iter = digestmap_iter_init(trusted_dir_certs); !digestmap_iter_done(key_iter); key_iter = digestmap_iter_next(trusted_dir_certs, key_iter)) { const char * key; void *cl_voidp; cert_list_t * cl; digestmap_iter_get(key_iter, &key, &cl_voidp); cl = cl_voidp; {
    (void) ({ int c_sl_idx, c_sl_len=(cl->certs)->num_used; authority_cert_t * c; for (c_sl_idx = 0; c_sl_idx < c_sl_len; ++c_sl_idx) { c = (cl->certs)->list[c_sl_idx]; { smartlist_add(certs_out, c); } c = ((void *)0); } })
                                                  ;
  } } }) ;;
}





void
authority_cert_dl_failed(const char *id_digest,
                         const char *signing_key_digest, int status)
{
  cert_list_t *cl;
  download_status_t *dlstatus = ((void *)0);
  char id_digest_str[2*20 +1];
  char sk_digest_str[2*20 +1];

  if (!trusted_dir_certs ||
      !(cl = digestmap_get(trusted_dir_certs, id_digest)))
    return;





  if (!signing_key_digest) {

    download_status_increment_failure((&cl->dl_status_by_id), (status), ((void *)0), get_options()->DirPort_set, time(((void *)0)));
  } else {




    dlstatus = dsmap_get(cl->dl_status_map, signing_key_digest);

    if (dlstatus) {
      download_status_increment_failure((dlstatus), (status), ((void *)0), get_options()->DirPort_set, time(((void *)0)));
    } else {




      base16_encode(id_digest_str, sizeof(id_digest_str),
                    id_digest, 20);
      base16_encode(sk_digest_str, sizeof(sk_digest_str),
                    signing_key_digest, 20);
      log_fn_(4, (1u<<12), __PRETTY_FUNCTION__, "Got failure for cert fetch with (fp,sk) = (%s,%s), with " "status %d, but knew nothing about the download.", id_digest_str, sk_digest_str, status)


                                                    ;
    }
  }
}

static const char *BAD_SIGNING_KEYS[] = {
  "09CD84F751FD6E955E0F8ADB497D5401470D697E",
  "0E7E9C07F0969D0468AD741E172A6109DC289F3C",
  "57B85409891D3FB32137F642FDEDF8B7F8CDFDCD",
  "87326329007AF781F587AF5B594E540B2B6C7630",
  "98CC82342DE8D298CF99D3F1A396475901E0D38E",
  "9904B52336713A5ADCB13E4FB14DC919E0D45571",
  "9DCD8E3F1DD1597E2AD476BBA28A1A89F3095227",
  "A61682F34B9BB9694AC98491FE1ABBFE61923941",
  "B59F6E99C575113650C99F1C425BA7B20A8C071D",
  "D27178388FA75B96D37FA36E0B015227DDDBDA51",
  ((void *)0),
};


int
authority_cert_is_blacklisted(const authority_cert_t *cert)
{
  char hex_digest[40 +1];
  int i;
  base16_encode(hex_digest, sizeof(hex_digest),
                cert->signing_key_digest, sizeof(cert->signing_key_digest));

  for (i = 0; BAD_SIGNING_KEYS[i]; ++i) {
    if (!strcasecmp(hex_digest, BAD_SIGNING_KEYS[i])) {
      return 1;
    }
  }
  return 0;
}




int
authority_cert_dl_looks_uncertain(const char *id_digest)
{

  cert_list_t *cl;
  int n_failures;
  if (!trusted_dir_certs ||
      !(cl = digestmap_get(trusted_dir_certs, id_digest)))
    return 0;

  n_failures = download_status_get_n_failures(&cl->dl_status_by_id);
  return n_failures >= 2;
}







void
authority_certs_fetch_missing(networkstatus_t *status, time_t now)
{





  digestmap_t *pending_id;
  fp_pair_map_t *pending_cert;
  authority_cert_t *cert;






  smartlist_t *missing_cert_digests, *missing_id_digests;
  char *resource = ((void *)0);
  cert_list_t *cl;
  const int cache = directory_caches_unknown_auth_certs(get_options());
  fp_pair_t *fp_tmp = ((void *)0);
  char id_digest_str[2*20 +1];
  char sk_digest_str[2*20 +1];

  if (should_delay_dir_fetches(get_options(), ((void *)0)))
    return;

  pending_cert = fp_pair_map_new();
  pending_id = digestmap_new();
  missing_cert_digests = smartlist_new();
  missing_id_digests = smartlist_new();





  list_pending_downloads(pending_id, ((void *)0),
                         15, "fp/");
  list_pending_fpsk_downloads(pending_cert);





  (void) ({ int ds_sl_idx, ds_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ds; for (ds_sl_idx = 0; ds_sl_idx < ds_sl_len; ++ds_sl_idx) { ds = (trusted_dir_servers)->list[ds_sl_idx]; {
    int found = 0;
    if (!(ds->type & V3_DIRINFO))
      continue;
    if (smartlist_contains_digest(missing_id_digests,
                                  ds->v3_identity_digest))
      continue;
    cl = get_cert_list(ds->v3_identity_digest);
    (void) ({ int cert_sl_idx, cert_sl_len=(cl->certs)->num_used; authority_cert_t * cert; for (cert_sl_idx = 0; cert_sl_idx < cert_sl_len; ++cert_sl_idx) { cert = (cl->certs)->list[cert_sl_idx]; {
      if (now < cert->expires) {


        download_status_reset(&(cl->dl_status_by_id));

        download_status_reset_by_sk_in_cl(cl, cert->signing_key_digest);
        found = 1;
        break;
      }
    } cert = ((void *)0); } });
    if (!found &&
        download_status_is_ready(&(cl->dl_status_by_id), now,
                                 get_options()->TestingCertMaxDownloadTries) &&
        !digestmap_get(pending_id, ds->v3_identity_digest)) {
      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "No current certificate known for authority %s " "(ID digest %s); launching request.", ds->nickname, hex_str(ds->v3_identity_digest, 20))


                                                                         ;
      smartlist_add(missing_id_digests, ds->v3_identity_digest);
    }
  } ds = ((void *)0); } });
# 789 "routerlist.c"
  if (status) {
    (void) ({ int voter_sl_idx, voter_sl_len=(status->voters)->num_used; networkstatus_voter_info_t * voter; for (voter_sl_idx = 0; voter_sl_idx < voter_sl_len; ++voter_sl_idx) { voter = (status->voters)->list[voter_sl_idx];
                                   {
      if (!((voter->sigs)->num_used))
        continue;

      if (!cache &&
          !trusteddirserver_get_by_v3_auth_digest(voter->identity_digest))
        continue;






      cl = get_cert_list(voter->identity_digest);
      if (((cl->certs)->num_used) == 0) {



        if (digestmap_get(pending_id, voter->identity_digest))
          continue;





        if (smartlist_contains_digest(missing_id_digests,
                                      voter->identity_digest))
          continue;
      }

      (void) ({ int sig_sl_idx, sig_sl_len=(voter->sigs)->num_used; document_signature_t * sig; for (sig_sl_idx = 0; sig_sl_idx < sig_sl_len; ++sig_sl_idx) { sig = (voter->sigs)->list[sig_sl_idx]; {
        cert = authority_cert_get_by_digests(voter->identity_digest,
                                             sig->signing_key_digest);
        if (cert) {
          if (now < cert->expires)
            download_status_reset_by_sk_in_cl(cl, sig->signing_key_digest);
          continue;
        }
        if (download_status_is_ready_by_sk_in_cl(
              cl, sig->signing_key_digest,
              now, get_options()->TestingCertMaxDownloadTries) &&
            !fp_pair_map_get_by_digests(pending_cert,
                                        voter->identity_digest,
                                        sig->signing_key_digest)) {




          base16_encode(id_digest_str, sizeof(id_digest_str),
                        voter->identity_digest, 20);
          base16_encode(sk_digest_str, sizeof(sk_digest_str),
                        sig->signing_key_digest, 20);

          if (voter->nickname) {
            log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "We're missing a certificate from authority %s " "(ID digest %s) with signing key %s: " "launching request.", voter->nickname, id_digest_str, sk_digest_str)



                                                                   ;
          } else {
            log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "We're missing a certificate from authority ID digest " "%s with signing key %s: launching request.", id_digest_str, sk_digest_str)


                                                  ;
          }


          fp_tmp = tor_malloc_(sizeof(*fp_tmp) );
          memcpy(fp_tmp->first, voter->identity_digest, sizeof(fp_tmp->first));
          memcpy(fp_tmp->second, sig->signing_key_digest,
                 sizeof(fp_tmp->second));
          smartlist_add(missing_cert_digests, fp_tmp);
        }
      } sig = ((void *)0); } });
    } voter = ((void *)0); } });
  }


  if (((missing_id_digests)->num_used) > 0) {
    int need_plus = 0;
    smartlist_t *fps = smartlist_new();

    smartlist_add(fps, tor_strdup_("fp/" ));

    (void) ({ int d_sl_idx, d_sl_len=(missing_id_digests)->num_used; const char * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (missing_id_digests)->list[d_sl_idx]; {
      char *fp = ((void *)0);

      if (digestmap_get(pending_id, d))
        continue;

      base16_encode(id_digest_str, sizeof(id_digest_str),
                    d, 20);

      if (need_plus) {
        tor_asprintf(&fp, "+%s", id_digest_str);
      } else {

        fp = tor_strdup_(id_digest_str );
        need_plus = 1;
      }

      smartlist_add(fps, fp);
    } d = ((void *)0); } });

    if (((fps)->num_used) > 1) {
      resource = smartlist_join_strings(fps, "", 0, ((void *)0));
      directory_get_from_dirserver(15, 0,
                                   resource, (1<<1));
      (void) ({ if (__builtin_expect(!!((resource)!=((void *)0)), 1)) { free(resource); (resource)=((void *)0); } });
    }


    (void) ({ int cp_sl_idx, cp_sl_len=(fps)->num_used; char * cp; for (cp_sl_idx = 0; cp_sl_idx < cp_sl_len; ++cp_sl_idx) { cp = (fps)->list[cp_sl_idx]; { (void) ({ if (__builtin_expect(!!((cp)!=((void *)0)), 1)) { free(cp); (cp)=((void *)0); } }); } cp = ((void *)0); } });
    smartlist_free(fps);
  }


  if (((missing_cert_digests)->num_used) > 0) {
    int need_plus = 0;
    smartlist_t *fp_pairs = smartlist_new();

    smartlist_add(fp_pairs, tor_strdup_("fp-sk/" ));

    (void) ({ int d_sl_idx, d_sl_len=(missing_cert_digests)->num_used; const fp_pair_t * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (missing_cert_digests)->list[d_sl_idx]; {
      char *fp_pair = ((void *)0);

      if (fp_pair_map_get(pending_cert, d))
        continue;


      base16_encode(id_digest_str, sizeof(id_digest_str),
                    d->first, 20);
      base16_encode(sk_digest_str, sizeof(sk_digest_str),
                    d->second, 20);


      if (need_plus) {
        tor_asprintf(&fp_pair, "+%s-%s", id_digest_str, sk_digest_str);
      } else {

        tor_asprintf(&fp_pair, "%s-%s", id_digest_str, sk_digest_str);
        need_plus = 1;
      }


      smartlist_add(fp_pairs, fp_pair);
    } d = ((void *)0); } });

    if (((fp_pairs)->num_used) > 1) {
      resource = smartlist_join_strings(fp_pairs, "", 0, ((void *)0));
      directory_get_from_dirserver(15, 0,
                                   resource, (1<<1));
      (void) ({ if (__builtin_expect(!!((resource)!=((void *)0)), 1)) { free(resource); (resource)=((void *)0); } });
    }


    (void) ({ int p_sl_idx, p_sl_len=(fp_pairs)->num_used; char * p; for (p_sl_idx = 0; p_sl_idx < p_sl_len; ++p_sl_idx) { p = (fp_pairs)->list[p_sl_idx]; { (void) ({ if (__builtin_expect(!!((p)!=((void *)0)), 1)) { free(p); (p)=((void *)0); } }); } p = ((void *)0); } });
    smartlist_free(fp_pairs);
  }

  smartlist_free(missing_id_digests);
  (void) ({ int p_sl_idx, p_sl_len=(missing_cert_digests)->num_used; fp_pair_t * p; for (p_sl_idx = 0; p_sl_idx < p_sl_len; ++p_sl_idx) { p = (missing_cert_digests)->list[p_sl_idx]; { (void) ({ if (__builtin_expect(!!((p)!=((void *)0)), 1)) { free(p); (p)=((void *)0); } }); } p = ((void *)0); } });
  smartlist_free(missing_cert_digests);
  digestmap_free(pending_id, ((void *)0));
  fp_pair_map_free(pending_cert, ((void *)0));
}
# 973 "routerlist.c"
static int
router_should_rebuild_store(desc_store_t *store)
{
  if (store->store_len > (1<<16))
    return (store->journal_len > store->store_len / 2 ||
            store->bytes_dropped > store->store_len / 2);
  else
    return store->journal_len > (1<<15);
}



static inline desc_store_t *
desc_get_store(routerlist_t *rl, const signed_descriptor_t *sd)
{
  if (sd->is_extrainfo)
    return &rl->extrainfo_store;
  else
    return &rl->desc_store;
}




static int
signed_desc_append_to_journal(signed_descriptor_t *desc,
                              desc_store_t *store)
{
  char *fname = options_get_datadir_fname2_suffix(get_options(), ((store->fname_base)), (((void *)0)), ((".new")));
  const char *body = signed_descriptor_get_body_impl(desc,1);
  size_t len = desc->signed_descriptor_len + desc->annotations_len;

  if (append_bytes_to_file(fname, body, len, 1)) {
    log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Unable to store router descriptor");
    (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });
    return -1;
  }
  desc->saved_location = SAVED_IN_JOURNAL;
  (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });

  desc->saved_offset = store->journal_len;
  store->journal_len += len;

  return 0;
}




static int
compare_signed_descriptors_by_age_(const void **_a, const void **_b)
{
  const signed_descriptor_t *r1 = *_a, *r2 = *_b;
  return (int)(r1->published_on - r2->published_on);
}
# 1038 "routerlist.c"
static int
router_rebuild_store(int flags, desc_store_t *store)
{
  smartlist_t *chunk_list = ((void *)0);
  char *fname = ((void *)0), *fname_tmp = ((void *)0);
  int r = -1;
  off_t offset = 0;
  smartlist_t *signed_descriptors = ((void *)0);
  int nocache=0;
  size_t total_expected_len = 0;
  int had_any;
  int force = flags & 1;

  if (!force && !router_should_rebuild_store(store)) {
    r = 0;
    goto done;
  }
  if (!routerlist) {
    r = 0;
    goto done;
  }

  if (store->type == EXTRAINFO_STORE)
    had_any = !eimap_isempty(routerlist->extra_info_map);
  else
    had_any = (((routerlist->routers)->num_used)+
               ((routerlist->old_routers)->num_used))>0;


  if (!(flags & 2))
    routerlist_remove_old_routers();

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Rebuilding %s cache", store->description);

  fname = options_get_datadir_fname2_suffix(get_options(), ((store->fname_base)), (((void *)0)), (((void *)0)));
  fname_tmp = options_get_datadir_fname2_suffix(get_options(), ((store->fname_base)), (((void *)0)), ((".tmp")));

  chunk_list = smartlist_new();


  signed_descriptors = smartlist_new();
  if (store->type == EXTRAINFO_STORE) {
    eimap_iter_t *iter;
    for (iter = eimap_iter_init(routerlist->extra_info_map);
         !eimap_iter_done(iter);
         iter = eimap_iter_next(routerlist->extra_info_map, iter)) {
      const char *key;
      extrainfo_t *ei;
      eimap_iter_get(iter, &key, &ei);
      smartlist_add(signed_descriptors, &ei->cache_info);
    }
  } else {
    (void) ({ int sd_sl_idx, sd_sl_len=(routerlist->old_routers)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (routerlist->old_routers)->list[sd_sl_idx]; { smartlist_add(signed_descriptors, sd); } sd = ((void *)0); } })
                                                            ;
    (void) ({ int ri_sl_idx, ri_sl_len=(routerlist->routers)->num_used; routerinfo_t * ri; for (ri_sl_idx = 0; ri_sl_idx < ri_sl_len; ++ri_sl_idx) { ri = (routerlist->routers)->list[ri_sl_idx]; { smartlist_add(signed_descriptors, &ri->cache_info); } ri = ((void *)0); } })
                                                                         ;
  }

  smartlist_sort(signed_descriptors, compare_signed_descriptors_by_age_);


  (void) ({ int sd_sl_idx, sd_sl_len=(signed_descriptors)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (signed_descriptors)->list[sd_sl_idx]; {
      sized_chunk_t *c;
      const char *body = signed_descriptor_get_body_impl(sd, 1);
      if (!body) {
        log_fn_(4, (1u<<12), __PRETTY_FUNCTION__, "No descriptor available for router.");
        goto done;
      }
      if (sd->do_not_cache) {
        ++nocache;
        continue;
      }
      c = tor_malloc_(sizeof(sized_chunk_t) );
      c->bytes = body;
      c->len = sd->signed_descriptor_len + sd->annotations_len;
      total_expected_len += c->len;
      smartlist_add(chunk_list, c);
  } sd = ((void *)0); } });

  if (write_chunks_to_file(fname_tmp, chunk_list, 1, 1)<0) {
    log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Error writing router store to disk.");
    goto done;
  }


  if (store->mmap) {
    int res = tor_munmap_file(store->mmap);
    store->mmap = ((void *)0);
    if (res != 0) {
      log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Unable to munmap route store in %s", fname);
    }
  }

  if (replace_file(fname_tmp, fname)<0) {
    log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Error replacing old router store: %s", strerror((*__errno_location ())));
    goto done;
  }

  (*__errno_location ()) = 0;
  store->mmap = tor_mmap_file(fname);
  if (! store->mmap) {
    if ((*__errno_location ()) == 34) {

      if (total_expected_len) {
        log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "We wrote some bytes to a new descriptor file at '%s'," " but when we went to mmap it, it was empty!", fname)
                                                                      ;
      } else if (had_any) {
        log_fn_(6, (1u<<4), __PRETTY_FUNCTION__, "We just removed every descriptor in '%s'.  This is " "okay if we're just starting up after a long time. " "Otherwise, it's a bug.", fname)

                                                 ;
      }
    } else {
      log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Unable to mmap new descriptor file at '%s'.",fname);
    }
  }

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Reconstructing pointers into cache");

  offset = 0;
  (void) ({ int sd_sl_idx, sd_sl_len=(signed_descriptors)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (signed_descriptors)->list[sd_sl_idx]; {
      if (sd->do_not_cache)
        continue;
      sd->saved_location = SAVED_IN_CACHE;
      if (store->mmap) {
        (void) ({ if (__builtin_expect(!!((sd->signed_descriptor_body)!=((void *)0)), 1)) { free(sd->signed_descriptor_body); (sd->signed_descriptor_body)=((void *)0); } });
        sd->saved_offset = offset;
      }
      offset += sd->signed_descriptor_len + sd->annotations_len;
      signed_descriptor_get_body(sd);
  } sd = ((void *)0); } });

  (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });
  fname = options_get_datadir_fname2_suffix(get_options(), ((store->fname_base)), (((void *)0)), ((".new")));
  write_str_to_file(fname, "", 1);

  r = 0;
  store->store_len = (size_t) offset;
  store->journal_len = 0;
  store->bytes_dropped = 0;
 done:
  smartlist_free(signed_descriptors);
  (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((fname_tmp)!=((void *)0)), 1)) { free(fname_tmp); (fname_tmp)=((void *)0); } });
  if (chunk_list) {
    (void) ({ int c_sl_idx, c_sl_len=(chunk_list)->num_used; sized_chunk_t * c; for (c_sl_idx = 0; c_sl_idx < c_sl_len; ++c_sl_idx) { c = (chunk_list)->list[c_sl_idx]; { (void) ({ if (__builtin_expect(!!((c)!=((void *)0)), 1)) { free(c); (c)=((void *)0); } }); } c = ((void *)0); } });
    smartlist_free(chunk_list);
  }

  return r;
}




static int
router_reload_router_list_impl(desc_store_t *store)
{
  char *fname = ((void *)0), *contents = ((void *)0);
  struct stat st;
  int extrainfo = (store->type == EXTRAINFO_STORE);
  store->journal_len = store->store_len = 0;

  fname = options_get_datadir_fname2_suffix(get_options(), ((store->fname_base)), (((void *)0)), (((void *)0)));

  if (store->mmap) {

    int res = tor_munmap_file(store->mmap);
    store->mmap = ((void *)0);
    if (res != 0) {
      log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Failed to munmap %s", fname);
      (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });
      return -1;
    }
  }

  store->mmap = tor_mmap_file(fname);
  if (store->mmap) {
    store->store_len = store->mmap->size;
    if (extrainfo)
      router_load_extrainfo_from_string(store->mmap->data,
                                        store->mmap->data+store->mmap->size,
                                        SAVED_IN_CACHE, ((void *)0), 0);
    else
      router_load_routers_from_string(store->mmap->data,
                                      store->mmap->data+store->mmap->size,
                                      SAVED_IN_CACHE, ((void *)0), 0, ((void *)0));
  }

  (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });
  fname = options_get_datadir_fname2_suffix(get_options(), ((store->fname_base)), (((void *)0)), ((".new")));

  if (file_status(fname) == FN_FILE)
    contents = read_file_to_str(fname, 1|2, &st);
  if (contents) {
    if (extrainfo)
      router_load_extrainfo_from_string(contents, ((void *)0),SAVED_IN_JOURNAL,
                                        ((void *)0), 0);
    else
      router_load_routers_from_string(contents, ((void *)0), SAVED_IN_JOURNAL,
                                      ((void *)0), 0, ((void *)0));
    store->journal_len = (size_t) st.st_size;
    (void) ({ if (__builtin_expect(!!((contents)!=((void *)0)), 1)) { free(contents); (contents)=((void *)0); } });
  }

  (void) ({ if (__builtin_expect(!!((fname)!=((void *)0)), 1)) { free(fname); (fname)=((void *)0); } });

  if (store->journal_len) {

    router_rebuild_store(1, store);
  } else if (!extrainfo) {


    routerlist_remove_old_routers();
  }

  return 0;
}




int
router_reload_router_list(void)
{
  routerlist_t *rl = router_get_routerlist();
  if (router_reload_router_list_impl(&rl->desc_store))
    return -1;
  if (router_reload_router_list_impl(&rl->extrainfo_store))
    return -1;
  return 0;
}





const smartlist_t *
router_get_trusted_dir_servers(void)
{
  if (!trusted_dir_servers)
    trusted_dir_servers = smartlist_new();

  return trusted_dir_servers;
}

const smartlist_t *
router_get_fallback_dir_servers(void)
{
  if (!fallback_dir_servers)
    fallback_dir_servers = smartlist_new();

  return fallback_dir_servers;
}
# 1307 "routerlist.c"
const routerstatus_t *
router_pick_directory_server(dirinfo_type_t type, int flags)
{
  int busy = 0;
  const routerstatus_t *choice;

  if (!routerlist)
    return ((void *)0);

  choice = router_pick_directory_server_impl(type, flags, &busy);
  if (choice || !(flags & (1<<1)))
    return choice;

  if (busy) {



    (void) ({ if (__builtin_expect(!!(!((flags & ((1<<3)| (1<<4))))), 0)) { tor_assertion_failed_((
 "routerlist.c"
# 1324 "routerlist.c"
    ),
 1325
# 1324 "routerlist.c"
    , "???", "(flags & (PDS_NO_EXISTING_SERVERDESC_FETCH| PDS_NO_EXISTING_MICRODESC_FETCH))"); abort(); } })
                                                           ;
    return ((void *)0);
  }

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "No reachable router entries for dirservers. " "Trying them all again.")

                                    ;

  mark_all_dirservers_up(fallback_dir_servers);

  choice = router_pick_directory_server_impl(type, flags, ((void *)0));
  return choice;
}




dir_server_t *
router_get_trusteddirserver_by_digest(const char *digest)
{
  if (!trusted_dir_servers)
    return ((void *)0);

  (void) ({ int ds_sl_idx, ds_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ds; for (ds_sl_idx = 0; ds_sl_idx < ds_sl_len; ++ds_sl_idx) { ds = (trusted_dir_servers)->list[ds_sl_idx]; { { if (tor_memeq(ds->digest, digest, 20)) return ds; }; } ds = ((void *)0); } })



       ;

  return ((void *)0);
}




dir_server_t *
router_get_fallback_dirserver_by_digest(const char *digest)
{
  if (!trusted_dir_servers)
    return ((void *)0);

  (void) ({ int ds_sl_idx, ds_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ds; for (ds_sl_idx = 0; ds_sl_idx < ds_sl_len; ++ds_sl_idx) { ds = (trusted_dir_servers)->list[ds_sl_idx]; { { if (tor_memeq(ds->digest, digest, 20)) return ds; }; } ds = ((void *)0); } })



       ;

  return ((void *)0);
}





dir_server_t *
trusteddirserver_get_by_v3_auth_digest(const char *digest)
{
  if (!trusted_dir_servers)
    return ((void *)0);

  (void) ({ int ds_sl_idx, ds_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ds; for (ds_sl_idx = 0; ds_sl_idx < ds_sl_len; ++ds_sl_idx) { ds = (trusted_dir_servers)->list[ds_sl_idx]; { { if (tor_memeq(ds->v3_identity_digest, digest, 20) && (ds->type & V3_DIRINFO)) return ds; }; } ds = ((void *)0); } })




       ;

  return ((void *)0);
}




const routerstatus_t *
router_pick_trusteddirserver(dirinfo_type_t type, int flags)
{
  return router_pick_dirserver_generic(trusted_dir_servers, type, flags);
}




const routerstatus_t *
router_pick_fallback_dirserver(dirinfo_type_t type, int flags)
{
  return router_pick_dirserver_generic(fallback_dir_servers, type, flags);
}




static const routerstatus_t *
router_pick_dirserver_generic(smartlist_t *sourcelist,
                              dirinfo_type_t type, int flags)
{
  const routerstatus_t *choice;
  int busy = 0;

  choice = router_pick_trusteddirserver_impl(sourcelist, type, flags, &busy);
  if (choice || !(flags & (1<<1)))
    return choice;
  if (busy) {



    (void) ({ if (__builtin_expect(!!(!((flags & ((1<<3)| (1<<4))))), 0)) { tor_assertion_failed_((
 "routerlist.c"
# 1430 "routerlist.c"
    ),
 1431
# 1430 "routerlist.c"
    , "???", "(flags & (PDS_NO_EXISTING_SERVERDESC_FETCH| PDS_NO_EXISTING_MICRODESC_FETCH))"); abort(); } })
                                                           ;
    return ((void *)0);
  }

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "No dirservers are reachable. Trying them all again.")
                                                                 ;
  mark_all_dirservers_up(sourcelist);
  return router_pick_trusteddirserver_impl(sourcelist, type, flags, ((void *)0));
}
# 1451 "routerlist.c"
static const routerstatus_t *
router_pick_directory_server_impl(dirinfo_type_t type, int flags,
                                  int *n_busy_out)
{
  const or_options_t *options = get_options();
  const node_t *result;
  smartlist_t *direct, *tunnel;
  smartlist_t *trusted_direct, *trusted_tunnel;
  smartlist_t *overloaded_direct, *overloaded_tunnel;
  time_t now = time(((void *)0));
  const networkstatus_t *consensus = networkstatus_get_latest_consensus();
  const int requireother = ! (flags & (1<<0));
  const int fascistfirewall = ! (flags & (1<<2));
  const int no_serverdesc_fetching =(flags & (1<<3));
  const int no_microdesc_fetching = (flags & (1<<4));
  const int for_guard = (flags & (1<<5));
  int try_excluding = 1, n_excluded = 0, n_busy = 0;

  if (!consensus)
    return ((void *)0);

 retry_without_exclude:

  direct = smartlist_new();
  tunnel = smartlist_new();
  trusted_direct = smartlist_new();
  trusted_tunnel = smartlist_new();
  overloaded_direct = smartlist_new();
  overloaded_tunnel = smartlist_new();


  (void) ({ int node_sl_idx, node_sl_len=(nodelist_get_list())->num_used; const node_t * node; for (node_sl_idx = 0; node_sl_idx < node_sl_len; ++node_sl_idx) { node = (nodelist_get_list())->list[node_sl_idx]; {
    int is_trusted, is_trusted_extrainfo;
    int is_overloaded;
    tor_addr_t addr;
    const routerstatus_t *status = node->rs;
    const country_t country = node->country;
    if (!status)
      continue;

    if (!node->is_running || !status->dir_port || !node->is_valid)
      continue;
    if (requireother && router_digest_is_me(node->identity))
      continue;
    is_trusted = router_digest_is_trusted_dir_type((node->identity), NO_DIRINFO);
    is_trusted_extrainfo = router_digest_is_trusted_dir_type(
                           node->identity, EXTRAINFO_DIRINFO);
    if ((type & EXTRAINFO_DIRINFO) &&
        !router_supports_extrainfo(node->identity, is_trusted_extrainfo))
      continue;
    if ((type & MICRODESC_DIRINFO) && !is_trusted &&
        !node->rs->version_supports_microdesc_cache)
      continue;
    if (for_guard && node->using_as_guard)
      continue;
    if (try_excluding &&
        routerset_contains_routerstatus(options->ExcludeNodes, status,
                                        country)) {
      ++n_excluded;
      continue;
    }


    tor_addr_from_ipv4n((&addr), htonl(status->addr));

    if (no_serverdesc_fetching && (
       connection_get_by_type_addr_port_purpose(
         9, &addr, status->dir_port, 6)
    || connection_get_by_type_addr_port_purpose(
         9, &addr, status->dir_port, 7)
    )) {
      ++n_busy;
      continue;
    }

    if (no_microdesc_fetching && connection_get_by_type_addr_port_purpose(
      9, &addr, status->dir_port, 19)
    ) {
      ++n_busy;
      continue;
    }

    is_overloaded = status->last_dir_503_at + (60*60) > now;

    if ((!fascistfirewall ||
         fascist_firewall_allows_address_or(&addr, status->or_port)))
      smartlist_add(is_trusted ? trusted_tunnel :
                    is_overloaded ? overloaded_tunnel : tunnel, (void*)node);
    else if (!fascistfirewall ||
             fascist_firewall_allows_address_dir(&addr, status->dir_port))
      smartlist_add(is_trusted ? trusted_direct :
                    is_overloaded ? overloaded_direct : direct, (void*)node);
  } node = ((void *)0); } });

  if (((tunnel)->num_used)) {
    result = node_sl_choose_by_bandwidth(tunnel, WEIGHT_FOR_DIR);
  } else if (((overloaded_tunnel)->num_used)) {
    result = node_sl_choose_by_bandwidth(overloaded_tunnel,
                                                 WEIGHT_FOR_DIR);
  } else if (((trusted_tunnel)->num_used)) {




    result = smartlist_choose(trusted_tunnel);
  } else if (((direct)->num_used)) {
    result = node_sl_choose_by_bandwidth(direct, WEIGHT_FOR_DIR);
  } else if (((overloaded_direct)->num_used)) {
    result = node_sl_choose_by_bandwidth(overloaded_direct,
                                         WEIGHT_FOR_DIR);
  } else {
    result = smartlist_choose(trusted_direct);
  }
  smartlist_free(direct);
  smartlist_free(tunnel);
  smartlist_free(trusted_direct);
  smartlist_free(trusted_tunnel);
  smartlist_free(overloaded_direct);
  smartlist_free(overloaded_tunnel);

  if (result == ((void *)0) && try_excluding && !options->StrictNodes && n_excluded
      && !n_busy) {


    try_excluding = 0;
    n_excluded = 0;
    n_busy = 0;
    goto retry_without_exclude;
  }

  if (n_busy_out)
    *n_busy_out = n_busy;

  return result ? result->rs : ((void *)0);
}



static const dir_server_t *
dirserver_choose_by_weight(const smartlist_t *servers, double authority_weight)
{
  int n = ((servers)->num_used);
  int i;
  u64_dbl_t *weights;
  const dir_server_t *ds;

  weights = tor_calloc_(n, sizeof(u64_dbl_t) );
  for (i = 0; i < n; ++i) {
    ds = ((servers)->list[i]);
    weights[i].dbl = ds->weight;
    if (ds->is_authority)
      weights[i].dbl *= authority_weight;
  }

  scale_array_elements_to_u64(weights, n, ((void *)0));
  i = choose_array_element_by_weight(weights, n);
  (void) ({ if (__builtin_expect(!!((weights)!=((void *)0)), 1)) { free(weights); (weights)=((void *)0); } });
  return (i < 0) ? ((void *)0) : ((servers)->list[i]);
}




static const routerstatus_t *
router_pick_trusteddirserver_impl(const smartlist_t *sourcelist,
                                  dirinfo_type_t type, int flags,
                                  int *n_busy_out)
{
  const or_options_t *options = get_options();
  smartlist_t *direct, *tunnel;
  smartlist_t *overloaded_direct, *overloaded_tunnel;
  const routerinfo_t *me = router_get_my_routerinfo();
  const routerstatus_t *result = ((void *)0);
  time_t now = time(((void *)0));
  const int requireother = ! (flags & (1<<0));
  const int fascistfirewall = ! (flags & (1<<2));
  const int no_serverdesc_fetching =(flags & (1<<3));
  const int no_microdesc_fetching =(flags & (1<<4));
  const double auth_weight = (sourcelist == fallback_dir_servers) ?
    options->DirAuthorityFallbackRate : 1.0;
  smartlist_t *pick_from;
  int n_busy = 0;
  int try_excluding = 1, n_excluded = 0;

  if (!sourcelist)
    return ((void *)0);

 retry_without_exclude:

  direct = smartlist_new();
  tunnel = smartlist_new();
  overloaded_direct = smartlist_new();
  overloaded_tunnel = smartlist_new();

  (void) ({ int d_sl_idx, d_sl_len=(sourcelist)->num_used; const dir_server_t * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (sourcelist)->list[d_sl_idx];
    {
      int is_overloaded =
          d->fake_status.last_dir_503_at + (60*60) > now;
      tor_addr_t addr;
      if (!d->is_running) continue;
      if ((type & d->type) == 0)
        continue;
      if ((type & EXTRAINFO_DIRINFO) &&
          !router_supports_extrainfo(d->digest, 1))
        continue;
      if (requireother && me && router_digest_is_me(d->digest))
          continue;
      if (try_excluding &&
          routerset_contains_routerstatus(options->ExcludeNodes,
                                          &d->fake_status, -1)) {
        ++n_excluded;
        continue;
      }


      tor_addr_from_ipv4n((&addr), htonl(d->addr));

      if (no_serverdesc_fetching) {
        if (connection_get_by_type_addr_port_purpose(
            9, &addr, d->dir_port, 6)
         || connection_get_by_type_addr_port_purpose(
             9, &addr, d->dir_port, 7)) {


          ++n_busy;
          continue;
        }
      }
      if (no_microdesc_fetching) {
        if (connection_get_by_type_addr_port_purpose(
             9, &addr, d->dir_port, 19)) {
          ++n_busy;
          continue;
        }
      }

      if (d->or_port &&
          (!fascistfirewall ||
           fascist_firewall_allows_address_or(&addr, d->or_port)))
        smartlist_add(is_overloaded ? overloaded_tunnel : tunnel, (void*)d);
      else if (!fascistfirewall ||
               fascist_firewall_allows_address_dir(&addr, d->dir_port))
        smartlist_add(is_overloaded ? overloaded_direct : direct, (void*)d);
    }
  d = ((void *)0); } });

  if (((tunnel)->num_used)) {
    pick_from = tunnel;
  } else if (((overloaded_tunnel)->num_used)) {
    pick_from = overloaded_tunnel;
  } else if (((direct)->num_used)) {
    pick_from = direct;
  } else {
    pick_from = overloaded_direct;
  }

  {
    const dir_server_t *selection =
      dirserver_choose_by_weight(pick_from, auth_weight);

    if (selection)
      result = &selection->fake_status;
  }

  if (n_busy_out)
    *n_busy_out = n_busy;

  smartlist_free(direct);
  smartlist_free(tunnel);
  smartlist_free(overloaded_direct);
  smartlist_free(overloaded_tunnel);

  if (result == ((void *)0) && try_excluding && !options->StrictNodes && n_excluded) {


    try_excluding = 0;
    n_excluded = 0;
    goto retry_without_exclude;
  }

  return result;
}


static void
mark_all_dirservers_up(smartlist_t *server_list)
{
  if (server_list) {
    (void) ({ int dir_sl_idx, dir_sl_len=(server_list)->num_used; dir_server_t * dir; for (dir_sl_idx = 0; dir_sl_idx < dir_sl_len; ++dir_sl_idx) { dir = (server_list)->list[dir_sl_idx]; {
      routerstatus_t *rs;
      node_t *node;
      dir->is_running = 1;
      node = node_get_mutable_by_id(dir->digest);
      if (node)
        node->is_running = 1;
      rs = router_get_mutable_consensus_status_by_id(dir->digest);
      if (rs) {
        rs->last_dir_503_at = 0;
        control_event_networkstatus_changed_single(rs);
      }
    } dir = ((void *)0); } });
  }
  router_dir_info_changed();
}


int
routers_have_same_or_addrs(const routerinfo_t *r1, const routerinfo_t *r2)
{
  return r1->addr == r2->addr && r1->or_port == r2->or_port &&
    (0==tor_addr_compare((&r1->ipv6_addr),(&r2->ipv6_addr),CMP_EXACT)) &&
    r1->ipv6_orport == r2->ipv6_orport;
}



void
router_reset_status_download_failures(void)
{
  mark_all_dirservers_up(fallback_dir_servers);
}







static void
routerlist_add_node_and_family(smartlist_t *sl, const routerinfo_t *router)
{

  node_t fake_node;
  const node_t *node = node_get_by_id(router->cache_info.identity_digest);;
  if (node == ((void *)0)) {
    memset(&fake_node, 0, sizeof(fake_node));
    fake_node.ri = (routerinfo_t *)router;
    memcpy(fake_node.identity, router->cache_info.identity_digest, 20);
    node = &fake_node;
  }
  nodelist_add_node_and_family(sl, node);
}




void
router_add_running_nodes_to_smartlist(smartlist_t *sl, int allow_invalid,
                                      int need_uptime, int need_capacity,
                                      int need_guard, int need_desc)
{
  (void) ({ int node_sl_idx, node_sl_len=(nodelist_get_list())->num_used; const node_t * node; for (node_sl_idx = 0; node_sl_idx < node_sl_len; ++node_sl_idx) { node = (nodelist_get_list())->list[node_sl_idx]; {
    if (!node->is_running ||
        (!node->is_valid && !allow_invalid))
      continue;
    if (need_desc && !(node->ri || (node->rs && node->md)))
      continue;
    if (node->ri && node->ri->purpose != 0)
      continue;
    if (node_is_unreliable(node, need_uptime, need_capacity, need_guard))
      continue;

    smartlist_add(sl, (void *)node);
  } node = ((void *)0); } });
}



const routerinfo_t *
routerlist_find_my_routerinfo(void)
{
  if (!routerlist)
    return ((void *)0);

  (void) ({ int router_sl_idx, router_sl_len=(routerlist->routers)->num_used; routerinfo_t * router; for (router_sl_idx = 0; router_sl_idx < router_sl_len; ++router_sl_idx) { router = (routerlist->routers)->list[router_sl_idx]; { { if (router_is_me(router)) return router; }; } router = ((void *)0); } })



    ;
  return ((void *)0);
}



uint32_t
router_get_advertised_bandwidth(const routerinfo_t *router)
{
  if (router->bandwidthcapacity < router->bandwidthrate)
    return router->bandwidthcapacity;
  return router->bandwidthrate;
}







uint32_t
router_get_advertised_bandwidth_capped(const routerinfo_t *router)
{
  uint32_t result = router->bandwidthcapacity;
  if (result > router->bandwidthrate)
    result = router->bandwidthrate;
  if (result > 10000000)
    result = 10000000;
  return result;
}





static void
scale_array_elements_to_u64(u64_dbl_t *entries, int n_entries,
                            uint64_t *total_out)
{
  double total = 0.0;
  double scale_factor = 0.0;
  int i;



  for (i = 0; i < n_entries; ++i)
    total += entries[i].dbl;

  if (total > 0.0)
    scale_factor = ((int64_t) ((9223372036854775807L) / 4)) / total;

  for (i = 0; i < n_entries; ++i)
    entries[i].u64 = tor_llround(entries[i].dbl * scale_factor);

  if (total_out)
    *total_out = (uint64_t) total;


}






static inline int
gt_i64_timei(uint64_t a, uint64_t b)
{
  int64_t diff = (int64_t) (b - a);
  int res = diff >> 63;
  return res & 1;
}







static int
choose_array_element_by_weight(const u64_dbl_t *entries, int n_entries)
{
  int i, i_chosen=-1, n_chosen=0;
  uint64_t total_so_far = 0;
  uint64_t rand_val;
  uint64_t total = 0;

  for (i = 0; i < n_entries; ++i)
    total += entries[i].u64;

  if (n_entries < 1)
    return -1;

  if (total == 0)
    return crypto_rand_int(n_entries);

  (void) ({ if (__builtin_expect(!!(!(total < (9223372036854775807L))), 0)) { tor_assertion_failed_(("routerlist.c"), 1925, "???", "total < INT64_MAX"); abort(); } });

  rand_val = crypto_rand_uint64(total);

  for (i = 0; i < n_entries; ++i) {
    total_so_far += entries[i].u64;
    if (gt_i64_timei(total_so_far, rand_val)) {
      i_chosen = i;
      n_chosen++;


      rand_val = (9223372036854775807L);
    }
  }
  (void) ({ if (__builtin_expect(!!(!(total_so_far == total)), 0)) { tor_assertion_failed_(("routerlist.c"), 1939, "???", "total_so_far == total"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(n_chosen == 1)), 0)) { tor_assertion_failed_(("routerlist.c"), 1940, "???", "n_chosen == 1"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(i_chosen >= 0)), 0)) { tor_assertion_failed_(("routerlist.c"), 1941, "???", "i_chosen >= 0"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(i_chosen < n_entries)), 0)) { tor_assertion_failed_(("routerlist.c"), 1942, "???", "i_chosen < n_entries"); abort(); } });

  return i_chosen;
}
# 1957 "routerlist.c"
static uint32_t
bridge_get_advertised_bandwidth_bounded(routerinfo_t *router)
{
  uint32_t result = router->bandwidthcapacity;
  if (result > router->bandwidthrate)
    result = router->bandwidthrate;
  if (result > 100000)
    result = 100000;
  else if (result < 20000)
    result = 20000;
  return result;
}



static inline int32_t
kb_to_bytes(uint32_t bw)
{
  return (bw > ((2147483647)/1000)) ? (2147483647) : bw*1000;
}
# 1992 "routerlist.c"
static const node_t *
smartlist_choose_node_by_bandwidth_weights(const smartlist_t *sl,
                                           bandwidth_weight_rule_t rule)
{
  u64_dbl_t *bandwidths=((void *)0);

  if (compute_weighted_bandwidths(sl, rule, &bandwidths) < 0)
    return ((void *)0);

  scale_array_elements_to_u64(bandwidths, ((sl)->num_used), ((void *)0));

  {
    int idx = choose_array_element_by_weight(bandwidths,
                                             ((sl)->num_used));
    (void) ({ if (__builtin_expect(!!((bandwidths)!=((void *)0)), 1)) { free(bandwidths); (bandwidths)=((void *)0); } });
    return idx < 0 ? ((void *)0) : ((sl)->list[idx]);
  }
}






static int
compute_weighted_bandwidths(const smartlist_t *sl,
                            bandwidth_weight_rule_t rule,
                            u64_dbl_t **bandwidths_out)
{
  int64_t weight_scale;
  double Wg = -1, Wm = -1, We = -1, Wd = -1;
  double Wgb = -1, Wmb = -1, Web = -1, Wdb = -1;
  uint64_t weighted_bw = 0;
  guardfraction_bandwidth_t guardfraction_bw;
  u64_dbl_t *bandwidths;


  (void) ({ if (__builtin_expect(!!(!(rule == NO_WEIGHTING || rule == WEIGHT_FOR_EXIT || rule == WEIGHT_FOR_GUARD || rule == WEIGHT_FOR_MID || rule == WEIGHT_FOR_DIR)), 0)) { tor_assertion_failed_((



 "routerlist.c"
# 2029 "routerlist.c"
  ),



 2033
# 2029 "routerlist.c"
  , "???", "rule == NO_WEIGHTING || rule == WEIGHT_FOR_EXIT || rule == WEIGHT_FOR_GUARD || rule == WEIGHT_FOR_MID || rule == WEIGHT_FOR_DIR"); abort(); } })



                                    ;

  if (((sl)->num_used) == 0) {
    log_fn_(6, (1u<<10), __PRETTY_FUNCTION__, "Empty routerlist passed in to consensus weight node " "selection for rule %s", bandwidth_weight_rule_to_string(rule))


                                                   ;
    return -1;
  }

  weight_scale = networkstatus_get_weight_scale_param(((void *)0));

  if (rule == WEIGHT_FOR_GUARD) {
    Wg = networkstatus_get_bw_weight(((void *)0), "Wgg", -1);
    Wm = networkstatus_get_bw_weight(((void *)0), "Wgm", -1);
    We = 0;
    Wd = networkstatus_get_bw_weight(((void *)0), "Wgd", -1);

    Wgb = networkstatus_get_bw_weight(((void *)0), "Wgb", -1);
    Wmb = networkstatus_get_bw_weight(((void *)0), "Wmb", -1);
    Web = networkstatus_get_bw_weight(((void *)0), "Web", -1);
    Wdb = networkstatus_get_bw_weight(((void *)0), "Wdb", -1);
  } else if (rule == WEIGHT_FOR_MID) {
    Wg = networkstatus_get_bw_weight(((void *)0), "Wmg", -1);
    Wm = networkstatus_get_bw_weight(((void *)0), "Wmm", -1);
    We = networkstatus_get_bw_weight(((void *)0), "Wme", -1);
    Wd = networkstatus_get_bw_weight(((void *)0), "Wmd", -1);

    Wgb = networkstatus_get_bw_weight(((void *)0), "Wgb", -1);
    Wmb = networkstatus_get_bw_weight(((void *)0), "Wmb", -1);
    Web = networkstatus_get_bw_weight(((void *)0), "Web", -1);
    Wdb = networkstatus_get_bw_weight(((void *)0), "Wdb", -1);
  } else if (rule == WEIGHT_FOR_EXIT) {


    We = networkstatus_get_bw_weight(((void *)0), "Wee", -1);
    Wm = networkstatus_get_bw_weight(((void *)0), "Wem", -1);
    Wd = networkstatus_get_bw_weight(((void *)0), "Wed", -1);
    Wg = networkstatus_get_bw_weight(((void *)0), "Weg", -1);

    Wgb = networkstatus_get_bw_weight(((void *)0), "Wgb", -1);
    Wmb = networkstatus_get_bw_weight(((void *)0), "Wmb", -1);
    Web = networkstatus_get_bw_weight(((void *)0), "Web", -1);
    Wdb = networkstatus_get_bw_weight(((void *)0), "Wdb", -1);
  } else if (rule == WEIGHT_FOR_DIR) {
    We = networkstatus_get_bw_weight(((void *)0), "Wbe", -1);
    Wm = networkstatus_get_bw_weight(((void *)0), "Wbm", -1);
    Wd = networkstatus_get_bw_weight(((void *)0), "Wbd", -1);
    Wg = networkstatus_get_bw_weight(((void *)0), "Wbg", -1);

    Wgb = Wmb = Web = Wdb = weight_scale;
  } else if (rule == NO_WEIGHTING) {
    Wg = Wm = We = Wd = weight_scale;
    Wgb = Wmb = Web = Wdb = weight_scale;
  }

  if (Wg < 0 || Wm < 0 || We < 0 || Wd < 0 || Wgb < 0 || Wmb < 0 || Wdb < 0
      || Web < 0) {
    (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<10), __PRETTY_FUNCTION__, "Got negative bandwidth weights. Defaulting to naive selection" " algorithm."); })

                            ;
    Wg = Wm = We = Wd = weight_scale;
    Wgb = Wmb = Web = Wdb = weight_scale;
  }

  Wg /= weight_scale;
  Wm /= weight_scale;
  We /= weight_scale;
  Wd /= weight_scale;

  Wgb /= weight_scale;
  Wmb /= weight_scale;
  Web /= weight_scale;
  Wdb /= weight_scale;

  bandwidths = tor_calloc_(((sl)->num_used), sizeof(u64_dbl_t) );


  static int warned_missing_bw = 0;
  (void) ({ int node_sl_idx, node_sl_len=(sl)->num_used; const node_t * node; for (node_sl_idx = 0; node_sl_idx < node_sl_len; ++node_sl_idx) { node = (sl)->list[node_sl_idx]; {
    int is_exit = 0, is_guard = 0, is_dir = 0, this_bw = 0;
    double weight = 1;
    double weight_without_guard_flag = 0;
    double final_weight = 0;
    is_exit = node->is_exit && ! node->is_bad_exit;
    is_guard = node->is_possible_guard;
    is_dir = node_is_dir(node);
    if (node->rs) {
      if (!node->rs->has_bandwidth) {


        if (! warned_missing_bw) {
          log_fn_(4, (1u<<12), __PRETTY_FUNCTION__, "Consensus is missing some bandwidths. Using a naive " "router selection algorithm")

                                              ;
          warned_missing_bw = 1;
        }
        this_bw = 30000;
      } else {
        this_bw = kb_to_bytes(node->rs->bandwidth_kb);
      }
    } else if (node->ri) {

      this_bw = bridge_get_advertised_bandwidth_bounded(node->ri);
    } else {

      continue;
    }

    if (is_guard && is_exit) {
      weight = (is_dir ? Wdb*Wd : Wd);
      weight_without_guard_flag = (is_dir ? Web*We : We);
    } else if (is_guard) {
      weight = (is_dir ? Wgb*Wg : Wg);
      weight_without_guard_flag = (is_dir ? Wmb*Wm : Wm);
    } else if (is_exit) {
      weight = (is_dir ? Web*We : We);
    } else {
      weight = (is_dir ? Wmb*Wm : Wm);
    }


    if (this_bw < 0)
      this_bw = 0;
    if (weight < 0.0)
      weight = 0.0;
    if (weight_without_guard_flag < 0.0)
      weight_without_guard_flag = 0.0;
# 2173 "routerlist.c"
    if (node->rs && node->rs->has_guardfraction && rule != WEIGHT_FOR_GUARD) {



      (void) ({ if (__builtin_expect(!!(!(node->rs->is_possible_guard)), 0)) { tor_assertion_failed_(("routerlist.c"), 2177, "???", "node->rs->is_possible_guard"); abort(); } });

      guard_get_guardfraction_bandwidth(&guardfraction_bw,
                                        this_bw,
                                        node->rs->guardfraction_percentage);


      final_weight =
        guardfraction_bw.guard_bw * weight +
        guardfraction_bw.non_guard_bw * weight_without_guard_flag;

      (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<0), __PRETTY_FUNCTION__, "%s: Guardfraction weight %f instead of %f (%s)", node->rs->nickname, final_weight, weight*this_bw, bandwidth_weight_rule_to_string(rule)); })

                                                      ;
    } else {
      final_weight = weight*this_bw;
    }

    bandwidths[node_sl_idx].dbl = final_weight + 0.5;
  } node = ((void *)0); } });

  (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<10), __PRETTY_FUNCTION__, "Generated weighted bandwidths for rule %s based " "on weights " "Wg=%f Wm=%f We=%f Wd=%f with total bw ""%llu", bandwidth_weight_rule_to_string(rule), Wg, Wm, We, Wd, ((long long unsigned int)(weighted_bw))); })



                                                        ;

  *bandwidths_out = bandwidths;

  return 0;
}




double
frac_nodes_with_descriptors(const smartlist_t *sl,
                            bandwidth_weight_rule_t rule)
{
  u64_dbl_t *bandwidths = ((void *)0);
  double total, present;

  if (((sl)->num_used) == 0)
    return 0.0;

  if (compute_weighted_bandwidths(sl, rule, &bandwidths) < 0) {
    int n_with_descs = 0;
    (void) ({ int node_sl_idx, node_sl_len=(sl)->num_used; const node_t * node; for (node_sl_idx = 0; node_sl_idx < node_sl_len; ++node_sl_idx) { node = (sl)->list[node_sl_idx]; { { if (node_has_descriptor(node)) n_with_descs++; }; } node = ((void *)0); } })


      ;
    return ((double)n_with_descs) / (double)((sl)->num_used);
  }

  total = present = 0.0;
  (void) ({ int node_sl_idx, node_sl_len=(sl)->num_used; const node_t * node; for (node_sl_idx = 0; node_sl_idx < node_sl_len; ++node_sl_idx) { node = (sl)->list[node_sl_idx]; {
    const double bw = bandwidths[node_sl_idx].dbl;
    total += bw;
    if (node_has_descriptor(node))
      present += bw;
  } node = ((void *)0); } });

  (void) ({ if (__builtin_expect(!!((bandwidths)!=((void *)0)), 1)) { free(bandwidths); (bandwidths)=((void *)0); } });

  if (total < 1.0)
    return 0;

  return present / total;
}



const node_t *
node_sl_choose_by_bandwidth(const smartlist_t *sl,
                            bandwidth_weight_rule_t rule)
{
  return smartlist_choose_node_by_bandwidth_weights(sl, rule);
}
# 2274 "routerlist.c"
const node_t *
router_choose_random_node(smartlist_t *excludedsmartlist,
                          routerset_t *excludedset,
                          router_crn_flags_t flags)
{
  const int need_uptime = (flags & CRN_NEED_UPTIME) != 0;
  const int need_capacity = (flags & CRN_NEED_CAPACITY) != 0;
  const int need_guard = (flags & CRN_NEED_GUARD) != 0;
  const int allow_invalid = (flags & CRN_ALLOW_INVALID) != 0;
  const int weight_for_exit = (flags & CRN_WEIGHT_AS_EXIT) != 0;
  const int need_desc = (flags & CRN_NEED_DESC) != 0;

  smartlist_t *sl=smartlist_new(),
    *excludednodes=smartlist_new();
  const node_t *choice = ((void *)0);
  const routerinfo_t *r;
  bandwidth_weight_rule_t rule;

  (void) ({ if (__builtin_expect(!!(!(!(weight_for_exit && need_guard))), 0)) { tor_assertion_failed_(("routerlist.c"), 2292, "???", "!(weight_for_exit && need_guard)"); abort(); } });
  rule = weight_for_exit ? WEIGHT_FOR_EXIT :
    (need_guard ? WEIGHT_FOR_GUARD : WEIGHT_FOR_MID);



  if (get_options()->ExcludeSingleHopRelays) {
    (void) ({ int node_sl_idx, node_sl_len=(nodelist_get_list())->num_used; node_t * node; for (node_sl_idx = 0; node_sl_idx < node_sl_len; ++node_sl_idx) { node = (nodelist_get_list())->list[node_sl_idx]; { if (node_allows_single_hop_exits(node)) { smartlist_add(excludednodes, node); }; } node = ((void *)0); } })


        ;
  }

  if ((r = routerlist_find_my_routerinfo()))
    routerlist_add_node_and_family(excludednodes, r);

  router_add_running_nodes_to_smartlist(sl, allow_invalid,
                                        need_uptime, need_capacity,
                                        need_guard, need_desc);
  (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<10), __PRETTY_FUNCTION__, "We found %d running nodes.", ((sl)->num_used)); })

                              ;

  smartlist_subtract(sl,excludednodes);
  (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<10), __PRETTY_FUNCTION__, "We removed %d excludednodes, leaving %d nodes.", ((excludednodes)->num_used), ((sl)->num_used)); })


                              ;

  if (excludedsmartlist) {
    smartlist_subtract(sl,excludedsmartlist);
    (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<10), __PRETTY_FUNCTION__, "We removed %d excludedsmartlist, leaving %d nodes.", ((excludedsmartlist)->num_used), ((sl)->num_used)); })


                                ;
  }
  if (excludedset) {
    routerset_subtract_nodes(sl,excludedset);
    (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<10), __PRETTY_FUNCTION__, "We removed excludedset, leaving %d nodes.", ((sl)->num_used)); })

                                ;
  }


  choice = node_sl_choose_by_bandwidth(sl, rule);

  smartlist_free(sl);
  if (!choice && (need_uptime || need_capacity || need_guard)) {

    log_fn_(6, (1u<<10), __PRETTY_FUNCTION__, "We couldn't find any live%s%s%s routers; falling back " "to list of all routers.", need_capacity?", fast":"", need_uptime?", stable":"", need_guard?", guard":"")




                                     ;
    flags &= ~ (CRN_NEED_UPTIME|CRN_NEED_CAPACITY|CRN_NEED_GUARD);
    choice = router_choose_random_node(
                     excludedsmartlist, excludedset, flags);
  }
  smartlist_free(excludednodes);
  if (!choice) {
    log_fn_(4, (1u<<10), __PRETTY_FUNCTION__, "No available nodes when trying to choose node. Failing.")
                                                                       ;
  }
  return choice;
}
# 2375 "routerlist.c"
int
hex_digest_nickname_decode(const char *hexdigest,
                           char *digest_out,
                           char *nickname_qualifier_char_out,
                           char *nickname_out)
{
  size_t len;

  (void) ({ if (__builtin_expect(!!(!(hexdigest)), 0)) { tor_assertion_failed_(("routerlist.c"), 2383, "???", "hexdigest"); abort(); } });
  if (hexdigest[0] == '$')
    ++hexdigest;

  len = strlen(hexdigest);
  if (len < 40) {
    return -1;
  } else if (len > 40 && (hexdigest[40] == '=' ||
                                    hexdigest[40] == '~') &&
           len <= 40 +1+19) {
    *nickname_qualifier_char_out = hexdigest[40];
    strlcpy(nickname_out, hexdigest+40 +1 , 19 +1);
  } else if (len == 40) {
    ;
  } else {
    return -1;
  }

  if (base16_decode(digest_out, 20, hexdigest, 40)<0)
    return -1;
  return 0;
}





int
hex_digest_nickname_matches(const char *hexdigest, const char *identity_digest,
                            const char *nickname, int is_named)
{
  char digest[20];
  char nn_char='\0';
  char nn_buf[19 +1];

  if (hex_digest_nickname_decode(hexdigest, digest, &nn_char, nn_buf) == -1)
    return 0;

  if (nn_char == '=' || nn_char == '~') {
    if (!nickname)
      return 0;
    if (strcasecmp(nn_buf, nickname))
      return 0;
    if (nn_char == '=' && !is_named)
      return 0;
  }

  return tor_memeq(digest, identity_digest, 20);
}



int
router_is_named(const routerinfo_t *router)
{
  const char *digest =
    networkstatus_get_router_digest_by_nickname(router->nickname);

  return (digest &&
          tor_memeq(digest, router->cache_info.identity_digest, 20));
}




int
router_digest_is_trusted_dir_type(const char *digest, dirinfo_type_t type)
{
  if (!trusted_dir_servers)
    return 0;
  if (authdir_mode(get_options()) && router_digest_is_me(digest))
    return 1;
  (void) ({ int ent_sl_idx, ent_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ent; for (ent_sl_idx = 0; ent_sl_idx < ent_sl_len; ++ent_sl_idx) { ent = (trusted_dir_servers)->list[ent_sl_idx]; { if (tor_memeq(digest, ent->digest, 20)) { return (!type) || ((type & ent->type) != 0); }; } ent = ((void *)0); } })


      ;
  return 0;
}



int
router_addr_is_trusted_dir(uint32_t addr)
{
  if (!trusted_dir_servers)
    return 0;
  (void) ({ int ent_sl_idx, ent_sl_len=(trusted_dir_servers)->num_used; dir_server_t * ent; for (ent_sl_idx = 0; ent_sl_idx < ent_sl_len; ++ent_sl_idx) { ent = (trusted_dir_servers)->list[ent_sl_idx]; { if (ent->addr == addr) return 1;; } ent = ((void *)0); } })


     ;
  return 0;
}





int
hexdigest_to_digest(const char *hexdigest, char *digest)
{
  if (hexdigest[0]=='$')
    ++hexdigest;
  if (strlen(hexdigest) < 40 ||
      base16_decode(digest,20,hexdigest,40) < 0)
    return -1;
  return 0;
}



routerinfo_t *
router_get_mutable_by_digest(const char *digest)
{
  (void) ({ if (__builtin_expect(!!(!(digest)), 0)) { tor_assertion_failed_(("routerlist.c"), 2496, "???", "digest"); abort(); } });

  if (!routerlist) return ((void *)0);



  return rimap_get(routerlist->identity_map, digest);
}



const routerinfo_t *
router_get_by_id_digest(const char *digest)
{
  return router_get_mutable_by_digest(digest);
}



signed_descriptor_t *
router_get_by_descriptor_digest(const char *digest)
{
  (void) ({ if (__builtin_expect(!!(!(digest)), 0)) { tor_assertion_failed_(("routerlist.c"), 2518, "???", "digest"); abort(); } });

  if (!routerlist) return ((void *)0);

  return sdmap_get(routerlist->desc_digest_map, digest);
}




signed_descriptor_t * router_get_by_extrainfo_digest (const char *digest)

{
  (void) ({ if (__builtin_expect(!!(!(digest)), 0)) { tor_assertion_failed_(("routerlist.c"), 2531, "???", "digest"); abort(); } });

  if (!routerlist) return ((void *)0);

  return sdmap_get(routerlist->desc_by_eid_map, digest);
}




signed_descriptor_t *
extrainfo_get_by_descriptor_digest(const char *digest)
{
  extrainfo_t *ei;
  (void) ({ if (__builtin_expect(!!(!(digest)), 0)) { tor_assertion_failed_(("routerlist.c"), 2545, "???", "digest"); abort(); } });
  if (!routerlist) return ((void *)0);
  ei = eimap_get(routerlist->extra_info_map, digest);
  return ei ? &ei->cache_info : ((void *)0);
}
# 2562 "routerlist.c"
static const char *
signed_descriptor_get_body_impl(const signed_descriptor_t *desc,
                                int with_annotations)
{
  const char *r = ((void *)0);
  size_t len = desc->signed_descriptor_len;
  off_t offset = desc->saved_offset;
  if (with_annotations)
    len += desc->annotations_len;
  else
    offset += desc->annotations_len;

  (void) ({ if (__builtin_expect(!!(!(len > 32)), 0)) { tor_assertion_failed_(("routerlist.c"), 2574, "???", "len > 32"); abort(); } });
  if (desc->saved_location == SAVED_IN_CACHE && routerlist) {
    desc_store_t *store = desc_get_store(router_get_routerlist(), desc);
    if (store && store->mmap) {
      (void) ({ if (__builtin_expect(!!(!(desc->saved_offset + len <= store->mmap->size)), 0)) { tor_assertion_failed_(("routerlist.c"), 2578, "???", "desc->saved_offset + len <= store->mmap->size"); abort(); } });
      r = store->mmap->data + offset;
    } else if (store) {
      log_fn_(3, (1u<<13), __PRETTY_FUNCTION__, "We couldn't read a descriptor that is supposedly " "mmaped in our cache.  Is another process running in our data " "directory?  Exiting.")

                                     ;
      exit(1);
    }
  }
  if (!r)
    r = desc->signed_descriptor_body +
      (with_annotations ? 0 : desc->annotations_len);

  (void) ({ if (__builtin_expect(!!(!(r)), 0)) { tor_assertion_failed_(("routerlist.c"), 2591, "???", "r"); abort(); } });
  if (!with_annotations) {
    if ((memcmp(("router "),(r),(7))) && (memcmp(("extra-info "),(r),(11)))) {
      char *cp = tor_strndup_(r, 64 );
      log_fn_(3, (1u<<13), __PRETTY_FUNCTION__, "descriptor at %p begins with unexpected string %s.  " "Is another process running in our data directory?  Exiting.", desc, escaped(cp))

                                ;
      exit(1);
    }
  }

  return r;
}







const char *
signed_descriptor_get_body(const signed_descriptor_t *desc)
{
  return signed_descriptor_get_body_impl(desc, 0);
}



const char *
signed_descriptor_get_annotations(const signed_descriptor_t *desc)
{
  return signed_descriptor_get_body_impl(desc, 1);
}


routerlist_t *
router_get_routerlist(void)
{
  if (__builtin_expect(!!(!routerlist), 0)) {
    routerlist = tor_malloc_zero_(sizeof(routerlist_t) );
    routerlist->routers = smartlist_new();
    routerlist->old_routers = smartlist_new();
    routerlist->identity_map = rimap_new();
    routerlist->desc_digest_map = sdmap_new();
    routerlist->desc_by_eid_map = sdmap_new();
    routerlist->extra_info_map = eimap_new();

    routerlist->desc_store.fname_base = "cached-descriptors";
    routerlist->extrainfo_store.fname_base = "cached-extrainfo";

    routerlist->desc_store.type = ROUTER_STORE;
    routerlist->extrainfo_store.type = EXTRAINFO_STORE;

    routerlist->desc_store.description = "router descriptors";
    routerlist->extrainfo_store.description = "extra-info documents";
  }
  return routerlist;
}


void
routerinfo_free(routerinfo_t *router)
{
  if (!router)
    return;

  (void) ({ if (__builtin_expect(!!((router->cache_info.signed_descriptor_body)!=((void *)0)), 1)) { free(router->cache_info.signed_descriptor_body); (router->cache_info.signed_descriptor_body)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((router->nickname)!=((void *)0)), 1)) { free(router->nickname); (router->nickname)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((router->platform)!=((void *)0)), 1)) { free(router->platform); (router->platform)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((router->contact_info)!=((void *)0)), 1)) { free(router->contact_info); (router->contact_info)=((void *)0); } });
  if (router->onion_pkey)
    crypto_pk_free(router->onion_pkey);
  (void) ({ if (__builtin_expect(!!((router->onion_curve25519_pkey)!=((void *)0)), 1)) { free(router->onion_curve25519_pkey); (router->onion_curve25519_pkey)=((void *)0); } });
  if (router->identity_pkey)
    crypto_pk_free(router->identity_pkey);
  if (router->declared_family) {
    (void) ({ int s_sl_idx, s_sl_len=(router->declared_family)->num_used; char * s; for (s_sl_idx = 0; s_sl_idx < s_sl_len; ++s_sl_idx) { s = (router->declared_family)->list[s_sl_idx]; { (void) ({ if (__builtin_expect(!!((s)!=((void *)0)), 1)) { free(s); (s)=((void *)0); } }); } s = ((void *)0); } });
    smartlist_free(router->declared_family);
  }
  addr_policy_list_free(router->exit_policy);
  short_policy_free(router->ipv6_exit_policy);

  memset(router, 77, sizeof(routerinfo_t));

  (void) ({ if (__builtin_expect(!!((router)!=((void *)0)), 1)) { free(router); (router)=((void *)0); } });
}


void
extrainfo_free(extrainfo_t *extrainfo)
{
  if (!extrainfo)
    return;
  (void) ({ if (__builtin_expect(!!((extrainfo->cache_info.signed_descriptor_body)!=((void *)0)), 1)) { free(extrainfo->cache_info.signed_descriptor_body); (extrainfo->cache_info.signed_descriptor_body)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((extrainfo->pending_sig)!=((void *)0)), 1)) { free(extrainfo->pending_sig); (extrainfo->pending_sig)=((void *)0); } });

  memset(extrainfo, 88, sizeof(extrainfo_t));
  (void) ({ if (__builtin_expect(!!((extrainfo)!=((void *)0)), 1)) { free(extrainfo); (extrainfo)=((void *)0); } });
}


static void
signed_descriptor_free(signed_descriptor_t *sd)
{
  if (!sd)
    return;

  (void) ({ if (__builtin_expect(!!((sd->signed_descriptor_body)!=((void *)0)), 1)) { free(sd->signed_descriptor_body); (sd->signed_descriptor_body)=((void *)0); } });

  memset(sd, 99, sizeof(signed_descriptor_t));
  (void) ({ if (__builtin_expect(!!((sd)!=((void *)0)), 1)) { free(sd); (sd)=((void *)0); } });
}




static signed_descriptor_t *
signed_descriptor_from_routerinfo(routerinfo_t *ri)
{
  signed_descriptor_t *sd;
  (void) ({ if (__builtin_expect(!!(!(ri->purpose == 0)), 0)) { tor_assertion_failed_(("routerlist.c"), 2711, "???", "ri->purpose == ROUTER_PURPOSE_GENERAL"); abort(); } });
  sd = tor_malloc_zero_(sizeof(signed_descriptor_t) );
  memcpy(sd, &(ri->cache_info), sizeof(signed_descriptor_t));
  sd->routerlist_index = -1;
  ri->cache_info.signed_descriptor_body = ((void *)0);
  routerinfo_free(ri);
  return sd;
}


static void
extrainfo_free_(void *e)
{
  extrainfo_free(e);
}


void
routerlist_free(routerlist_t *rl)
{
  if (!rl)
    return;
  rimap_free(rl->identity_map, ((void *)0));
  sdmap_free(rl->desc_digest_map, ((void *)0));
  sdmap_free(rl->desc_by_eid_map, ((void *)0));
  eimap_free(rl->extra_info_map, extrainfo_free_);
  (void) ({ int r_sl_idx, r_sl_len=(rl->routers)->num_used; routerinfo_t * r; for (r_sl_idx = 0; r_sl_idx < r_sl_len; ++r_sl_idx) { r = (rl->routers)->list[r_sl_idx]; { routerinfo_free(r); } r = ((void *)0); } })
                                       ;
  (void) ({ int sd_sl_idx, sd_sl_len=(rl->old_routers)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (rl->old_routers)->list[sd_sl_idx]; { signed_descriptor_free(sd); } sd = ((void *)0); } })
                                               ;
  smartlist_free(rl->routers);
  smartlist_free(rl->old_routers);
  if (rl->desc_store.mmap) {
    int res = tor_munmap_file(routerlist->desc_store.mmap);
    if (res != 0) {
      log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Failed to munmap routerlist->desc_store.mmap");
    }
  }
  if (rl->extrainfo_store.mmap) {
    int res = tor_munmap_file(routerlist->extrainfo_store.mmap);
    if (res != 0) {
      log_fn_(4, (1u<<4), __PRETTY_FUNCTION__, "Failed to munmap routerlist->extrainfo_store.mmap");
    }
  }
  (void) ({ if (__builtin_expect(!!((rl)!=((void *)0)), 1)) { free(rl); (rl)=((void *)0); } });

  router_dir_info_changed();
}



void
dump_routerlist_mem_usage(int severity)
{
  uint64_t livedescs = 0;
  uint64_t olddescs = 0;
  if (!routerlist)
    return;
  (void) ({ int r_sl_idx, r_sl_len=(routerlist->routers)->num_used; routerinfo_t * r; for (r_sl_idx = 0; r_sl_idx < r_sl_len; ++r_sl_idx) { r = (routerlist->routers)->list[r_sl_idx]; { livedescs += r->cache_info.signed_descriptor_len; } r = ((void *)0); } })
                                                                     ;
  (void) ({ int sd_sl_idx, sd_sl_len=(routerlist->old_routers)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (routerlist->old_routers)->list[sd_sl_idx]; { olddescs += sd->signed_descriptor_len; } sd = ((void *)0); } })
                                                          ;

  tor_log(severity, (1u<<13),
      "In %d live descriptors: ""%llu"" bytes.  "
      "In %d old descriptors: ""%llu"" bytes.",
      ((routerlist->routers)->num_used), ((long long unsigned int)(livedescs)),
      ((routerlist->old_routers)->num_used), ((long long unsigned int)(olddescs)));
}





static inline int
routerlist_find_elt_(smartlist_t *sl, void *ri, int idx)
{
  if (idx < 0) {
    idx = -1;
    (void) ({ int r_sl_idx, r_sl_len=(sl)->num_used; routerinfo_t * r; for (r_sl_idx = 0; r_sl_idx < r_sl_len; ++r_sl_idx) { r = (sl)->list[r_sl_idx]; { if (r == ri) { idx = r_sl_idx; break; }; } r = ((void *)0); } })



                        ;
  } else {
    (void) ({ if (__builtin_expect(!!(!(idx < ((sl)->num_used))), 0)) { tor_assertion_failed_(("routerlist.c"), 2796, "???", "idx < smartlist_len(sl)"); abort(); } });
    (void) ({ if (__builtin_expect(!!(!(((sl)->list[idx]) == ri)), 0)) { tor_assertion_failed_(("routerlist.c"), 2797, "???", "smartlist_get(sl, idx) == ri"); abort(); } });
  };
  return idx;
}






static void
routerlist_insert(routerlist_t *rl, routerinfo_t *ri)
{
  routerinfo_t *ri_old;
  signed_descriptor_t *sd_old;
  {
    const routerinfo_t *ri_generated = router_get_my_routerinfo();
    (void) ({ if (__builtin_expect(!!(!(ri_generated != ri)), 0)) { tor_assertion_failed_(("routerlist.c"), 2814, "???", "ri_generated != ri"); abort(); } });
  }
  (void) ({ if (__builtin_expect(!!(!(ri->cache_info.routerlist_index == -1)), 0)) { tor_assertion_failed_(("routerlist.c"), 2816, "???", "ri->cache_info.routerlist_index == -1"); abort(); } });

  ri_old = rimap_set(rl->identity_map, ri->cache_info.identity_digest, ri);
  (void) ({ if (__builtin_expect(!!(!(!ri_old)), 0)) { tor_assertion_failed_(("routerlist.c"), 2819, "???", "!ri_old"); abort(); } });

  sd_old = sdmap_set(rl->desc_digest_map,
                     ri->cache_info.signed_descriptor_digest,
                     &(ri->cache_info));
  if (sd_old) {
    int idx = sd_old->routerlist_index;
    sd_old->routerlist_index = -1;
    smartlist_del(rl->old_routers, idx);
    if (idx < ((rl->old_routers)->num_used)) {
       signed_descriptor_t *d = ((rl->old_routers)->list[idx]);
       d->routerlist_index = idx;
    }
    rl->desc_store.bytes_dropped += sd_old->signed_descriptor_len;
    sdmap_remove(rl->desc_by_eid_map, sd_old->extra_info_digest);
    signed_descriptor_free(sd_old);
  }

  if (!tor_digest_is_zero(ri->cache_info.extra_info_digest))
    sdmap_set(rl->desc_by_eid_map, ri->cache_info.extra_info_digest,
              &ri->cache_info);
  smartlist_add(rl->routers, ri);
  ri->cache_info.routerlist_index = ((rl->routers)->num_used) - 1;
  nodelist_set_routerinfo(ri, ((void *)0));
  router_dir_info_changed();



}




static was_router_added_t extrainfo_insert (routerlist_t *rl, extrainfo_t *ei, int warn_if_incompatible)

{
  was_router_added_t r;
  const char *compatibility_error_msg;
  routerinfo_t *ri = rimap_get(rl->identity_map,
                               ei->cache_info.identity_digest);
  signed_descriptor_t *sd =
    sdmap_get(rl->desc_by_eid_map, ei->cache_info.signed_descriptor_digest);
  extrainfo_t *ei_tmp;
  const int severity = warn_if_incompatible ? 4 : 6;

  {
    extrainfo_t *ei_generated = router_get_my_extrainfo();
    (void) ({ if (__builtin_expect(!!(!(ei_generated != ei)), 0)) { tor_assertion_failed_(("routerlist.c"), 2866, "???", "ei_generated != ei"); abort(); } });
  }

  if (!ri) {

    r = ROUTER_NOT_IN_CONSENSUS;
    goto done;
  }
  if (! sd) {

                               ;
    static ratelim_t no_sd_ratelim = { (1800), 0, 0 };
    r = ROUTER_BAD_EI;
    log_fn_ratelim_(&no_sd_ratelim, severity, (1u<<12), __PRETTY_FUNCTION__, "No entry found in extrainfo map.")
                                                      ;
    goto done;
  }
  if ((!tor_memeq((ei->cache_info.signed_descriptor_digest),(sd->extra_info_digest),(20)))
                                                   ) {
    static ratelim_t digest_mismatch_ratelim = { (1800), 0, 0 };


    r = ROUTER_BAD_EI;
    log_fn_ratelim_(&digest_mismatch_ratelim, severity, (1u<<12), __PRETTY_FUNCTION__, "Mismatch in digest in extrainfo map.")
                                                            ;
    goto done;
  }
  if (routerinfo_incompatible_with_extrainfo(ri, ei, sd,
                                             &compatibility_error_msg)) {
    char d1[40 +1], d2[40 +1];
    r = (ri->cache_info.extrainfo_is_bogus) ?
      ROUTER_BAD_EI : ROUTER_NOT_IN_CONSENSUS;

    base16_encode(d1, sizeof(d1), ri->cache_info.identity_digest, 20);
    base16_encode(d2, sizeof(d2), ei->cache_info.identity_digest, 20);

    log_fn_(severity, (1u<<13), __PRETTY_FUNCTION__, "router info incompatible with extra info (ri id: %s, ei id %s, " "reason: %s)", d1, d2, compatibility_error_msg)

                                                          ;

    goto done;
  }




  ei_tmp = eimap_set(rl->extra_info_map,
                     ei->cache_info.signed_descriptor_digest,
                     ei);
  r = ROUTER_ADDED_SUCCESSFULLY;
  if (ei_tmp) {
    rl->extrainfo_store.bytes_dropped +=
      ei_tmp->cache_info.signed_descriptor_len;
    extrainfo_free(ei_tmp);
  }

 done:
  if (r != ROUTER_ADDED_SUCCESSFULLY)
    extrainfo_free(ei);




  return r;
}







static void
routerlist_insert_old(routerlist_t *rl, routerinfo_t *ri)
{
  {
    const routerinfo_t *ri_generated = router_get_my_routerinfo();
    (void) ({ if (__builtin_expect(!!(!(ri_generated != ri)), 0)) { tor_assertion_failed_(("routerlist.c"), 2943, "???", "ri_generated != ri"); abort(); } });
  }
  (void) ({ if (__builtin_expect(!!(!(ri->cache_info.routerlist_index == -1)), 0)) { tor_assertion_failed_(("routerlist.c"), 2945, "???", "ri->cache_info.routerlist_index == -1"); abort(); } });

  if (directory_caches_dir_info(get_options()) &&
      ri->purpose == 0 &&
      !sdmap_get(rl->desc_digest_map,
                 ri->cache_info.signed_descriptor_digest)) {
    signed_descriptor_t *sd = signed_descriptor_from_routerinfo(ri);
    sdmap_set(rl->desc_digest_map, sd->signed_descriptor_digest, sd);
    smartlist_add(rl->old_routers, sd);
    sd->routerlist_index = ((rl->old_routers)->num_used)-1;
    if (!tor_digest_is_zero(sd->extra_info_digest))
      sdmap_set(rl->desc_by_eid_map, sd->extra_info_digest, sd);
  } else {
    routerinfo_free(ri);
  }



}
# 2973 "routerlist.c"
void
routerlist_remove(routerlist_t *rl, routerinfo_t *ri, int make_old, time_t now)
{
  routerinfo_t *ri_tmp;
  extrainfo_t *ei_tmp;
  int idx = ri->cache_info.routerlist_index;
  (void) ({ if (__builtin_expect(!!(!(0 <= idx && idx < ((rl->routers)->num_used))), 0)) { tor_assertion_failed_(("routerlist.c"), 2979, "???", "0 <= idx && idx < smartlist_len(rl->routers)"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(((rl->routers)->list[idx]) == ri)), 0)) { tor_assertion_failed_(("routerlist.c"), 2980, "???", "smartlist_get(rl->routers, idx) == ri"); abort(); } });

  nodelist_remove_routerinfo(ri);


  rep_hist_note_router_unreachable(ri->cache_info.identity_digest, now);

  ri->cache_info.routerlist_index = -1;
  smartlist_del(rl->routers, idx);
  if (idx < ((rl->routers)->num_used)) {
    routerinfo_t *r = ((rl->routers)->list[idx]);
    r->cache_info.routerlist_index = idx;
  }

  ri_tmp = rimap_remove(rl->identity_map, ri->cache_info.identity_digest);
  router_dir_info_changed();
  (void) ({ if (__builtin_expect(!!(!(ri_tmp == ri)), 0)) { tor_assertion_failed_(("routerlist.c"), 2996, "???", "ri_tmp == ri"); abort(); } });

  if (make_old && directory_caches_dir_info(get_options()) &&
      ri->purpose == 0) {
    signed_descriptor_t *sd;
    sd = signed_descriptor_from_routerinfo(ri);
    smartlist_add(rl->old_routers, sd);
    sd->routerlist_index = ((rl->old_routers)->num_used)-1;
    sdmap_set(rl->desc_digest_map, sd->signed_descriptor_digest, sd);
    if (!tor_digest_is_zero(sd->extra_info_digest))
      sdmap_set(rl->desc_by_eid_map, sd->extra_info_digest, sd);
  } else {
    signed_descriptor_t *sd_tmp;
    sd_tmp = sdmap_remove(rl->desc_digest_map,
                          ri->cache_info.signed_descriptor_digest);
    (void) ({ if (__builtin_expect(!!(!(sd_tmp == &(ri->cache_info))), 0)) { tor_assertion_failed_(("routerlist.c"), 3011, "???", "sd_tmp == &(ri->cache_info)"); abort(); } });
    rl->desc_store.bytes_dropped += ri->cache_info.signed_descriptor_len;
    ei_tmp = eimap_remove(rl->extra_info_map,
                          ri->cache_info.extra_info_digest);
    if (ei_tmp) {
      rl->extrainfo_store.bytes_dropped +=
        ei_tmp->cache_info.signed_descriptor_len;
      extrainfo_free(ei_tmp);
    }
    if (!tor_digest_is_zero(ri->cache_info.extra_info_digest))
      sdmap_remove(rl->desc_by_eid_map, ri->cache_info.extra_info_digest);
    routerinfo_free(ri);
  }



}




static void
routerlist_remove_old(routerlist_t *rl, signed_descriptor_t *sd, int idx)
{
  signed_descriptor_t *sd_tmp;
  extrainfo_t *ei_tmp;
  desc_store_t *store;
  if (idx == -1) {
    idx = sd->routerlist_index;
  }
  (void) ({ if (__builtin_expect(!!(!(0 <= idx && idx < ((rl->old_routers)->num_used))), 0)) { tor_assertion_failed_(("routerlist.c"), 3041, "???", "0 <= idx && idx < smartlist_len(rl->old_routers)"); abort(); } });



  (void) ({ if (__builtin_expect(!!(!(((rl->old_routers)->list[idx]) == sd)), 0)) { tor_assertion_failed_(("routerlist.c"), 3045, "???", "smartlist_get(rl->old_routers, idx) == sd"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(idx == sd->routerlist_index)), 0)) { tor_assertion_failed_(("routerlist.c"), 3046, "???", "idx == sd->routerlist_index"); abort(); } });

  sd->routerlist_index = -1;
  smartlist_del(rl->old_routers, idx);
  if (idx < ((rl->old_routers)->num_used)) {
    signed_descriptor_t *d = ((rl->old_routers)->list[idx]);
    d->routerlist_index = idx;
  }
  sd_tmp = sdmap_remove(rl->desc_digest_map,
                        sd->signed_descriptor_digest);
  (void) ({ if (__builtin_expect(!!(!(sd_tmp == sd)), 0)) { tor_assertion_failed_(("routerlist.c"), 3056, "???", "sd_tmp == sd"); abort(); } });
  store = desc_get_store(rl, sd);
  if (store)
    store->bytes_dropped += sd->signed_descriptor_len;

  ei_tmp = eimap_remove(rl->extra_info_map,
                        sd->extra_info_digest);
  if (ei_tmp) {
    rl->extrainfo_store.bytes_dropped +=
      ei_tmp->cache_info.signed_descriptor_len;
    extrainfo_free(ei_tmp);
  }
  if (!tor_digest_is_zero(sd->extra_info_digest))
    sdmap_remove(rl->desc_by_eid_map, sd->extra_info_digest);

  signed_descriptor_free(sd);



}
# 3085 "routerlist.c"
static void
routerlist_replace(routerlist_t *rl, routerinfo_t *ri_old,
                   routerinfo_t *ri_new)
{
  int idx;
  int same_descriptors;

  routerinfo_t *ri_tmp;
  extrainfo_t *ei_tmp;
  {
    const routerinfo_t *ri_generated = router_get_my_routerinfo();
    (void) ({ if (__builtin_expect(!!(!(ri_generated != ri_new)), 0)) { tor_assertion_failed_(("routerlist.c"), 3096, "???", "ri_generated != ri_new"); abort(); } });
  }
  (void) ({ if (__builtin_expect(!!(!(ri_old != ri_new)), 0)) { tor_assertion_failed_(("routerlist.c"), 3098, "???", "ri_old != ri_new"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(ri_new->cache_info.routerlist_index == -1)), 0)) { tor_assertion_failed_(("routerlist.c"), 3099, "???", "ri_new->cache_info.routerlist_index == -1"); abort(); } });

  idx = ri_old->cache_info.routerlist_index;
  (void) ({ if (__builtin_expect(!!(!(0 <= idx && idx < ((rl->routers)->num_used))), 0)) { tor_assertion_failed_(("routerlist.c"), 3102, "???", "0 <= idx && idx < smartlist_len(rl->routers)"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(((rl->routers)->list[idx]) == ri_old)), 0)) { tor_assertion_failed_(("routerlist.c"), 3103, "???", "smartlist_get(rl->routers, idx) == ri_old"); abort(); } });

  {
    routerinfo_t *ri_old_tmp=((void *)0);
    nodelist_set_routerinfo(ri_new, &ri_old_tmp);
    (void) ({ if (__builtin_expect(!!(!(ri_old == ri_old_tmp)), 0)) { tor_assertion_failed_(("routerlist.c"), 3108, "???", "ri_old == ri_old_tmp"); abort(); } });
  }

  router_dir_info_changed();
  if (idx >= 0) {
    ((rl->routers)->list[idx] = (ri_new));
    ri_old->cache_info.routerlist_index = -1;
    ri_new->cache_info.routerlist_index = idx;

    (void) ({ if (__builtin_expect(!!(!(routerlist_find_elt_(rl->routers, ri_old, -1) == -1)), 0)) { tor_assertion_failed_(("routerlist.c"), 3117, "???", "routerlist_find_elt_(rl->routers, ri_old, -1) == -1"); abort(); } });
  } else {
    log_fn_(4, (1u<<12), __PRETTY_FUNCTION__, "Appending entry from routerlist_replace.");
    routerlist_insert(rl, ri_new);
    return;
  }
  if ((!tor_memeq((ri_old->cache_info.identity_digest),(ri_new->cache_info.identity_digest),(20)))
                                                            ) {

    rimap_remove(rl->identity_map, ri_old->cache_info.identity_digest);
  }
  ri_tmp = rimap_set(rl->identity_map,
                     ri_new->cache_info.identity_digest, ri_new);
  (void) ({ if (__builtin_expect(!!(!(!ri_tmp || ri_tmp == ri_old)), 0)) { tor_assertion_failed_(("routerlist.c"), 3130, "???", "!ri_tmp || ri_tmp == ri_old"); abort(); } });
  sdmap_set(rl->desc_digest_map,
            ri_new->cache_info.signed_descriptor_digest,
            &(ri_new->cache_info));

  if (!tor_digest_is_zero(ri_new->cache_info.extra_info_digest)) {
    sdmap_set(rl->desc_by_eid_map, ri_new->cache_info.extra_info_digest,
              &ri_new->cache_info);
  }

  same_descriptors = tor_memeq(ri_old->cache_info.signed_descriptor_digest,
                              ri_new->cache_info.signed_descriptor_digest,
                              20);

  if (directory_caches_dir_info(get_options()) &&
      ri_old->purpose == 0 &&
      !same_descriptors) {


    signed_descriptor_t *sd = signed_descriptor_from_routerinfo(ri_old);
    smartlist_add(rl->old_routers, sd);
    sd->routerlist_index = ((rl->old_routers)->num_used)-1;
    sdmap_set(rl->desc_digest_map, sd->signed_descriptor_digest, sd);
    if (!tor_digest_is_zero(sd->extra_info_digest))
      sdmap_set(rl->desc_by_eid_map, sd->extra_info_digest, sd);
  } else {

    if (!same_descriptors) {

      sdmap_remove(rl->desc_digest_map,
                   ri_old->cache_info.signed_descriptor_digest);

      if ((!tor_memeq((ri_old->cache_info.extra_info_digest),(ri_new->cache_info.extra_info_digest),(20)))
                                                                  ) {
        ei_tmp = eimap_remove(rl->extra_info_map,
                              ri_old->cache_info.extra_info_digest);
        if (ei_tmp) {
          rl->extrainfo_store.bytes_dropped +=
            ei_tmp->cache_info.signed_descriptor_len;
          extrainfo_free(ei_tmp);
        }
      }

      if (!tor_digest_is_zero(ri_old->cache_info.extra_info_digest)) {
        sdmap_remove(rl->desc_by_eid_map,
                     ri_old->cache_info.extra_info_digest);
      }
    }
    rl->desc_store.bytes_dropped += ri_old->cache_info.signed_descriptor_len;
    routerinfo_free(ri_old);
  }



}



static routerinfo_t *
routerlist_reparse_old(routerlist_t *rl, signed_descriptor_t *sd)
{
  routerinfo_t *ri;
  const char *body;

  body = signed_descriptor_get_annotations(sd);

  ri = router_parse_entry_from_string(body,
                         body+sd->signed_descriptor_len+sd->annotations_len,
                         0, 1, ((void *)0), ((void *)0));
  if (!ri)
    return ((void *)0);
  memcpy(&ri->cache_info, sd, sizeof(signed_descriptor_t));
  sd->signed_descriptor_body = ((void *)0);
  ri->cache_info.routerlist_index = -1;

  routerlist_remove_old(rl, sd, -1);

  return ri;
}


void
routerlist_free_all(void)
{
  routerlist_free(routerlist);
  routerlist = ((void *)0);
  if (warned_nicknames) {
    (void) ({ int cp_sl_idx, cp_sl_len=(warned_nicknames)->num_used; char * cp; for (cp_sl_idx = 0; cp_sl_idx < cp_sl_len; ++cp_sl_idx) { cp = (warned_nicknames)->list[cp_sl_idx]; { (void) ({ if (__builtin_expect(!!((cp)!=((void *)0)), 1)) { free(cp); (cp)=((void *)0); } }); } cp = ((void *)0); } });
    smartlist_free(warned_nicknames);
    warned_nicknames = ((void *)0);
  }
  clear_dir_servers();
  smartlist_free(trusted_dir_servers);
  smartlist_free(fallback_dir_servers);
  trusted_dir_servers = fallback_dir_servers = ((void *)0);
  if (trusted_dir_certs) {
    digestmap_free(trusted_dir_certs, cert_list_free_);
    trusted_dir_certs = ((void *)0);
  }
}



void
routerlist_reset_warnings(void)
{
  if (!warned_nicknames)
    warned_nicknames = smartlist_new();
  (void) ({ int cp_sl_idx, cp_sl_len=(warned_nicknames)->num_used; char * cp; for (cp_sl_idx = 0; cp_sl_idx < cp_sl_len; ++cp_sl_idx) { cp = (warned_nicknames)->list[cp_sl_idx]; { (void) ({ if (__builtin_expect(!!((cp)!=((void *)0)), 1)) { free(cp); (cp)=((void *)0); } }); } cp = ((void *)0); } });
  smartlist_clear(warned_nicknames);

  networkstatus_reset_warnings();
}



int router_descriptor_is_older_than (const routerinfo_t *router, int seconds)

{
  return router->cache_info.published_on < approx_time() - seconds;
}
# 3272 "routerlist.c"
was_router_added_t
router_add_to_routerlist(routerinfo_t *router, const char **msg,
                         int from_cache, int from_fetch)
{
  const char *id_digest;
  const or_options_t *options = get_options();
  int authdir = authdir_mode_handles_descs(options, router->purpose);
  int authdir_believes_valid = 0;
  routerinfo_t *old_router;
  networkstatus_t *consensus =
    networkstatus_get_latest_consensus_by_flavor(FLAV_NS);
  int in_consensus = 0;

  (void) ({ if (__builtin_expect(!!(!(msg)), 0)) { tor_assertion_failed_(("routerlist.c"), 3285, "???", "msg"); abort(); } });

  if (!routerlist)
    router_get_routerlist();

  id_digest = router->cache_info.identity_digest;

  old_router = router_get_mutable_by_digest(id_digest);


  if (sdmap_get(routerlist->desc_digest_map,
                router->cache_info.signed_descriptor_digest)) {






    const int was_bridge = old_router &&
      old_router->purpose == 2;

    if (routerinfo_is_a_configured_bridge(router) &&
        router->purpose == 2 &&
        !was_bridge) {
      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Replacing non-bridge descriptor with bridge " "descriptor for router %s", router_describe(router))

                                       ;
    } else {
      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Dropping descriptor that we already have for router %s", router_describe(router))

                                       ;
      *msg = "Router descriptor was not new.";
      routerinfo_free(router);
      return ROUTER_IS_ALREADY_KNOWN;
    }
  }

  if (authdir) {
    if (authdir_wants_to_reject_router(router, msg,
                                       !from_cache && !from_fetch,
                                       &authdir_believes_valid)) {
      (void) ({ if (__builtin_expect(!!(!(*msg)), 0)) { tor_assertion_failed_(("routerlist.c"), 3326, "???", "*msg"); abort(); } });
      routerinfo_free(router);
      return ROUTER_AUTHDIR_REJECTS;
    }
  } else if (from_fetch) {



    if (!signed_desc_digest_is_recognized(&router->cache_info) &&
        !routerinfo_is_a_configured_bridge(router)) {


      log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Received a no-longer-recognized descriptor for router %s", router_describe(router))

                                       ;
      *msg = "Router descriptor is not referenced by any network-status.";


      if (!from_cache && directory_caches_dir_info(get_options()))
        signed_desc_append_to_journal(&router->cache_info,
                                      &routerlist->desc_store);
      routerlist_insert_old(routerlist, router);
      return ROUTER_NOT_IN_CONSENSUS_OR_NETWORKSTATUS;
    }
  }


  if (consensus) {
    routerstatus_t *rs = networkstatus_vote_find_mutable_entry(
                                                     consensus, id_digest);
    if (rs && tor_memeq(rs->descriptor_digest,
                      router->cache_info.signed_descriptor_digest,
                      20)) {
      in_consensus = 1;
    }
  }

  if (router->purpose == 0 &&
      consensus && !in_consensus && !authdir) {


    if (!from_cache && directory_caches_dir_info(get_options()))
      signed_desc_append_to_journal(&router->cache_info,
                                    &routerlist->desc_store);
    routerlist_insert_old(routerlist, router);
    *msg = "Skipping router descriptor: not in consensus.";
    return ROUTER_NOT_IN_CONSENSUS;
  }





  if (router->purpose == 2 && from_cache &&
      !authdir_mode_bridge(options) &&
      !routerinfo_is_a_configured_bridge(router)) {
    log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Dropping bridge descriptor for %s because we have " "no bridge configured at that address.", safe_str_client(router_describe(router)))

                                                      ;
    *msg = "Router descriptor was not a configured bridge.";
    routerinfo_free(router);
    return ROUTER_WAS_NOT_WANTED;
  }


  if (old_router) {
    if (!in_consensus && (router->cache_info.published_on <=
                          old_router->cache_info.published_on)) {

      (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<13), __PRETTY_FUNCTION__, "Not-new descriptor for router %s", router_describe(router)); })
                                        ;

      if (!from_cache && directory_caches_dir_info(get_options()))
        signed_desc_append_to_journal(&router->cache_info,
                                      &routerlist->desc_store);
      routerlist_insert_old(routerlist, router);
      *msg = "Router descriptor was not new.";
      return ROUTER_IS_ALREADY_KNOWN;
    } else {

      (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<13), __PRETTY_FUNCTION__, "Replacing entry for router %s", router_describe(router)); })
                                        ;
      routerlist_replace(routerlist, old_router, router);
      if (!from_cache) {
        signed_desc_append_to_journal(&router->cache_info,
                                      &routerlist->desc_store);
      }
      *msg = authdir_believes_valid ? "Valid server updated" :
        ("Invalid server updated. (This dirserver is marking your "
         "server as unapproved.)");
      return ROUTER_ADDED_SUCCESSFULLY;
    }
  }

  if (!in_consensus && from_cache &&
      router_descriptor_is_older_than(router, (60*60*24*5))) {
    *msg = "Router descriptor was really old.";
    routerinfo_free(router);
    return ROUTER_WAS_TOO_OLD;
  }



  routerlist_insert(routerlist, router);
  if (!from_cache) {
    signed_desc_append_to_journal(&router->cache_info,
                                  &routerlist->desc_store);
  }
  return ROUTER_ADDED_SUCCESSFULLY;
}





was_router_added_t
router_add_extrainfo_to_routerlist(extrainfo_t *ei, const char **msg,
                                   int from_cache, int from_fetch)
{
  was_router_added_t inserted;
  (void)from_fetch;
  if (msg) *msg = ((void *)0);


  inserted = extrainfo_insert(router_get_routerlist(), ei, !from_cache);

  if (WRA_WAS_ADDED(inserted) && !from_cache)
    signed_desc_append_to_journal(&ei->cache_info,
                                  &routerlist->extrainfo_store);

  return inserted;
}




static int
compare_old_routers_by_identity_(const void **_a, const void **_b)
{
  int i;
  const signed_descriptor_t *r1 = *_a, *r2 = *_b;
  if ((i = (memcmp((r1->identity_digest),(r2->identity_digest),(20)))))
    return i;
  return (int)(r1->published_on - r2->published_on);
}




struct duration_idx_t {
  int duration;
  int idx;
  int old;
};


static int
compare_duration_idx_(const void *_d1, const void *_d2)
{
  const struct duration_idx_t *d1 = _d1;
  const struct duration_idx_t *d2 = _d2;
  return d1->duration - d2->duration;
}
# 3498 "routerlist.c"
static void
routerlist_remove_old_cached_routers_with_id(time_t now,
                                             time_t cutoff, int lo, int hi,
                                             digestset_t *retain)
{
  int i, n = hi-lo+1;
  unsigned n_extra, n_rmv = 0;
  struct duration_idx_t *lifespans;
  uint8_t *rmv, *must_keep;
  smartlist_t *lst = routerlist->old_routers;

  const char *ident;
  (void) ({ if (__builtin_expect(!!(!(hi < ((lst)->num_used))), 0)) { tor_assertion_failed_(("routerlist.c"), 3510, "???", "hi < smartlist_len(lst)"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(lo <= hi)), 0)) { tor_assertion_failed_(("routerlist.c"), 3511, "???", "lo <= hi"); abort(); } });
  ident = ((signed_descriptor_t*)((lst)->list[lo]))->identity_digest;
  for (i = lo+1; i <= hi; ++i) {
    signed_descriptor_t *r = ((lst)->list[i]);
    (void) ({ if (__builtin_expect(!!(!(tor_memeq(ident, r->identity_digest, 20))), 0)) { tor_assertion_failed_(("routerlist.c"), 3515, "???", "tor_memeq(ident, r->identity_digest, DIGEST_LEN)"); abort(); } });
  }


  {
    int mdpr = directory_caches_dir_info(get_options()) ? 2 : 1;
    if (n <= mdpr)
      return;
    n_extra = n - mdpr;
  }

  lifespans = tor_calloc_(n, sizeof(struct duration_idx_t) );
  rmv = tor_calloc_(n, sizeof(uint8_t) );
  must_keep = tor_calloc_(n, sizeof(uint8_t) );


  for (i = lo; i <= hi; ++i) {
    signed_descriptor_t *r = ((lst)->list[i]);
    signed_descriptor_t *r_next;
    lifespans[i-lo].idx = i;
    if (r->last_listed_as_valid_until >= now ||
        (retain && digestset_contains(retain, r->signed_descriptor_digest))) {
      must_keep[i-lo] = 1;
    }
    if (i < hi) {
      r_next = ((lst)->list[i+1]);
      (void) ({ if (__builtin_expect(!!(!(r->published_on <= r_next->published_on)), 0)) { tor_assertion_failed_(("routerlist.c"), 3541, "???", "r->published_on <= r_next->published_on"); abort(); } });
      lifespans[i-lo].duration = (int)(r_next->published_on - r->published_on);
    } else {
      r_next = ((void *)0);
      lifespans[i-lo].duration = 2147483647;
    }
    if (!must_keep[i-lo] && r->published_on < cutoff && n_rmv < n_extra) {
      ++n_rmv;
      lifespans[i-lo].old = 1;
      rmv[i-lo] = 1;
    }
  }

  if (n_rmv < n_extra) {





    qsort(lifespans, n, sizeof(struct duration_idx_t), compare_duration_idx_);
    for (i = 0; i < n && n_rmv < n_extra; ++i) {
      if (!must_keep[lifespans[i].idx-lo] && !lifespans[i].old) {
        rmv[lifespans[i].idx-lo] = 1;
        ++n_rmv;
      }
    }
  }

  i = hi;
  do {
    if (rmv[i-lo])
      routerlist_remove_old(routerlist, ((lst)->list[i]), i);
  } while (--i >= lo);
  (void) ({ if (__builtin_expect(!!((must_keep)!=((void *)0)), 1)) { free(must_keep); (must_keep)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((rmv)!=((void *)0)), 1)) { free(rmv); (rmv)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((lifespans)!=((void *)0)), 1)) { free(lifespans); (lifespans)=((void *)0); } });
}





void
routerlist_remove_old_routers(void)
{
  int i, hi=-1;
  const char *cur_id = ((void *)0);
  time_t now = time(((void *)0));
  time_t cutoff;
  routerinfo_t *router;
  signed_descriptor_t *sd;
  digestset_t *retain;
  const networkstatus_t *consensus = networkstatus_get_latest_consensus();

  trusted_dirs_remove_old_certs();

  if (!routerlist || !consensus)
    return;







  {

    int n_max_retain = ((consensus->routerstatus_list)->num_used);
    retain = digestset_new(n_max_retain);
  }

  cutoff = now - (60*60*24*5);

  if (consensus) {
    (void) ({ int rs_sl_idx, rs_sl_len=(consensus->routerstatus_list)->num_used; routerstatus_t * rs; for (rs_sl_idx = 0; rs_sl_idx < rs_sl_len; ++rs_sl_idx) { rs = (consensus->routerstatus_list)->list[rs_sl_idx]; { if (rs->published_on >= cutoff) digestset_add(retain, rs->descriptor_digest); } rs = ((void *)0); } })

                                                       ;
  }





  if (consensus) {
    cutoff = now - (60*60*48);

    for (i = 0; i < ((routerlist->routers)->num_used); ++i) {
      router = ((routerlist->routers)->list[i]);
      if (router->cache_info.published_on <= cutoff &&
          router->cache_info.last_listed_as_valid_until < now &&
          !digestset_contains(retain,
                          router->cache_info.signed_descriptor_digest)) {


        log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Forgetting obsolete (too old) routerinfo for router %s", router_describe(router))

                                         ;
        routerlist_remove(routerlist, router, 1, now);
        i--;
      }
    }
  }




  cutoff = now - (60*60*24*5);
  for (i = 0; i < ((routerlist->old_routers)->num_used); ++i) {
    sd = ((routerlist->old_routers)->list[i]);
    if (sd->published_on <= cutoff &&
        sd->last_listed_as_valid_until < now &&
        !digestset_contains(retain, sd->signed_descriptor_digest)) {

      routerlist_remove_old(routerlist, sd, i--);
    }
  }



  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "We have %d live routers and %d old router descriptors.", ((routerlist->routers)->num_used), ((routerlist->old_routers)->num_used))

                                                  ;







  if (((routerlist->old_routers)->num_used) <
      ((routerlist->routers)->num_used))
    goto done;


  smartlist_sort(routerlist->old_routers, compare_old_routers_by_identity_);

  for (i = 0; i < ((routerlist->old_routers)->num_used); ++i) {
    signed_descriptor_t *r = ((routerlist->old_routers)->list[i]);
    r->routerlist_index = i;
  }



  for (i = ((routerlist->old_routers)->num_used)-1; i >= 0; --i) {
    signed_descriptor_t *r = ((routerlist->old_routers)->list[i]);
    if (!cur_id) {
      cur_id = r->identity_digest;
      hi = i;
    }
    if ((!tor_memeq((cur_id),(r->identity_digest),(20)))) {
      routerlist_remove_old_cached_routers_with_id(now,
                                                   cutoff, i+1, hi, retain);
      cur_id = r->identity_digest;
      hi = i;
    }
  }
  if (hi>=0)
    routerlist_remove_old_cached_routers_with_id(now, cutoff, 0, hi, retain);


 done:
  digestset_free(retain);
  router_rebuild_store(2, &routerlist->desc_store);
  router_rebuild_store(2,&routerlist->extrainfo_store);
}



void
routerlist_descriptors_added(smartlist_t *sl, int from_cache)
{
  (void) ({ if (__builtin_expect(!!(!(sl)), 0)) { tor_assertion_failed_(("routerlist.c"), 3712, "???", "sl"); abort(); } });
  control_event_descriptors_changed(sl);
  (void) ({ int ri_sl_idx, ri_sl_len=(sl)->num_used; routerinfo_t * ri; for (ri_sl_idx = 0; ri_sl_idx < ri_sl_len; ++ri_sl_idx) { ri = (sl)->list[ri_sl_idx]; {
    if (ri->purpose == 2)
      learned_bridge_descriptor(ri, from_cache);
    if (ri->needs_retest_if_added) {
      ri->needs_retest_if_added = 0;
      dirserv_single_reachability_test(approx_time(), ri);
    }
  } ri = ((void *)0); } });
}
# 3736 "routerlist.c"
int
router_load_single_router(const char *s, uint8_t purpose, int cache,
                          const char **msg)
{
  routerinfo_t *ri;
  was_router_added_t r;
  smartlist_t *lst;
  char annotation_buf[256];
  (void) ({ if (__builtin_expect(!!(!(msg)), 0)) { tor_assertion_failed_(("routerlist.c"), 3744, "???", "msg"); abort(); } });
  *msg = ((void *)0);

  tor_snprintf(annotation_buf, sizeof(annotation_buf),
               "@source controller\n"
               "@purpose %s\n", router_purpose_to_string(purpose));

  if (!(ri = router_parse_entry_from_string(s, ((void *)0), 1, 0,
                                            annotation_buf, ((void *)0)))) {
    log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "Error parsing router descriptor; dropping.");
    *msg = "Couldn't parse router descriptor.";
    return -1;
  }
  (void) ({ if (__builtin_expect(!!(!(ri->purpose == purpose)), 0)) { tor_assertion_failed_(("routerlist.c"), 3757, "???", "ri->purpose == purpose"); abort(); } });
  if (router_is_me(ri)) {
    log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "Router's identity key matches mine; dropping.");
    *msg = "Router's identity key matches mine.";
    routerinfo_free(ri);
    return 0;
  }

  if (!cache)
    ri->cache_info.do_not_cache = 1;

  lst = smartlist_new();
  smartlist_add(lst, ri);
  routers_update_status_from_consensus_networkstatus(lst, 0);

  r = router_add_to_routerlist(ri, msg, 0, 0);
  if (!WRA_WAS_ADDED(r)) {

    (void) ({ if (__builtin_expect(!!(!(*msg)), 0)) { tor_assertion_failed_(("routerlist.c"), 3775, "???", "*msg"); abort(); } });
    if (r == ROUTER_AUTHDIR_REJECTS)
      log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "Couldn't add router to list: %s Dropping.", *msg);
    smartlist_free(lst);
    return 0;
  } else {
    routerlist_descriptors_added(lst, 0);
    smartlist_free(lst);
    (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<13), __PRETTY_FUNCTION__, "Added router to list"); });
    return 1;
  }
}
# 3803 "routerlist.c"
int
router_load_routers_from_string(const char *s, const char *eos,
                                saved_location_t saved_location,
                                smartlist_t *requested_fingerprints,
                                int descriptor_digests,
                                const char *prepend_annotations)
{
  smartlist_t *routers = smartlist_new(), *changed = smartlist_new();
  char fp[40 +1];
  const char *msg;
  int from_cache = (saved_location != SAVED_NOWHERE);
  int allow_annotations = (saved_location != SAVED_NOWHERE);
  int any_changed = 0;
  smartlist_t *invalid_digests = smartlist_new();

  router_parse_list_from_string(&s, eos, routers, saved_location, 0,
                                allow_annotations, prepend_annotations,
                                invalid_digests);

  routers_update_status_from_consensus_networkstatus(routers, !from_cache);

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "%d elements to add", ((routers)->num_used));

  (void) ({ int ri_sl_idx, ri_sl_len=(routers)->num_used; routerinfo_t * ri; for (ri_sl_idx = 0; ri_sl_idx < ri_sl_len; ++ri_sl_idx) { ri = (routers)->list[ri_sl_idx]; {
    was_router_added_t r;
    char d[20];
    if (requested_fingerprints) {
      base16_encode(fp, sizeof(fp), descriptor_digests ?
                      ri->cache_info.signed_descriptor_digest :
                      ri->cache_info.identity_digest,
                    20);
      if (smartlist_contains_string(requested_fingerprints, fp)) {
        smartlist_string_remove(requested_fingerprints, fp);
      } else {
        char *requested =
          smartlist_join_strings(requested_fingerprints," ",0,((void *)0));
        log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "We received a router descriptor with a fingerprint (%s) " "that we never requested. (We asked for: %s.) Dropping.", fp, requested)


                               ;
        (void) ({ if (__builtin_expect(!!((requested)!=((void *)0)), 1)) { free(requested); (requested)=((void *)0); } });
        routerinfo_free(ri);
        continue;
      }
    }

    memcpy(d, ri->cache_info.signed_descriptor_digest, 20);
    r = router_add_to_routerlist(ri, &msg, from_cache, !from_cache);
    if (WRA_WAS_ADDED(r)) {
      any_changed++;
      smartlist_add(changed, ri);
      routerlist_descriptors_added(changed, from_cache);
      smartlist_clear(changed);
    } else if (WRA_NEVER_DOWNLOADABLE(r)) {
      download_status_t *dl_status;
      dl_status = router_get_dl_status_by_descriptor_digest(d);
      if (dl_status) {
        log_fn_(6, (1u<<0), __PRETTY_FUNCTION__, "Marking router %s as never downloadable", hex_str(d, 20))
                                        ;
        download_status_mark_impossible(dl_status);
      }
    }
  } ri = ((void *)0); } });

  (void) ({ int bad_digest_sl_idx, bad_digest_sl_len=(invalid_digests)->num_used; const uint8_t * bad_digest; for (bad_digest_sl_idx = 0; bad_digest_sl_idx < bad_digest_sl_len; ++bad_digest_sl_idx) { bad_digest = (invalid_digests)->list[bad_digest_sl_idx]; {

    base16_encode(fp, sizeof(fp), (char*)bad_digest, 20);
    if (requested_fingerprints && descriptor_digests) {
      if (! smartlist_contains_string(requested_fingerprints, fp)) {

        continue;
      }
      smartlist_string_remove(requested_fingerprints, fp);
    }
    download_status_t *dls;
    dls = router_get_dl_status_by_descriptor_digest((char*)bad_digest);
    if (dls) {
      log_fn_(6, (1u<<0), __PRETTY_FUNCTION__, "Marking router with descriptor %s as unparseable, " "and therefore undownloadable", fp)
                                                  ;
      download_status_mark_impossible(dls);
    }
  } bad_digest = ((void *)0); } });
  (void) ({ int d_sl_idx, d_sl_len=(invalid_digests)->num_used; uint8_t * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (invalid_digests)->list[d_sl_idx]; { (void) ({ if (__builtin_expect(!!((d)!=((void *)0)), 1)) { free(d); (d)=((void *)0); } }); } d = ((void *)0); } });
  smartlist_free(invalid_digests);

  routerlist_assert_ok(routerlist);

  if (any_changed)
    router_rebuild_store(0, &routerlist->desc_store);

  smartlist_free(routers);
  smartlist_free(changed);

  return any_changed;
}




void
router_load_extrainfo_from_string(const char *s, const char *eos,
                                  saved_location_t saved_location,
                                  smartlist_t *requested_fingerprints,
                                  int descriptor_digests)
{
  smartlist_t *extrainfo_list = smartlist_new();
  const char *msg;
  int from_cache = (saved_location != SAVED_NOWHERE);
  smartlist_t *invalid_digests = smartlist_new();

  router_parse_list_from_string(&s, eos, extrainfo_list, saved_location, 1, 0,
                                ((void *)0), invalid_digests);

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "%d elements to add", ((extrainfo_list)->num_used));

  (void) ({ int ei_sl_idx, ei_sl_len=(extrainfo_list)->num_used; extrainfo_t * ei; for (ei_sl_idx = 0; ei_sl_idx < ei_sl_len; ++ei_sl_idx) { ei = (extrainfo_list)->list[ei_sl_idx]; {
      uint8_t d[20];
      memcpy(d, ei->cache_info.signed_descriptor_digest, 20);
      was_router_added_t added =
        router_add_extrainfo_to_routerlist(ei, &msg, from_cache, !from_cache);
      if (WRA_WAS_ADDED(added) && requested_fingerprints) {
        char fp[40 +1];
        base16_encode(fp, sizeof(fp), descriptor_digests ?
                        ei->cache_info.signed_descriptor_digest :
                        ei->cache_info.identity_digest,
                      20);
        smartlist_string_remove(requested_fingerprints, fp);




      } else if (WRA_NEVER_DOWNLOADABLE(added)) {
        signed_descriptor_t *sd = router_get_by_extrainfo_digest((char*)d);
        if (sd) {
          log_fn_(6, (1u<<0), __PRETTY_FUNCTION__, "Marking extrainfo with descriptor %s as " "unparseable, and therefore undownloadable", hex_str((char*)d,20))

                                                ;
          download_status_mark_impossible(&sd->ei_dl_status);
        }
      }
  } ei = ((void *)0); } });

  (void) ({ int bad_digest_sl_idx, bad_digest_sl_len=(invalid_digests)->num_used; const uint8_t * bad_digest; for (bad_digest_sl_idx = 0; bad_digest_sl_idx < bad_digest_sl_len; ++bad_digest_sl_idx) { bad_digest = (invalid_digests)->list[bad_digest_sl_idx]; {

    char fp[40 +1];
    base16_encode(fp, sizeof(fp), (char*)bad_digest, 20);
    if (requested_fingerprints) {
      if (! smartlist_contains_string(requested_fingerprints, fp)) {

        continue;
      }
      smartlist_string_remove(requested_fingerprints, fp);
    }
    signed_descriptor_t *sd =
      router_get_by_extrainfo_digest((char*)bad_digest);
    if (sd) {
      log_fn_(6, (1u<<0), __PRETTY_FUNCTION__, "Marking extrainfo with descriptor %s as " "unparseable, and therefore undownloadable", fp)
                                                               ;
      download_status_mark_impossible(&sd->ei_dl_status);
    }
  } bad_digest = ((void *)0); } });
  (void) ({ int d_sl_idx, d_sl_len=(invalid_digests)->num_used; uint8_t * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (invalid_digests)->list[d_sl_idx]; { (void) ({ if (__builtin_expect(!!((d)!=((void *)0)), 1)) { free(d); (d)=((void *)0); } }); } d = ((void *)0); } });
  smartlist_free(invalid_digests);

  routerlist_assert_ok(routerlist);
  router_rebuild_store(0, &router_get_routerlist()->extrainfo_store);

  smartlist_free(extrainfo_list);
}



static int
signed_desc_digest_is_recognized(signed_descriptor_t *desc)
{
  const routerstatus_t *rs;
  networkstatus_t *consensus = networkstatus_get_latest_consensus();

  if (consensus) {
    rs = networkstatus_vote_find_entry(consensus, desc->identity_digest);
    if (rs && tor_memeq(rs->descriptor_digest,
                      desc->signed_descriptor_digest, 20))
      return 1;
  }
  return 0;
}



void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());
}



void
routerlist_retry_directory_downloads(time_t now)
{
  router_reset_status_download_failures();
  router_reset_descriptor_download_failures();
  if (get_options()->DisableNetwork)
    return;
  update_networkstatus_downloads(now);
  update_all_descriptor_downloads(now);
}



int
router_exit_policy_rejects_all(const routerinfo_t *router)
{
  return router->policy_is_reject_star;
}





static dir_server_t *
dir_server_new(int is_authority,
               const char *nickname,
               const tor_addr_t *addr,
               const char *hostname,
               uint16_t dir_port, uint16_t or_port,
               const char *digest, const char *v3_auth_digest,
               dirinfo_type_t type,
               double weight)
{
  dir_server_t *ent;
  uint32_t a;
  char *hostname_ = ((void *)0);

  if (weight < 0)
    return ((void *)0);

  if (tor_addr_family(addr) == 2)
    a = tor_addr_to_ipv4h(addr);
  else
    return ((void *)0);

  if (!hostname)
    hostname_ = tor_dup_addr(addr);
  else
    hostname_ = tor_strdup_(hostname );

  ent = tor_malloc_zero_(sizeof(dir_server_t) );
  ent->nickname = nickname ? tor_strdup_(nickname ) : ((void *)0);
  ent->address = hostname_;
  ent->addr = a;
  ent->dir_port = dir_port;
  ent->or_port = or_port;
  ent->is_running = 1;
  ent->is_authority = is_authority;
  ent->type = type;
  ent->weight = weight;
  memcpy(ent->digest, digest, 20);
  if (v3_auth_digest && (type & V3_DIRINFO))
    memcpy(ent->v3_identity_digest, v3_auth_digest, 20);

  if (nickname)
    tor_asprintf(&ent->description, "directory server \"%s\" at %s:%d",
                 nickname, hostname, (int)dir_port);
  else
    tor_asprintf(&ent->description, "directory server at %s:%d",
                 hostname, (int)dir_port);

  ent->fake_status.addr = ent->addr;
  memcpy(ent->fake_status.identity_digest, digest, 20);
  if (nickname)
    strlcpy(ent->fake_status.nickname, nickname,
            sizeof(ent->fake_status.nickname));
  else
    ent->fake_status.nickname[0] = '\0';
  ent->fake_status.dir_port = ent->dir_port;
  ent->fake_status.or_port = ent->or_port;

  return ent;
}





dir_server_t *
trusted_dir_server_new(const char *nickname, const char *address,
                       uint16_t dir_port, uint16_t or_port,
                       const char *digest, const char *v3_auth_digest,
                       dirinfo_type_t type, double weight)
{
  uint32_t a;
  tor_addr_t addr;
  char *hostname=((void *)0);
  dir_server_t *result;

  if (!address) {
    if (resolve_my_address(4, get_options(),
                           &a, ((void *)0), &hostname) < 0) {
      log_fn_(4, (1u<<3), __PRETTY_FUNCTION__, "Couldn't find a suitable address when adding ourself as a " "trusted directory server.")

                                           ;
      return ((void *)0);
    }
    if (!hostname)
      hostname = tor_dup_ip(a);
  } else {
    if (tor_lookup_hostname(address, &a)) {
      log_fn_(4, (1u<<3), __PRETTY_FUNCTION__, "Unable to lookup address for directory server at '%s'", address)

                       ;
      return ((void *)0);
    }
    hostname = tor_strdup_(address );
  }
  tor_addr_from_ipv4n((&addr), htonl(a));

  result = dir_server_new(1, nickname, &addr, hostname,
                          dir_port, or_port, digest,
                          v3_auth_digest, type, weight);
  (void) ({ if (__builtin_expect(!!((hostname)!=((void *)0)), 1)) { free(hostname); (hostname)=((void *)0); } });
  return result;
}




dir_server_t *
fallback_dir_server_new(const tor_addr_t *addr,
                        uint16_t dir_port, uint16_t or_port,
                        const char *id_digest, double weight)
{
  return dir_server_new(0, ((void *)0), addr, ((void *)0), dir_port, or_port, id_digest,
                        ((void *)0), ((dirinfo_type_t)((1<<7)-1)), weight);
}


void
dir_server_add(dir_server_t *ent)
{
  if (!trusted_dir_servers)
    trusted_dir_servers = smartlist_new();
  if (!fallback_dir_servers)
    fallback_dir_servers = smartlist_new();

  if (ent->is_authority)
    smartlist_add(trusted_dir_servers, ent);

  smartlist_add(fallback_dir_servers, ent);
  router_dir_info_changed();
}


void
authority_cert_free(authority_cert_t *cert)
{
  if (!cert)
    return;

  (void) ({ if (__builtin_expect(!!((cert->cache_info.signed_descriptor_body)!=((void *)0)), 1)) { free(cert->cache_info.signed_descriptor_body); (cert->cache_info.signed_descriptor_body)=((void *)0); } });
  crypto_pk_free(cert->signing_key);
  crypto_pk_free(cert->identity_key);

  (void) ({ if (__builtin_expect(!!((cert)!=((void *)0)), 1)) { free(cert); (cert)=((void *)0); } });
}


static void
dir_server_free(dir_server_t *ds)
{
  if (!ds)
    return;

  (void) ({ if (__builtin_expect(!!((ds->nickname)!=((void *)0)), 1)) { free(ds->nickname); (ds->nickname)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((ds->description)!=((void *)0)), 1)) { free(ds->description); (ds->description)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((ds->address)!=((void *)0)), 1)) { free(ds->address); (ds->address)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((ds)!=((void *)0)), 1)) { free(ds); (ds)=((void *)0); } });
}


void
clear_dir_servers(void)
{
  if (fallback_dir_servers) {
    (void) ({ int ent_sl_idx, ent_sl_len=(fallback_dir_servers)->num_used; dir_server_t * ent; for (ent_sl_idx = 0; ent_sl_idx < ent_sl_len; ++ent_sl_idx) { ent = (fallback_dir_servers)->list[ent_sl_idx]; { dir_server_free(ent); } ent = ((void *)0); } })
                                           ;
    smartlist_clear(fallback_dir_servers);
  } else {
    fallback_dir_servers = smartlist_new();
  }
  if (trusted_dir_servers) {
    smartlist_clear(trusted_dir_servers);
  } else {
    trusted_dir_servers = smartlist_new();
  }
  router_dir_info_changed();
}







static void
list_pending_downloads(digestmap_t *result, digest256map_t *result256,
                       int purpose, const char *prefix)
{
  const size_t p_len = strlen(prefix);
  smartlist_t *tmp = smartlist_new();
  smartlist_t *conns = get_connection_array();
  int flags = (1<<0);
  if (purpose == 19)
    flags = (1<<2)|(1<<1);

  (void) ({ if (__builtin_expect(!!(!(result || result256)), 0)) { tor_assertion_failed_(("routerlist.c"), 4222, "???", "result || result256"); abort(); } });

  (void) ({ int conn_sl_idx, conn_sl_len=(conns)->num_used; connection_t * conn; for (conn_sl_idx = 0; conn_sl_idx < conn_sl_len; ++conn_sl_idx) { conn = (conns)->list[conn_sl_idx]; {
    if (conn->type == 9 &&
        conn->purpose == purpose &&
        !conn->marked_for_close) {
      const char *resource = TO_DIR_CONN(conn)->requested_resource;
      if (!strcmpstart(resource, prefix))
        dir_split_resource_into_fingerprints(resource + p_len,
                                             tmp, ((void *)0), flags);
    }
  } conn = ((void *)0); } });

  if (result) {
    (void) ({ int d_sl_idx, d_sl_len=(tmp)->num_used; char * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (tmp)->list[d_sl_idx]; { { digestmap_set(result, d, (void*)1); (void) ({ if (__builtin_expect(!!((d)!=((void *)0)), 1)) { free(d); (d)=((void *)0); } }); }; } d = ((void *)0); } })



                      ;
  } else if (result256) {
    (void) ({ int d_sl_idx, d_sl_len=(tmp)->num_used; uint8_t * d; for (d_sl_idx = 0; d_sl_idx < d_sl_len; ++d_sl_idx) { d = (tmp)->list[d_sl_idx]; { { digest256map_set(result256, d, (void*)1); (void) ({ if (__builtin_expect(!!((d)!=((void *)0)), 1)) { free(d); (d)=((void *)0); } }); }; } d = ((void *)0); } })



                      ;
  }
  smartlist_free(tmp);
}




static void
list_pending_descriptor_downloads(digestmap_t *result, int extrainfo)
{
  int purpose =
    extrainfo ? 7 : 6;
  list_pending_downloads(result, ((void *)0), purpose, "d/");
}




void
list_pending_microdesc_downloads(digest256map_t *result)
{
  list_pending_downloads(((void *)0), result, 19, "d/");
}




static void
list_pending_fpsk_downloads(fp_pair_map_t *result)
{
  const char *pfx = "fp-sk/";
  smartlist_t *tmp;
  smartlist_t *conns;
  const char *resource;

  (void) ({ if (__builtin_expect(!!(!(result)), 0)) { tor_assertion_failed_(("routerlist.c"), 4282, "???", "result"); abort(); } });

  tmp = smartlist_new();
  conns = get_connection_array();

  (void) ({ int conn_sl_idx, conn_sl_len=(conns)->num_used; connection_t * conn; for (conn_sl_idx = 0; conn_sl_idx < conn_sl_len; ++conn_sl_idx) { conn = (conns)->list[conn_sl_idx]; {
    if (conn->type == 9 &&
        conn->purpose == 15 &&
        !conn->marked_for_close) {
      resource = TO_DIR_CONN(conn)->requested_resource;
      if (!strcmpstart(resource, pfx))
        dir_split_resource_into_fingerprint_pairs(resource + strlen(pfx),
                                                  tmp);
    }
  } conn = ((void *)0); } });

  (void) ({ int fp_sl_idx, fp_sl_len=(tmp)->num_used; fp_pair_t * fp; for (fp_sl_idx = 0; fp_sl_idx < fp_sl_len; ++fp_sl_idx) { fp = (tmp)->list[fp_sl_idx]; {
    fp_pair_map_set(result, fp, (void*)1);
    (void) ({ if (__builtin_expect(!!((fp)!=((void *)0)), 1)) { free(fp); (fp)=((void *)0); } });
  } fp = ((void *)0); } });

  smartlist_free(tmp);
}






static void initiate_descriptor_downloads (const routerstatus_t *source, int purpose, smartlist_t *digests, int lo, int hi, int pds_flags)


{
  char *resource, *cp;
  int digest_len, enc_digest_len;
  const char *sep;
  int b64_256;
  smartlist_t *tmp;

  if (purpose == 19) {


    digest_len = 32;
    enc_digest_len = 43 + 1;
    sep = "-";
    b64_256 = 1;
  } else {
    digest_len = 20;
    enc_digest_len = 40 + 1;
    sep = "+";
    b64_256 = 0;
  }

  if (lo < 0)
    lo = 0;
  if (hi > ((digests)->num_used))
    hi = ((digests)->num_used);

  if (hi-lo <= 0)
    return;

  tmp = smartlist_new();

  for (; lo < hi; ++lo) {
    cp = tor_malloc_(enc_digest_len );
    if (b64_256) {
      digest256_to_base64(cp, ((digests)->list[lo]));
    } else {
      base16_encode(cp, enc_digest_len, ((digests)->list[lo]),
                    digest_len);
    }
    smartlist_add(tmp, cp);
  }

  cp = smartlist_join_strings(tmp, sep, 0, ((void *)0));
  tor_asprintf(&resource, "d/%s.z", cp);

  (void) ({ int cp1_sl_idx, cp1_sl_len=(tmp)->num_used; char * cp1; for (cp1_sl_idx = 0; cp1_sl_idx < cp1_sl_len; ++cp1_sl_idx) { cp1 = (tmp)->list[cp1_sl_idx]; { (void) ({ if (__builtin_expect(!!((cp1)!=((void *)0)), 1)) { free(cp1); (cp1)=((void *)0); } }); } cp1 = ((void *)0); } });
  smartlist_free(tmp);
  (void) ({ if (__builtin_expect(!!((cp)!=((void *)0)), 1)) { free(cp); (cp)=((void *)0); } });

  if (source) {

    directory_initiate_command_routerstatus(source, purpose,
                                            0,
                                            DIRIND_ONEHOP,
                                            resource, ((void *)0), 0, 0);
  } else {
    directory_get_from_dirserver(purpose, 0, resource,
                                 pds_flags);
  }
  (void) ({ if (__builtin_expect(!!((resource)!=((void *)0)), 1)) { free(resource); (resource)=((void *)0); } });
}



static int
max_dl_per_request(const or_options_t *options, int purpose)
{





  int max = 96;
  if (purpose == 19) {
    max = 92;
  }


  if (!directory_fetches_from_authorities(options)) {
    max = 500;
  }
  return max;
}
# 4414 "routerlist.c"
void
launch_descriptor_downloads(int purpose,
                            smartlist_t *downloadable,
                            const routerstatus_t *source, time_t now)
{
  const or_options_t *options = get_options();
  const char *descname;
  const int fetch_microdesc = (purpose == 19);
  int n_downloadable = ((downloadable)->num_used);

  int i, n_per_request, max_dl_per_req;
  const char *req_plural = "", *rtr_plural = "";
  int pds_flags = (1<<1);

  (void) ({ if (__builtin_expect(!!(!(fetch_microdesc || purpose == 6)), 0)) { tor_assertion_failed_(("routerlist.c"), 4428, "???", "fetch_microdesc || purpose == DIR_PURPOSE_FETCH_SERVERDESC"); abort(); } });
  descname = fetch_microdesc ? "microdesc" : "routerdesc";

  if (!n_downloadable)
    return;

  if (!directory_fetches_dir_info_early(options)) {
    if (n_downloadable >= 16) {
      (void) ({ if (__builtin_expect(!!(log_global_min_severity_ == 7), 0)) log_fn_(7, (1u<<13), __PRETTY_FUNCTION__, "There are enough downloadable %ss to launch requests.", descname); })

                         ;
    } else {


      if ((last_descriptor_download_attempted +
          options->TestingClientMaxIntervalWithoutRequest) > now)
        return;

      if (last_descriptor_download_attempted) {
        log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "There are not many downloadable %ss, but we've " "been waiting long enough (%d seconds). Downloading.", descname, (int)(now-last_descriptor_download_attempted))



                                                               ;
      } else {
        log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "There are not many downloadable %ss, but we haven't " "tried downloading descriptors recently. Downloading.", descname)


                          ;
      }
    }
  }

  if (!authdir_mode_any_nonhidserv(options)) {
# 4472 "routerlist.c"
    pds_flags |= fetch_microdesc ?
      (1<<4) :
      (1<<3);
  }

  n_per_request = (((n_downloadable)+(3)-1)/(3));
  max_dl_per_req = max_dl_per_request(options, purpose);

  if (n_per_request > max_dl_per_req)
    n_per_request = max_dl_per_req;

  if (n_per_request < 4)
    n_per_request = 4;

  if (n_downloadable > n_per_request)
    req_plural = rtr_plural = "s";
  else if (n_downloadable > 1)
    rtr_plural = "s";

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Launching %d request%s for %d %s%s, %d at a time", (((n_downloadable)+(n_per_request)-1)/(n_per_request)), req_plural, n_downloadable, descname, rtr_plural, n_per_request)


                                                               ;
  smartlist_sort_digests(downloadable);
  for (i=0; i < n_downloadable; i += n_per_request) {
    initiate_descriptor_downloads(source, purpose,
                                  downloadable, i, i+n_per_request,
                                  pds_flags);
  }
  last_descriptor_download_attempted = now;
}



void
update_consensus_router_descriptor_downloads(time_t now, int is_vote,
                                             networkstatus_t *consensus)
{
  const or_options_t *options = get_options();
  digestmap_t *map = ((void *)0);
  smartlist_t *no_longer_old = smartlist_new();
  smartlist_t *downloadable = smartlist_new();
  routerstatus_t *source = ((void *)0);
  int authdir = authdir_mode(options);
  int n_delayed=0, n_have=0, n_would_reject=0, n_wouldnt_use=0,
    n_inprogress=0, n_in_oldrouters=0;

  if (directory_too_idle_to_fetch_descriptors(options, now))
    goto done;
  if (!consensus)
    goto done;

  if (is_vote) {

    dir_server_t *ds;
    networkstatus_voter_info_t *voter = ((consensus->voters)->list[0]);
    (void) ({ if (__builtin_expect(!!(!(voter)), 0)) { tor_assertion_failed_(("routerlist.c"), 4528, "???", "voter"); abort(); } });
    ds = trusteddirserver_get_by_v3_auth_digest(voter->identity_digest);
    if (ds)
      source = &(ds->fake_status);
    else
      log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "couldn't lookup source from vote?");
  }

  map = digestmap_new();
  list_pending_descriptor_downloads(map, 0);
  (void) ({ int rsp_sl_idx, rsp_sl_len=(consensus->routerstatus_list)->num_used; void * rsp; for (rsp_sl_idx = 0; rsp_sl_idx < rsp_sl_len; ++rsp_sl_idx) { rsp = (consensus->routerstatus_list)->list[rsp_sl_idx]; {
      routerstatus_t *rs =
        is_vote ? &(((vote_routerstatus_t *)rsp)->status) : rsp;
      signed_descriptor_t *sd;
      if ((sd = router_get_by_descriptor_digest(rs->descriptor_digest))) {
        const routerinfo_t *ri;
        ++n_have;
        if (!(ri = router_get_by_id_digest(rs->identity_digest)) ||
            (!tor_memeq((ri->cache_info.signed_descriptor_digest),(sd->signed_descriptor_digest),(20)))
                                                            ) {




          smartlist_add(no_longer_old, sd);
          ++n_in_oldrouters;
        }
        continue;
      }
      if (digestmap_get(map, rs->descriptor_digest)) {
        ++n_inprogress;
        continue;
      }
      if (!download_status_is_ready(&rs->dl_status, now,
                          options->TestingDescriptorMaxDownloadTries)) {
        ++n_delayed;
        continue;
      }
      if (authdir && dirserv_would_reject_router(rs)) {
        ++n_would_reject;
        continue;
      }
      if (!directory_caches_dir_info(options) &&
          !client_would_use_router(rs, now, options)) {
        ++n_wouldnt_use;
        continue;
      }
      if (is_vote && source) {
        char time_bufnew[19 +1];
        char time_bufold[19 +1];
        const routerinfo_t *oldrouter;
        oldrouter = router_get_by_id_digest(rs->identity_digest);
        format_iso_time(time_bufnew, rs->published_on);
        if (oldrouter)
          format_iso_time(time_bufold, oldrouter->cache_info.published_on);
        log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Learned about %s (%s vs %s) from %s's vote (%s)", routerstatus_describe(rs), time_bufnew, oldrouter ? time_bufold : "none", source->nickname, oldrouter ? "known" : "unknown")



                                                                   ;
      }
      smartlist_add(downloadable, rs->descriptor_digest);
  } rsp = ((void *)0); } });

  if (!authdir_mode_handles_descs(options, 0)
      && ((no_longer_old)->num_used)) {
    routerlist_t *rl = router_get_routerlist();
    log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "%d router descriptors listed in consensus are " "currently in old_routers; making them current.", ((no_longer_old)->num_used))

                                          ;
    (void) ({ int sd_sl_idx, sd_sl_len=(no_longer_old)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (no_longer_old)->list[sd_sl_idx]; {
        const char *msg;
        was_router_added_t r;
        routerinfo_t *ri = routerlist_reparse_old(rl, sd);
        if (!ri) {
          log_fn_(4, (1u<<12), __PRETTY_FUNCTION__, "Failed to re-parse a router.");
          continue;
        }
        r = router_add_to_routerlist(ri, &msg, 1, 0);
        if (WRA_WAS_OUTDATED(r)) {
          log_fn_(4, (1u<<13), __PRETTY_FUNCTION__, "Couldn't add re-parsed router: %s", msg?msg:"???")
                                 ;
        }
    } sd = ((void *)0); } });
    routerlist_assert_ok(rl);
  }

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "%d router descriptors downloadable. %d delayed; %d present " "(%d of those were in old_routers); %d would_reject; " "%d wouldnt_use; %d in progress.", ((downloadable)->num_used), n_delayed, n_have, n_in_oldrouters, n_would_reject, n_wouldnt_use, n_inprogress)




                                                       ;

  launch_descriptor_downloads(6,
                              downloadable, source, now);

  digestmap_free(map, ((void *)0));
 done:
  smartlist_free(downloadable);
  smartlist_free(no_longer_old);
}
# 4639 "routerlist.c"
static void
launch_dummy_descriptor_download_as_needed(time_t now,
                                           const or_options_t *options)
{
  static time_t last_dummy_download = 0;




  if (!options->Address &&
      server_mode(options) &&
      last_descriptor_download_attempted + (20*60) < now &&
      last_dummy_download + (20*60) < now) {
    last_dummy_download = now;
    directory_get_from_dirserver(6,
                                 0, "authority.z",
                                 (1<<1));
  }
}


void
update_router_descriptor_downloads(time_t now)
{
  const or_options_t *options = get_options();
  if (should_delay_dir_fetches(options, ((void *)0)))
    return;
  if (!we_fetch_router_descriptors(options))
    return;

  update_consensus_router_descriptor_downloads(now, 0,
                  networkstatus_get_reasonably_live_consensus(now, FLAV_NS));
}


void
update_extrainfo_downloads(time_t now)
{
  const or_options_t *options = get_options();
  routerlist_t *rl;
  smartlist_t *wanted;
  digestmap_t *pending;
  int old_routers, i, max_dl_per_req;
  int n_no_ei = 0, n_pending = 0, n_have = 0, n_delay = 0, n_bogus[2] = {0,0};
  if (! options->DownloadExtraInfo)
    return;
  if (should_delay_dir_fetches(options, ((void *)0)))
    return;
  if (!router_have_minimum_dir_info())
    return;

  pending = digestmap_new();
  list_pending_descriptor_downloads(pending, 1);
  rl = router_get_routerlist();
  wanted = smartlist_new();
  for (old_routers = 0; old_routers < 2; ++old_routers) {
    smartlist_t *lst = old_routers ? rl->old_routers : rl->routers;
    for (i = 0; i < ((lst)->num_used); ++i) {
      signed_descriptor_t *sd;
      char *d;
      if (old_routers)
        sd = ((lst)->list[i]);
      else
        sd = &((routerinfo_t*)((lst)->list[i]))->cache_info;
      if (sd->is_extrainfo)
        continue;
      if (old_routers && !router_get_by_id_digest(sd->identity_digest))
        continue;
      if (sd->extrainfo_is_bogus)
        continue;
      d = sd->extra_info_digest;
      if (tor_digest_is_zero(d)) {
        ++n_no_ei;
        continue;
      }
      if (eimap_get(rl->extra_info_map, d)) {
        ++n_have;
        continue;
      }
      if (!download_status_is_ready(&sd->ei_dl_status, now,
                          options->TestingDescriptorMaxDownloadTries)) {
        ++n_delay;
        continue;
      }
      if (digestmap_get(pending, d)) {
        ++n_pending;
        continue;
      }

      const signed_descriptor_t *sd2 = router_get_by_extrainfo_digest(d);
      if (sd2 != sd) {
        if (sd2 != ((void *)0)) {
          char d1[40 +1], d2[40 +1];
          char d3[40 +1], d4[40 +1];
          base16_encode(d1, sizeof(d1), sd->identity_digest, 20);
          base16_encode(d2, sizeof(d2), sd2->identity_digest, 20);
          base16_encode(d3, sizeof(d3), d, 20);
          base16_encode(d4, sizeof(d3), sd2->extra_info_digest, 20);

          log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Found an entry in %s with mismatched " "router_get_by_extrainfo_digest() value. This has ID %s " "but the entry in the map has ID %s. This has EI digest " "%s and the entry in the map has EI digest %s.", old_routers?"old_routers":"routers", d1, d2, d3, d4)




                                  ;
        } else {
          char d1[40 +1], d2[40 +1];
          base16_encode(d1, sizeof(d1), sd->identity_digest, 20);
          base16_encode(d2, sizeof(d2), d, 20);

          log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Found an entry in %s with NULL " "router_get_by_extrainfo_digest() value. This has ID %s " "and EI digest %s.", old_routers?"old_routers":"routers", d1, d2)



                          ;
        }
        ++n_bogus[old_routers];
        continue;
      }
      smartlist_add(wanted, d);
    }
  }
  digestmap_free(pending, ((void *)0));

  log_fn_(6, (1u<<13), __PRETTY_FUNCTION__, "Extrainfo download status: %d router with no ei, %d " "with present ei, %d delaying, %d pending, %d downloadable, %d " "bogus in routers, %d bogus in old_routers", n_no_ei, n_have, n_delay, n_pending, ((wanted)->num_used), n_bogus[0], n_bogus[1])



                                  ;

  smartlist_shuffle(wanted);

  max_dl_per_req = max_dl_per_request(options, 7);
  for (i = 0; i < ((wanted)->num_used); i += max_dl_per_req) {
    initiate_descriptor_downloads(((void *)0), 7,
                                  wanted, i, i+max_dl_per_req,
                (1<<1)|(1<<3));
  }

  smartlist_free(wanted);
}




void
router_reset_descriptor_download_failures(void)
{
  networkstatus_reset_download_failures();
  last_descriptor_download_attempted = 0;
  if (!routerlist)
    return;
  (void) ({ int ri_sl_idx, ri_sl_len=(routerlist->routers)->num_used; routerinfo_t * ri; for (ri_sl_idx = 0; ri_sl_idx < ri_sl_len; ++ri_sl_idx) { ri = (routerlist->routers)->list[ri_sl_idx]; { { download_status_reset(&ri->cache_info.ei_dl_status); }; } ri = ((void *)0); } })


    ;
  (void) ({ int sd_sl_idx, sd_sl_len=(routerlist->old_routers)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (routerlist->old_routers)->list[sd_sl_idx]; { { download_status_reset(&sd->ei_dl_status); }; } sd = ((void *)0); } })


    ;
}
# 4811 "routerlist.c"
int
router_differences_are_cosmetic(const routerinfo_t *r1, const routerinfo_t *r2)
{
  time_t r1pub, r2pub;
  long time_difference;
  (void) ({ if (__builtin_expect(!!(!(r1 && r2)), 0)) { tor_assertion_failed_(("routerlist.c"), 4816, "???", "r1 && r2"); abort(); } });


  if (r1->cache_info.published_on > r2->cache_info.published_on) {
    const routerinfo_t *ri_tmp = r2;
    r2 = r1;
    r1 = ri_tmp;
  }


  if (r1->addr != r2->addr ||
      strcasecmp(r1->nickname, r2->nickname) ||
      r1->or_port != r2->or_port ||
      !(0==tor_addr_compare((&r1->ipv6_addr),(&r2->ipv6_addr),CMP_EXACT)) ||
      r1->ipv6_orport != r2->ipv6_orport ||
      r1->dir_port != r2->dir_port ||
      r1->purpose != r2->purpose ||
      !crypto_pk_eq_keys(r1->onion_pkey, r2->onion_pkey) ||
      !crypto_pk_eq_keys(r1->identity_pkey, r2->identity_pkey) ||
      strcasecmp(r1->platform, r2->platform) ||
      (r1->contact_info && !r2->contact_info) ||
      (!r1->contact_info && r2->contact_info) ||
      (r1->contact_info && r2->contact_info &&
       strcasecmp(r1->contact_info, r2->contact_info)) ||
      r1->is_hibernating != r2->is_hibernating ||
      cmp_addr_policies(r1->exit_policy, r2->exit_policy))
    return 0;
  if ((r1->declared_family == ((void *)0)) != (r2->declared_family == ((void *)0)))
    return 0;
  if (r1->declared_family && r2->declared_family) {
    int i, n;
    if (((r1->declared_family)->num_used)!=((r2->declared_family)->num_used))
      return 0;
    n = ((r1->declared_family)->num_used);
    for (i=0; i < n; ++i) {
      if (strcasecmp(((r1->declared_family)->list[i]),
                     ((r2->declared_family)->list[i])))
        return 0;
    }
  }


  if ((r1->bandwidthcapacity < r2->bandwidthcapacity/2) ||
      (r2->bandwidthcapacity < r1->bandwidthcapacity/2))
    return 0;


  if ((r1->bandwidthrate != r2->bandwidthrate) ||
      (r1->bandwidthburst != r2->bandwidthburst))
    return 0;


  if (r1->cache_info.published_on + (2*60*60)
      < r2->cache_info.published_on)
    return 0;



  r1pub = r1->cache_info.published_on;
  r2pub = r2->cache_info.published_on;
  time_difference = labs(r2->uptime - (r1->uptime + (r2pub - r1pub)));
  if (time_difference > (6*60*60) &&
      time_difference > r1->uptime * .05 &&
      time_difference > r2->uptime * .05)
    return 0;


  return 1;
}
# 4894 "routerlist.c"
int
routerinfo_incompatible_with_extrainfo(const routerinfo_t *ri,
                                       extrainfo_t *ei,
                                       signed_descriptor_t *sd,
                                       const char **msg)
{
  int digest_matches, r=1;
  (void) ({ if (__builtin_expect(!!(!(ri)), 0)) { tor_assertion_failed_(("routerlist.c"), 4901, "???", "ri"); abort(); } });
  (void) ({ if (__builtin_expect(!!(!(ei)), 0)) { tor_assertion_failed_(("routerlist.c"), 4902, "???", "ei"); abort(); } });
  if (!sd)
    sd = (signed_descriptor_t*)&ri->cache_info;

  if (ei->bad_sig) {
    if (msg) *msg = "Extrainfo signature was bad, or signed with wrong key.";
    return 1;
  }

  digest_matches = tor_memeq(ei->cache_info.signed_descriptor_digest,
                           sd->extra_info_digest, 20);



  if ((!tor_memeq((ri->cache_info.identity_digest),(ei->cache_info.identity_digest),(20)))

                            ) {
    if (msg) *msg = "Extrainfo nickname or identity did not match routerinfo";
    goto err;
  }

  if (ei->pending_sig) {
    char signed_digest[128];
    if (crypto_pk_public_checksig(ri->identity_pkey,
                       signed_digest, sizeof(signed_digest),
                       ei->pending_sig, ei->pending_sig_len) != 20 ||
        (!tor_memeq((signed_digest),(ei->cache_info.signed_descriptor_digest),(20)))
                          ) {
      ei->bad_sig = 1;
      (void) ({ if (__builtin_expect(!!((ei->pending_sig)!=((void *)0)), 1)) { free(ei->pending_sig); (ei->pending_sig)=((void *)0); } });
      if (msg) *msg = "Extrainfo signature bad, or signed with wrong key";
      goto err;
    }

    ei->cache_info.send_unencrypted = ri->cache_info.send_unencrypted;
    (void) ({ if (__builtin_expect(!!((ei->pending_sig)!=((void *)0)), 1)) { free(ei->pending_sig); (ei->pending_sig)=((void *)0); } });
  }

  if (ei->cache_info.published_on < sd->published_on) {
    if (msg) *msg = "Extrainfo published time did not match routerdesc";
    goto err;
  } else if (ei->cache_info.published_on > sd->published_on) {
    if (msg) *msg = "Extrainfo published time did not match routerdesc";
    r = -1;
    goto err;
  }

  if (!digest_matches) {
    if (msg) *msg = "Extrainfo digest did not match value from routerdesc";
    goto err;
  }

  return 0;
 err:
  if (digest_matches) {



    sd->extrainfo_is_bogus = 1;
  }

  return r;
}



void
routerlist_assert_ok(const routerlist_t *rl)
{
  routerinfo_t *r2;
  signed_descriptor_t *sd2;
  if (!rl)
    return;
  (void) ({ int r_sl_idx, r_sl_len=(rl->routers)->num_used; routerinfo_t * r; for (r_sl_idx = 0; r_sl_idx < r_sl_len; ++r_sl_idx) { r = (rl->routers)->list[r_sl_idx]; {
    r2 = rimap_get(rl->identity_map, r->cache_info.identity_digest);
    (void) ({ if (__builtin_expect(!!(!(r == r2)), 0)) { tor_assertion_failed_(("routerlist.c"), 4977, "???", "r == r2"); abort(); } });
    sd2 = sdmap_get(rl->desc_digest_map,
                    r->cache_info.signed_descriptor_digest);
    (void) ({ if (__builtin_expect(!!(!(&(r->cache_info) == sd2)), 0)) { tor_assertion_failed_(("routerlist.c"), 4980, "???", "&(r->cache_info) == sd2"); abort(); } });
    (void) ({ if (__builtin_expect(!!(!(r->cache_info.routerlist_index == r_sl_idx)), 0)) { tor_assertion_failed_(("routerlist.c"), 4981, "???", "r->cache_info.routerlist_index == r_sl_idx"); abort(); } });
# 5005 "routerlist.c"
  } r = ((void *)0); } });
  (void) ({ int sd_sl_idx, sd_sl_len=(rl->old_routers)->num_used; signed_descriptor_t * sd; for (sd_sl_idx = 0; sd_sl_idx < sd_sl_len; ++sd_sl_idx) { sd = (rl->old_routers)->list[sd_sl_idx]; {
    r2 = rimap_get(rl->identity_map, sd->identity_digest);
    (void) ({ if (__builtin_expect(!!(!(!r2 || sd != &(r2->cache_info))), 0)) { tor_assertion_failed_(("routerlist.c"), 5008, "???", "!r2 || sd != &(r2->cache_info)"); abort(); } });
    sd2 = sdmap_get(rl->desc_digest_map, sd->signed_descriptor_digest);
    (void) ({ if (__builtin_expect(!!(!(sd == sd2)), 0)) { tor_assertion_failed_(("routerlist.c"), 5010, "???", "sd == sd2"); abort(); } });
    (void) ({ if (__builtin_expect(!!(!(sd->routerlist_index == sd_sl_idx)), 0)) { tor_assertion_failed_(("routerlist.c"), 5011, "???", "sd->routerlist_index == sd_sl_idx"); abort(); } });







  } sd = ((void *)0); } });

  (void) ({ digestmap_iter_t *d_iter; for (d_iter = digestmap_iter_init(rimap_to_digestmap(rl->identity_map)); !digestmap_iter_done(d_iter); d_iter = digestmap_iter_next(rimap_to_digestmap(rl->identity_map), d_iter)) { const char * d; void *r_voidp; routerinfo_t * r; digestmap_iter_get(d_iter, &d, &r_voidp); r = r_voidp; {
    (void) ({ if (__builtin_expect(!!(!(tor_memeq(r->cache_info.identity_digest, d, 20))), 0)) { tor_assertion_failed_(("routerlist.c"), 5022, "???", "tor_memeq(r->cache_info.identity_digest, d, DIGEST_LEN)"); abort(); } });
  } } }) ;;
  (void) ({ digestmap_iter_t *d_iter; for (d_iter = digestmap_iter_init(sdmap_to_digestmap(rl->desc_digest_map)); !digestmap_iter_done(d_iter); d_iter = digestmap_iter_next(sdmap_to_digestmap(rl->desc_digest_map), d_iter)) { const char * d; void *sd_voidp; signed_descriptor_t * sd; digestmap_iter_get(d_iter, &d, &sd_voidp); sd = sd_voidp; {
    (void) ({ if (__builtin_expect(!!(!(tor_memeq(sd->signed_descriptor_digest, d, 20))), 0)) { tor_assertion_failed_(("routerlist.c"), 5025, "???", "tor_memeq(sd->signed_descriptor_digest, d, DIGEST_LEN)"); abort(); } });
  } } }) ;;
  (void) ({ digestmap_iter_t *d_iter; for (d_iter = digestmap_iter_init(sdmap_to_digestmap(rl->desc_by_eid_map)); !digestmap_iter_done(d_iter); d_iter = digestmap_iter_next(sdmap_to_digestmap(rl->desc_by_eid_map), d_iter)) { const char * d; void *sd_voidp; signed_descriptor_t * sd; digestmap_iter_get(d_iter, &d, &sd_voidp); sd = sd_voidp; {
    (void) ({ if (__builtin_expect(!!(!(!tor_digest_is_zero(d))), 0)) { tor_assertion_failed_(("routerlist.c"), 5028, "???", "!tor_digest_is_zero(d)"); abort(); } });
    (void) ({ if (__builtin_expect(!!(!(sd)), 0)) { tor_assertion_failed_(("routerlist.c"), 5029, "???", "sd"); abort(); } });
    (void) ({ if (__builtin_expect(!!(!(tor_memeq(sd->extra_info_digest, d, 20))), 0)) { tor_assertion_failed_(("routerlist.c"), 5030, "???", "tor_memeq(sd->extra_info_digest, d, DIGEST_LEN)"); abort(); } });
  } } }) ;;
  (void) ({ digestmap_iter_t *d_iter; for (d_iter = digestmap_iter_init(eimap_to_digestmap(rl->extra_info_map)); !digestmap_iter_done(d_iter); d_iter = digestmap_iter_next(eimap_to_digestmap(rl->extra_info_map), d_iter)) { const char * d; void *ei_voidp; extrainfo_t * ei; digestmap_iter_get(d_iter, &d, &ei_voidp); ei = ei_voidp; {
    signed_descriptor_t *sd;
    (void) ({ if (__builtin_expect(!!(!(tor_memeq(ei->cache_info.signed_descriptor_digest, d, 20))), 0)) { tor_assertion_failed_((
 "routerlist.c"
# 5034 "routerlist.c"
    ),
 5035
# 5034 "routerlist.c"
    , "???", "tor_memeq(ei->cache_info.signed_descriptor_digest, d, DIGEST_LEN)"); abort(); } })
                                      ;
    sd = sdmap_get(rl->desc_by_eid_map,
                   ei->cache_info.signed_descriptor_digest);

    if (sd) {
      (void) ({ if (__builtin_expect(!!(!(tor_memeq(ei->cache_info.signed_descriptor_digest, sd->extra_info_digest, 20))), 0)) { tor_assertion_failed_((
 "routerlist.c"
# 5040 "routerlist.c"
      ),
 5041
# 5040 "routerlist.c"
      , "???", "tor_memeq(ei->cache_info.signed_descriptor_digest, sd->extra_info_digest, DIGEST_LEN)"); abort(); } })
                                                            ;
    }
  } } }) ;;
}
# 5056 "routerlist.c"
const char *
esc_router_info(const routerinfo_t *router)
{
  static char *info=((void *)0);
  char *esc_contact, *esc_platform;
  (void) ({ if (__builtin_expect(!!((info)!=((void *)0)), 1)) { free(info); (info)=((void *)0); } });

  if (!router)
    return ((void *)0);

  esc_contact = esc_for_log(router->contact_info);
  esc_platform = esc_for_log(router->platform);

  tor_asprintf(&info, "Contact %s, Platform %s", esc_contact, esc_platform);
  (void) ({ if (__builtin_expect(!!((esc_contact)!=((void *)0)), 1)) { free(esc_contact); (esc_contact)=((void *)0); } });
  (void) ({ if (__builtin_expect(!!((esc_platform)!=((void *)0)), 1)) { free(esc_platform); (esc_platform)=((void *)0); } });

  return info;
}



static int
compare_routerinfo_by_id_digest_(const void **a, const void **b)
{
  routerinfo_t *first = *(routerinfo_t **)a, *second = *(routerinfo_t **)b;
  return (memcmp((first->cache_info.identity_digest),(second->cache_info.identity_digest),(20)))

                           ;
}


void
routers_sort_by_identity(smartlist_t *routers)
{
  smartlist_sort(routers, compare_routerinfo_by_id_digest_);
}




void
refresh_all_country_info(void)
{
  const or_options_t *options = get_options();

  if (options->EntryNodes)
    routerset_refresh_countries(options->EntryNodes);
  if (options->ExitNodes)
    routerset_refresh_countries(options->ExitNodes);
  if (options->ExcludeNodes)
    routerset_refresh_countries(options->ExcludeNodes);
  if (options->ExcludeExitNodes)
    routerset_refresh_countries(options->ExcludeExitNodes);
  if (options->ExcludeExitNodesUnion_)
    routerset_refresh_countries(options->ExcludeExitNodesUnion_);

  nodelist_refresh_countries();
}





int
hid_serv_get_responsible_directories(smartlist_t *responsible_dirs,
                                     const char *id)
{
  int start, found, n_added = 0, i;
  networkstatus_t *c = networkstatus_get_latest_consensus();
  if (!c || !((c->routerstatus_list)->num_used)) {
    log_fn_(4, (1u<<11), __PRETTY_FUNCTION__, "We don't have a consensus, so we can't perform v2 " "rendezvous operations.")
                                      ;
    return -1;
  }
  (void) ({ if (__builtin_expect(!!(!(id)), 0)) { tor_assertion_failed_(("routerlist.c"), 5131, "???", "id"); abort(); } });
  start = networkstatus_vote_find_entry_idx(c, id, &found);
  if (start == ((c->routerstatus_list)->num_used)) start = 0;
  i = start;
  do {
    routerstatus_t *r = ((c->routerstatus_list)->list[i]);
    if (r->is_hs_dir) {
      smartlist_add(responsible_dirs, r);
      if (++n_added == 3)
        return 0;
    }
    if (++i == ((c->routerstatus_list)->num_used))
      i = 0;
  } while (i != start);



  return ((responsible_dirs)->num_used) ? 0 : -1;
}



int
hid_serv_acting_as_directory(void)
{
  const routerinfo_t *me = router_get_my_routerinfo();
  if (!me)
    return 0;
  if (!get_options()->HidServDirectoryV2) {
    log_fn_(6, (1u<<11), __PRETTY_FUNCTION__, "We are not acting as hidden service directory, " "because we have not been configured as such.")
                                                                     ;
    return 0;
  }
  return 1;
}



int
hid_serv_responsible_for_desc_id(const char *query)
{
  const routerinfo_t *me;
  routerstatus_t *last_rs;
  const char *my_id, *last_id;
  int result;
  smartlist_t *responsible;
  if (!hid_serv_acting_as_directory())
    return 0;
  if (!(me = router_get_my_routerinfo()))
    return 0;
  my_id = me->cache_info.identity_digest;
  responsible = smartlist_new();
  if (hid_serv_get_responsible_directories(responsible, query) < 0) {
    smartlist_free(responsible);
    return 0;
  }
  last_rs = ((responsible)->list[((responsible)->num_used)-1]);
  last_id = last_rs->identity_digest;
  result = rend_id_is_in_interval(my_id, query, last_id);
  smartlist_free(responsible);
  return result;
}
